# MCP рдкреНрд░реЛрдЯреЛрдХрд▓ рд╕реБрд╡рд┐рдзрд╛ рдЧрд╣рд┐рд░реЛ рдЕрдиреНрд╡реЗрд╖рдг

рдпреЛ рдорд╛рд░реНрдЧрджрд░реНрд╢рд┐рдХрд╛рд▓реЗ рдЖрдзрд╛рд░рднреВрдд рдЙрдкрдХрд░рдг рд░ рд╕реНрд░реЛрдд рд╡реНрдпрд╡рд╕реНрдерд╛рдкрди рднрдиреНрджрд╛ рдкрд░ рдЧрдПрд░ рдЙрдиреНрдирдд MCP рдкреНрд░реЛрдЯреЛрдХрд▓ рд╕реБрд╡рд┐рдзрд╛рд╣рд░реВ рдЕрдиреНрд╡реЗрд╖рдг рдЧрд░реНрдЫред рдпреА рд╕реБрд╡рд┐рдзрд╛рд╣рд░реВ рдмреБрдЭреНрджрд╛ рддрдкрд╛рдИрдВрд▓реЗ рдердк рдмрд▓рд┐рдпреЛ, рдкреНрд░рдпреЛрдЧрдХрд░реНрддрд╛рдореИрддреНрд░реА рд░ рдЙрддреНрдкрд╛рджрди-рддрдп MCP рд╕рд░реНрднрд░рд╣рд░реВ рдирд┐рд░реНрдорд╛рдг рдЧрд░реНрди рд╕рдХреНрдиреБрд╣реБрдиреНрдЫред

## рд╕рдореЗрдЯрд┐рдПрдХрд╛ рд╕реБрд╡рд┐рдзрд╛рд╣рд░реВ

1. **рдкреНрд░рдЧрддрд┐ рд╕реВрдЪрдирд╛рд╣рд░реВ** - рд▓рд╛рдореЛ рд╕рдордп рдЪрд▓реНрдиреЗ рдЕрдкрд░реЗрд╕рдирд╣рд░реВрдХреЛ рдкреНрд░рдЧрддрд┐рдХреЛ рд░рд┐рдкреЛрд░реНрдЯ рдЧрд░реНрдиреБрд╣реЛрд╕реН
2. **рдЕрдиреБрд░реЛрдз рд░рджреНрджреАрдХрд░рдг** - рдЧреНрд░рд╛рд╣рдХрд╣рд░реВрд▓реЗ рдЪрд▓рд┐рд░рд╣реЗрдХрд╛ рдЕрдиреБрд░реЛрдзрд╣рд░реВ рд░рджреНрдж рдЧрд░реНрди рд╕рдХреНрдиреЗ рдЕрдиреБрдорддрд┐
3. **рд╕реНрд░реЛрдд рдЯреЗрдореНрдкреНрд▓реЗрдЯрд╣рд░реВ** - рдкреНрдпрд╛рд░рд╛рдорд┐рдЯрд░рд╣рд░реВрд╕рдБрдЧ рдЧрддрд┐рд╢реАрд▓ рд╕реНрд░реЛрдд URI рд╣рд░реВ
4. **рд╕рд░реНрднрд░ рдЬреАрд╡рдирдЪрдХреНрд░ рдШрдЯрдирд╛** - рдЙрдЪрд┐рдд рдЖрд░рдореНрдн рд░ рдмрдиреНрдж рдкреНрд░рдХреНрд░рд┐рдпрд╛рд╣рд░реВ
5. **рд▓рдЧрд┐рдЩ рдирд┐рдпрдиреНрддреНрд░рдг** - рд╕рд░реНрднрд░-рдкрдХреНрд╖рдХреЛ рд▓рдЧрд┐рдЩ рдХрдиреНрдлрд┐рдЧрд░реЗрд╕рди
6. **рддреНрд░реБрдЯрд┐ рд╣реНрдпрд╛рдиреНрдбрд▓рд┐рдЩ рдврд╛рдБрдЪрд╛** - рд╕реБрд╕рдВрдЧрдд рддреНрд░реБрдЯрд┐ рдкреНрд░рддрд┐рдХреНрд░рд┐рдпрд╛

---

## рез. рдкреНрд░рдЧрддрд┐ рд╕реВрдЪрдирд╛рд╣рд░реВ

рд╕рдордп рд▓рд╛рдЧреНрдиреЗ рдЕрдкрд░реЗрд╕рдирд╣рд░реВ (рдбреЗрдЯрд╛ рдкреНрд░рд╢реЛрдзрди, рдлрд╛рдЗрд▓ рдбрд╛рдЙрдирд▓реЛрдб, API рдХрд▓рд╣рд░реВ) рдХрд╛ рд▓рд╛рдЧрд┐ рдкреНрд░рдЧрддрд┐ рд╕реВрдЪрдирд╛рд▓реЗ рдкреНрд░рдпреЛрдЧрдХрд░реНрддрд╛рд╣рд░реВрд▓рд╛рдИ рдЬрд╛рдирдХрд╛рд░реАрдорд╛ рд░рд╛рдЦреНрдЫред

### рдпрд╕рд▓реЗ рдХрд╕рд░реА рдХрд╛рдо рдЧрд░реНрдЫ

```mermaid
sequenceDiagram
    participant Client
    participant Server
    
    Client->>Server: tools/call (рд▓рд╛рдореЛ рдЕрдкрд░реЗрд╕рди)
    Server-->>Client: рд╕реВрдЪрдирд╛: рдкреНрд░рдЧрддрд┐ резреж%
    Server-->>Client: рд╕реВрдЪрдирд╛: рдкреНрд░рдЧрддрд┐ релреж%
    Server-->>Client: рд╕реВрдЪрдирд╛: рдкреНрд░рдЧрддрд┐ репреж%
    Server->>Client: рдирддрд┐рдЬрд╛ (рдкреВрд░рд╛)
```
### Python рдХрд╛рд░реНрдпрд╛рдиреНрд╡рдпрди

```python
from mcp.server import Server, NotificationOptions
from mcp.types import ProgressNotification
import asyncio

app = Server("progress-server")

@app.tool()
async def process_large_file(file_path: str, ctx) -> str:
    """Process a large file with progress updates."""
    
    # рдкреНрд░рдЧрддрд┐ рдЧрдгрдирд╛рдХреЛ рд▓рд╛рдЧрд┐ рдлрд╛рдЗрд▓ рдЖрдХрд╛рд░ рдкреНрд░рд╛рдкреНрдд рдЧрд░реНрдиреБрд╣реЛрд╕реН
    file_size = os.path.getsize(file_path)
    processed = 0
    
    with open(file_path, 'rb') as f:
        while chunk := f.read(8192):
            # рдЦрдиреНрдб рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдЧрд░реНрдиреБрд╣реЛрд╕реН
            await process_chunk(chunk)
            processed += len(chunk)
            
            # рдкреНрд░рдЧрддрд┐ рд╕реВрдЪрди рдкрдард╛рдЙрдиреБрд╣реЛрд╕реН
            progress = (processed / file_size) * 100
            await ctx.send_notification(
                ProgressNotification(
                    progressToken=ctx.request_id,
                    progress=progress,
                    total=100,
                    message=f"Processing: {progress:.1f}%"
                )
            )
    
    return f"Processed {file_size} bytes"

@app.tool()
async def batch_operation(items: list[str], ctx) -> str:
    """Process multiple items with progress."""
    
    results = []
    total = len(items)
    
    for i, item in enumerate(items):
        result = await process_item(item)
        results.append(result)
        
        # рдкреНрд░рддреНрдпреЗрдХ рд╡рд╕реНрддреБ рдкрдЫрд┐ рдкреНрд░рдЧрддрд┐ рд░рд┐рдкреЛрд░реНрдЯ рдЧрд░реНрдиреБрд╣реЛрд╕реН
        await ctx.send_notification(
            ProgressNotification(
                progressToken=ctx.request_id,
                progress=i + 1,
                total=total,
                message=f"Processed {i + 1}/{total}: {item}"
            )
        )
    
    return f"Completed {total} items"
```

### TypeScript рдХрд╛рд░реНрдпрд╛рдиреНрд╡рдпрди

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";

server.setRequestHandler(CallToolSchema, async (request, extra) => {
  const { name, arguments: args } = request.params;
  
  if (name === "process_data") {
    const items = args.items as string[];
    const results = [];
    
    for (let i = 0; i < items.length; i++) {
      const result = await processItem(items[i]);
      results.push(result);
      
      // рдкреНрд░рдЧрддрд┐ рд╕реВрдЪрд┐рдд рдЧрд░реНрдиреБрд╣реЛрд╕реН
      await extra.sendNotification({
        method: "notifications/progress",
        params: {
          progressToken: request.id,
          progress: i + 1,
          total: items.length,
          message: `Processing item ${i + 1}/${items.length}`
        }
      });
    }
    
    return { content: [{ type: "text", text: JSON.stringify(results) }] };
  }
});
```

### рдЧреНрд░рд╛рд╣рдХ-рдкрдХреНрд╖ рд╣реНрдпрд╛рдиреНрдбрд▓рд┐рдЩ (Python)

```python
async def handle_progress(notification):
    """Handle progress notifications from server."""
    params = notification.params
    print(f"Progress: {params.progress}/{params.total} - {params.message}")

# рд╣реНрдпрд╛рдиреНрдбрд▓рд░ рджрд░реНрддрд╛ рдЧрд░реНрдиреБрд╣реЛрд╕реН
session.on_notification("notifications/progress", handle_progress)

# рдЙрдкрдХрд░рдг рдХрд▓ рдЧрд░реНрдиреБрд╣реЛрд╕реН (рдкреНрд░рдЧрддрд┐рдХреЛ рдЕрдкрдбреЗрдЯрд╣рд░реВ рд╣реНрдпрд╛рдиреНрдбрд▓рд░рдорд╛рд░реНрдлрдд рдЖрдЙрдиреЗрдЫрдиреН)
result = await session.call_tool("process_large_file", {"file_path": "/data/large.csv"})
```

---

## реи. рдЕрдиреБрд░реЛрдз рд░рджреНрджреАрдХрд░рдг

рдЧреНрд░рд╛рд╣рдХрд╣рд░реВрд▓реЗ рдЖрд╡рд╢реНрдпрдХ рдирд╛рдШреЗрдХрд╛ рд╡рд╛ рдзреЗрд░реИ рд▓рд╛рдореЛ рд╕рдордп рд▓рд┐рдПрд░ рд░рд╣реЗрдХрд╛ рдЕрдиреБрд░реЛрдзрд╣рд░реВ рд░рджреНрдж рдЧрд░реНрди рд╕рдХреНрдиреЗ рд╕реБрд╡рд┐рдзрд╛ред

### Python рдХрд╛рд░реНрдпрд╛рдиреНрд╡рдпрди

```python
from mcp.server import Server
from mcp.types import CancelledError
import asyncio

app = Server("cancellable-server")

@app.tool()
async def long_running_search(query: str, ctx) -> str:
    """Search that can be cancelled."""
    
    results = []
    
    try:
        for page in range(100):  # рдзреЗрд░реИ рдкреГрд╖реНрдард╣рд░реВ рдорд╛рд░реНрдлрдд рдЦреЛрдЬреА рдЧрд░реНрдиреБрд╣реЛрд╕реН
            # рд░рджреНрджреАрдХрд░рдг рдЕрдиреБрд░реЛрдз рдЧрд░рд┐рдПрдХреЛ рдЫ рдХрд┐ рдЫреИрди рдЬрд╛рдБрдЪ рдЧрд░реНрдиреБрд╣реЛрд╕реН
            if ctx.is_cancelled:
                raise CancelledError("Search cancelled by user")
            
            # рдкреГрд╖реНрда рдЦреЛрдЬреАрдХреЛ рдЕрдиреБрдХрд░рдг рдЧрд░реНрдиреБрд╣реЛрд╕реН
            page_results = await search_page(query, page)
            results.extend(page_results)
            
            # рд╕рд╛рдиреЛрддрд┐рдиреЛ рдврд┐рд▓рд╛рдЗрд▓реЗ рд░рджреНрджреАрдХрд░рдг рдЬрд╛рдБрдЪрд╣рд░реВ рдЧрд░реНрди рдЕрдиреБрдорддрд┐ рджрд┐рдиреНрдЫ
            await asyncio.sleep(0.1)
            
    except CancelledError:
        # рдЖрдВрд╢рд┐рдХ рдкрд░рд┐рдгрд╛рдорд╣рд░реВ рдлрд░реНрдХрд╛рдЙрдиреБрд╣реЛрд╕реН
        return f"Cancelled. Found {len(results)} results before cancellation."
    
    return f"Found {len(results)} total results"

@app.tool()
async def download_file(url: str, ctx) -> str:
    """Download with cancellation support."""
    
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            total_size = int(response.headers.get('content-length', 0))
            downloaded = 0
            chunks = []
            
            async for chunk in response.content.iter_chunked(8192):
                if ctx.is_cancelled:
                    return f"Download cancelled at {downloaded}/{total_size} bytes"
                
                chunks.append(chunk)
                downloaded += len(chunk)
            
            return f"Downloaded {downloaded} bytes"
```

### рд░рджреНрджреАрдХрд░рдг рд╕рдиреНрджрд░реНрдн рдХрд╛рд░реНрдпрд╛рдиреНрд╡рдпрди

```python
class CancellableContext:
    """Context object that tracks cancellation state."""
    
    def __init__(self, request_id: str):
        self.request_id = request_id
        self._cancelled = asyncio.Event()
        self._cancel_reason = None
    
    @property
    def is_cancelled(self) -> bool:
        return self._cancelled.is_set()
    
    def cancel(self, reason: str = "Cancelled"):
        self._cancel_reason = reason
        self._cancelled.set()
    
    async def check_cancelled(self):
        """Raise if cancelled, otherwise continue."""
        if self.is_cancelled:
            raise CancelledError(self._cancel_reason)
    
    async def sleep_or_cancel(self, seconds: float):
        """Sleep that can be interrupted by cancellation."""
        try:
            await asyncio.wait_for(
                self._cancelled.wait(),
                timeout=seconds
            )
            raise CancelledError(self._cancel_reason)
        except asyncio.TimeoutError:
            pass  # рд╕рд╛рдорд╛рдиреНрдп рд╕рдордп рд╕рдорд╛рдкреНрддрд┐, рдЬрд╛рд░реА рд░рд╛рдЦреНрдиреБрд╣реЛрд╕реН
```

### рдЧреНрд░рд╛рд╣рдХ-рдкрдХреНрд╖ рд░рджреНрджреАрдХрд░рдг

```python
import asyncio

async def search_with_timeout(session, query, timeout=30):
    """Search with automatic cancellation on timeout."""
    
    task = asyncio.create_task(
        session.call_tool("long_running_search", {"query": query})
    )
    
    try:
        result = await asyncio.wait_for(task, timeout=timeout)
        return result
    except asyncio.TimeoutError:
        # рдЕрдиреБрд░реЛрдз рд░рджреНрдз рдЧрд░реНрдиреБрд╣реЛрд╕реН
        await session.send_notification({
            "method": "notifications/cancelled",
            "params": {"requestId": task.request_id, "reason": "Timeout"}
        })
        return "Search timed out"
```

---

## рей. рд╕реНрд░реЛрдд рдЯреЗрдореНрдкреНрд▓реЗрдЯрд╣рд░реВ

рд╕реНрд░реЛрдд рдЯреЗрдореНрдкреНрд▓реЗрдЯрд╣рд░реВрд▓реЗ рдкреНрдпрд╛рд░рд╛рдорд┐рдЯрд░рд╣рд░реВрд╕рд╣рд┐рдд рдЧрддрд┐рд╢реАрд▓ URI рдирд┐рд░реНрдорд╛рдг рдЧрд░реНрдиреЗ рд╕реБрд╡рд┐рдзрд╛ рджрд┐рдиреНрдЫ, рдЬреБрди API рд░ рдбреЗрдЯрд╛рдмреЗрд╕рд╣рд░реВрдХрд╛ рд▓рд╛рдЧрд┐ рдЙрдкрдпреЛрдЧреА рдЫред

### рдЯреЗрдореНрдкреНрд▓реЗрдЯ рдкрд░рд┐рднрд╛рд╖рд╛

```python
from mcp.server import Server
from mcp.types import ResourceTemplate

app = Server("template-server")

@app.list_resource_templates()
async def list_templates() -> list[ResourceTemplate]:
    """Return available resource templates."""
    return [
        ResourceTemplate(
            uriTemplate="db://users/{user_id}",
            name="User Profile",
            description="Fetch user profile by ID",
            mimeType="application/json"
        ),
        ResourceTemplate(
            uriTemplate="api://weather/{city}/{date}",
            name="Weather Data",
            description="Historical weather for city and date",
            mimeType="application/json"
        ),
        ResourceTemplate(
            uriTemplate="file://{path}",
            name="File Content",
            description="Read file at given path",
            mimeType="text/plain"
        )
    ]

@app.read_resource()
async def read_resource(uri: str) -> str:
    """Read resource, expanding template parameters."""
    
    # рдкреНрдпрд╛рд░рд╛рдорд┐рдЯрд░рд╣рд░реВ рдирд┐рдХрд╛рд▓реНрдирдХреЛ рд▓рд╛рдЧрд┐ URI рдкрд╛рд░реНрд╕ рдЧрд░реНрдиреБрд╣реЛрд╕реН
    if uri.startswith("db://users/"):
        user_id = uri.split("/")[-1]
        return await fetch_user(user_id)
    
    elif uri.startswith("api://weather/"):
        parts = uri.replace("api://weather/", "").split("/")
        city, date = parts[0], parts[1]
        return await fetch_weather(city, date)
    
    elif uri.startswith("file://"):
        path = uri.replace("file://", "")
        return await read_file(path)
    
    raise ValueError(f"Unknown resource URI: {uri}")
```

### TypeScript рдХрд╛рд░реНрдпрд╛рдиреНрд╡рдпрди

```typescript
server.setRequestHandler(ListResourceTemplatesSchema, async () => {
  return {
    resourceTemplates: [
      {
        uriTemplate: "github://repos/{owner}/{repo}/issues/{issue_number}",
        name: "GitHub Issue",
        description: "Fetch a specific GitHub issue",
        mimeType: "application/json"
      },
      {
        uriTemplate: "db://tables/{table}/rows/{id}",
        name: "Database Row",
        description: "Fetch a row from a database table",
        mimeType: "application/json"
      }
    ]
  };
});

server.setRequestHandler(ReadResourceSchema, async (request) => {
  const uri = request.params.uri;
  
  // GitHub рдореБрджреНрджрд╛ URI рдкрд╛рд░реНрд╕ рдЧрд░реНрдиреБрд╣реЛрд╕реН
  const githubMatch = uri.match(/^github:\/\/repos\/([^/]+)\/([^/]+)\/issues\/(\d+)$/);
  if (githubMatch) {
    const [_, owner, repo, issueNumber] = githubMatch;
    const issue = await fetchGitHubIssue(owner, repo, parseInt(issueNumber));
    return {
      contents: [{
        uri,
        mimeType: "application/json",
        text: JSON.stringify(issue, null, 2)
      }]
    };
  }
  
  throw new Error(`Unknown resource URI: ${uri}`);
});
```

---

## рек. рд╕рд░реНрднрд░ рдЬреАрд╡рдирдЪрдХреНрд░ рдШрдЯрдирд╛

рдЙрдЪрд┐рдд рдЖрд░рдореНрдн рд░ рдмрдиреНрдж рдкреНрд░рдХреНрд░рд┐рдпрд╛рд▓реЗ рд╕реНрд░реЛрддрд╣рд░реВрдХреЛ рд╕рдлрд╛ рд╡реНрдпрд╡рд╕реНрдерд╛рдкрди рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдЧрд░реНрдЫред

### Python рдЬреАрд╡рдирдЪрдХреНрд░ рд╡реНрдпрд╡рд╕реНрдерд╛рдкрди

```python
from mcp.server import Server
from contextlib import asynccontextmanager

app = Server("lifecycle-server")

# рд╕рд╛рдЭрд╛ рдЕрд╡рд╕реНрдерд╛
db_connection = None
cache = None

@asynccontextmanager
async def lifespan(server: Server):
    """Manage server lifecycle."""
    global db_connection, cache
    
    # рд╕реБрд░реБ рдЧрд░реНрджреИрдЫ
    print("ЁЯЪА Server starting...")
    db_connection = await create_database_connection()
    cache = await create_cache_client()
    print("тЬЕ Resources initialized")
    
    yield  # рд╕рд░реНрднрд░ рдпрд╣рд╛рдБ рдЪрд▓реНрдЫ
    
    # рдмрдиреНрдж рдЧрд░реНрджреИрдЫ
    print("ЁЯЫС Server shutting down...")
    await db_connection.close()
    await cache.close()
    print("тЬЕ Resources cleaned up")

app = Server("lifecycle-server", lifespan=lifespan)

@app.tool()
async def query_database(sql: str) -> str:
    """Use the shared database connection."""
    result = await db_connection.execute(sql)
    return str(result)
```

### TypeScript рдЬреАрд╡рдирдЪрдХреНрд░

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";

class ManagedServer {
  private server: Server;
  private dbConnection: DatabaseConnection | null = null;
  
  constructor() {
    this.server = new Server({
      name: "lifecycle-server",
      version: "1.0.0"
    });
    
    this.setupHandlers();
  }
  
  async start() {
    // рд╕реНрд░реЛрддрд╣рд░реВ рдкреНрд░рд╛рд░рдореНрдн рдЧрд░реНрдиреБрд╣реЛрд╕реН
    console.log("ЁЯЪА Server starting...");
    this.dbConnection = await createDatabaseConnection();
    console.log("тЬЕ Database connected");
    
    // рд╕рд░реНрднрд░ рд╕реБрд░реБ рдЧрд░реНрдиреБрд╣реЛрд╕реН
    await this.server.connect(transport);
  }
  
  async stop() {
    // рд╕реНрд░реЛрддрд╣рд░реВ рд╕рдлрд╛ рдЧрд░реНрдиреБрд╣реЛрд╕реН
    console.log("ЁЯЫС Server shutting down...");
    if (this.dbConnection) {
      await this.dbConnection.close();
    }
    await this.server.close();
    console.log("тЬЕ Cleanup complete");
  }
  
  private setupHandlers() {
    this.server.setRequestHandler(CallToolSchema, async (request) => {
      // this.dbConnection рд╕реБрд░рдХреНрд╖рд┐рдд рд░реВрдкрдорд╛ рдкреНрд░рдпреЛрдЧ рдЧрд░реНрдиреБрд╣реЛрд╕реН
      // ...
    });
  }
}

// рд╢рд╛рд▓реАрди рдмрдиреНрджрд╕рдБрдЧ рдкреНрд░рдпреЛрдЧ
const server = new ManagedServer();

process.on('SIGINT', async () => {
  await server.stop();
  process.exit(0);
});

await server.start();
```

---

## рел. рд▓рдЧрд┐рдЩ рдирд┐рдпрдиреНрддреНрд░рдг

MCP рд╕рд░реНрднрд░-рдкрдХреНрд╖ рд▓рдЧрд┐рдЩ рд╕реНрддрд░рд╣рд░реВ рд╕рдорд░реНрдерди рдЧрд░реНрджрдЫ рдЬреБрди рдЧреНрд░рд╛рд╣рдХрд╣рд░реВрд▓реЗ рдирд┐рдпрдиреНрддреНрд░рдг рдЧрд░реНрди рд╕рдХреНрдЫрдиреНред

### рд▓рдЧрд┐рдЩ рд╕реНрддрд░ рдХрд╛рд░реНрдпрд╛рдиреНрд╡рдпрди

```python
from mcp.server import Server
from mcp.types import LoggingLevel
import logging

app = Server("logging-server")

# MCP рд╕реНрддрд░рд╣рд░реВрд▓рд╛рдИ Python рд▓рдЧрд┐рдЩ рд╕реНрддрд░рд╣рд░реВрдорд╛ рдирдХреНрд╕рд╛рдЩреНрдХрди рдЧрд░реНрдиреБрд╣реЛрд╕реН
LEVEL_MAP = {
    LoggingLevel.DEBUG: logging.DEBUG,
    LoggingLevel.INFO: logging.INFO,
    LoggingLevel.WARNING: logging.WARNING,
    LoggingLevel.ERROR: logging.ERROR,
}

logger = logging.getLogger("mcp-server")

@app.set_logging_level()
async def set_logging_level(level: LoggingLevel) -> None:
    """Handle client request to change logging level."""
    python_level = LEVEL_MAP.get(level, logging.INFO)
    logger.setLevel(python_level)
    logger.info(f"Logging level set to {level}")

@app.tool()
async def debug_operation(data: str) -> str:
    """Tool with various logging levels."""
    logger.debug(f"Processing data: {data}")
    
    try:
        result = process(data)
        logger.info(f"Successfully processed: {result}")
        return result
    except Exception as e:
        logger.error(f"Processing failed: {e}")
        raise
```

### рдЧреНрд░рд╛рд╣рдХрд▓рд╛рдИ рд▓рдЧ рд╕рдиреНрджреЗрд╢рд╣рд░реВ рдкрдард╛рдЙрдиреЗ

```python
@app.tool()
async def complex_operation(input: str, ctx) -> str:
    """Operation that logs to client."""
    
    # рдЧреНрд░рд╛рд╣рдХрд▓рд╛рдИ рд▓рдЧ рд╕реВрдЪрдирд╛ рдкрдард╛рдЙрдиреБрд╣реЛрд╕реН
    await ctx.send_log(
        level="info",
        message=f"Starting complex operation with input: {input}"
    )
    
    # рдХрд╛рдо рдЧрд░реНрдиреБрд╣реЛрд╕реН...
    result = await do_work(input)
    
    await ctx.send_log(
        level="debug",
        message=f"Operation complete, result size: {len(result)}"
    )
    
    return result
```

---

## рем. рддреНрд░реБрдЯрд┐ рд╣реНрдпрд╛рдиреНрдбрд▓рд┐рдЩ рдврд╛рдБрдЪрд╛

рд╕реБрд╕рдВрдЧрдд рддреНрд░реБрдЯрд┐ рд╣реНрдпрд╛рдиреНрдбрд▓рд┐рдЩрд▓реЗ рдбрд┐рдмрдЧрд┐рдЩ рд░ рдкреНрд░рдпреЛрдЧрдХрд░реНрддрд╛ рдЕрдиреБрднрд╡ рд╕реБрдзрд╛рд░реНрдЫред

### MCP рддреНрд░реБрдЯрд┐ рдХреЛрдбрд╣рд░реВ

```python
from mcp.types import McpError, ErrorCode

class ToolError(McpError):
    """Base class for tool errors."""
    pass

class ValidationError(ToolError):
    """Invalid input parameters."""
    def __init__(self, message: str):
        super().__init__(ErrorCode.INVALID_PARAMS, message)

class NotFoundError(ToolError):
    """Requested resource not found."""
    def __init__(self, resource: str):
        super().__init__(ErrorCode.INVALID_REQUEST, f"Not found: {resource}")

class PermissionError(ToolError):
    """Access denied."""
    def __init__(self, action: str):
        super().__init__(ErrorCode.INVALID_REQUEST, f"Permission denied: {action}")

class InternalError(ToolError):
    """Internal server error."""
    def __init__(self, message: str):
        super().__init__(ErrorCode.INTERNAL_ERROR, message)
```

### рд╕рдВрд░рдЪрд┐рдд рддреНрд░реБрдЯрд┐ рдкреНрд░рддрд┐рдХреНрд░рд┐рдпрд╛

```python
@app.tool()
async def safe_operation(input: str) -> str:
    """Tool with comprehensive error handling."""
    
    # рдЗрдирдкреБрдЯ рдкреНрд░рдорд╛рдгрд┐рдд рдЧрд░реНрдиреБрд╣реЛрд╕реН
    if not input:
        raise ValidationError("Input cannot be empty")
    
    if len(input) > 10000:
        raise ValidationError(f"Input too large: {len(input)} chars (max 10000)")
    
    try:
        # рдЕрдиреБрдорддрд┐ рдЬрд╛рдБрдЪ рдЧрд░реНрдиреБрд╣реЛрд╕реН
        if not await check_permission(input):
            raise PermissionError(f"read {input}")
        
        # рдХрд╛рд░реНрдп рд╕рдореНрдкрдиреНрди рдЧрд░реНрдиреБрд╣реЛрд╕реН
        result = await perform_operation(input)
        
        if result is None:
            raise NotFoundError(input)
        
        return result
        
    except ConnectionError as e:
        raise InternalError(f"Database connection failed: {e}")
    except TimeoutError as e:
        raise InternalError(f"Operation timed out: {e}")
    except Exception as e:
        # рдЕрдкреНрд░рддреНрдпрд╛рд╢рд┐рдд рддреНрд░реБрдЯрд┐рд╣рд░реВ рд▓рдЧ рдЧрд░реНрдиреБрд╣реЛрд╕реН
        logger.exception(f"Unexpected error in safe_operation")
        raise InternalError(f"Unexpected error: {type(e).__name__}")
```

### TypeScript рдорд╛ рддреНрд░реБрдЯрд┐ рд╣реНрдпрд╛рдиреНрдбрд▓рд┐рдЩ

```typescript
import { McpError, ErrorCode } from "@modelcontextprotocol/sdk/types.js";

function validateInput(data: unknown): asserts data is ValidInput {
  if (typeof data !== "object" || data === null) {
    throw new McpError(
      ErrorCode.InvalidParams,
      "Input must be an object"
    );
  }
  // рдердк рдорд╛рдиреНрдпрддрд╛...
}

server.setRequestHandler(CallToolSchema, async (request) => {
  try {
    validateInput(request.params.arguments);
    
    const result = await performOperation(request.params.arguments);
    
    return {
      content: [{ type: "text", text: JSON.stringify(result) }]
    };
    
  } catch (error) {
    if (error instanceof McpError) {
      throw error;  // рдкрд╣рд┐рд▓реЗ рдиреИ MCP рддреНрд░реБрдЯрд┐
    }
    
    // рдЕрдиреНрдп рддреНрд░реБрдЯрд┐рд╣рд░реВ рд░реВрдкрд╛рдиреНрддрд░рдг рдЧрд░реНрдиреБрд╣реЛрд╕реН
    if (error instanceof NotFoundError) {
      throw new McpError(ErrorCode.InvalidRequest, error.message);
    }
    
    // рдЕрдЬреНрдЮрд╛рдд рддреНрд░реБрдЯрд┐
    console.error("Unexpected error:", error);
    throw new McpError(
      ErrorCode.InternalError,
      "An unexpected error occurred"
    );
  }
});
```

---

## рдкреНрд░рд╛рдпреЛрдЧрд┐рдХ рд╕реБрд╡рд┐рдзрд╛рд╣рд░реВ (MCP 2025-11-25)

рдпреА рд╕реБрд╡рд┐рдзрд╛рд╣рд░реВ рдирд┐рд░реНрджрд┐рд╖реНрдЯрд┐рдорд╛ рдкреНрд░рд╛рдпреЛрдЧрд┐рдХ рднрдиреЗрд░ рдЪрд┐рдиреНрд╣рд┐рдд рдЫрдиреН:

### рдХрд╛рд░реНрдпрд╣рд░реВ (рд▓рд╛рдореЛ рд╕рдордп рдЪрд▓реНрдиреЗ рдЕрдкрд░реЗрд╕рдирд╣рд░реВ)

```python
# рдЯрд╛рд╕реНрдХрд╣рд░реВрд▓реЗ рдЕрд╡рд╕реНрдерд╛ рд╕рд╣рд┐рдд рд▓рд╛рдореЛ рд╕рдордпрд╕рдореНрдо рдЪрд▓реНрдиреЗ рдЕрдкрд░реЗрд╕рдирд╣рд░реВрдХреЛ рдЯреНрд░реНрдпрд╛рдХрд┐рдЩ рдЧрд░реНрди рдЕрдиреБрдорддрд┐ рджрд┐рдиреНрдЫрдиреН
@app.task()
async def training_task(model_id: str, data_path: str, ctx) -> str:
    """Long-running ML training task."""
    
    # рдЯрд╛рд╕реНрдХ рд╕реБрд░реБ рднрдпреЛ рд░рд┐рдкреЛрд░реНрдЯ рдЧрд░реНрдиреБрд╣реЛрд╕реН
    await ctx.report_status("running", "Initializing training...")
    
    # рддрд╛рд▓рд┐рдо рд▓реВрдк
    for epoch in range(100):
        await train_epoch(model_id, data_path, epoch)
        await ctx.report_status(
            "running",
            f"Training epoch {epoch + 1}/100",
            progress=epoch + 1,
            total=100
        )
    
    await ctx.report_status("completed", "Training finished")
    return f"Model {model_id} trained successfully"
```

### рдЙрдкрдХрд░рдг рдПрдиреЛрдЯреЗрд╕рдирд╣рд░реВ

```python
# рдЙрдкрдХрд░рдгрдХреЛ рд╡реНрдпрд╡рд╣рд╛рд░ рд╕рдореНрдмрдиреНрдзреА рдореЗрдЯрд╛рдбрд╛рдЯрд╛ рдкреНрд░рджрд╛рди рдЧрд░реНрджрдЫ
@app.tool(
    annotations={
        "destructive": False,      # рдбрд╛рдЯрд╛ рдкрд░рд┐рд╡рд░реНрддрди рдЧрд░реНрджреИрди
        "idempotent": True,        # рдкреБрди: рдкреНрд░рдпрд╛рд╕ рдЧрд░реНрди рд╕реБрд░рдХреНрд╖рд┐рдд
        "timeout_seconds": 30,     # рдЕрдкреЗрдХреНрд╖рд┐рдд рдЕрдзрд┐рдХрддрдо рдЕрд╡рдзрд┐
        "requires_approval": False # рдкреНрд░рдпреЛрдЧрдХрд░реНрддрд╛ рдЕрдиреБрдореЛрджрди рдЖрд╡рд╢реНрдпрдХ рдЫреИрди
    }
)
async def safe_query(query: str) -> str:
    """A read-only database query tool."""
    return await execute_read_query(query)
```

---

## рдХреЗ рдЖрдЙрдБрджреИрдЫ

- [рдореЛрдбреНрдпреБрд▓ рео - рдЙрддреНрддрдо рдЕрднреНрдпрд╛рд╕рд╣рд░реВ](../../08-BestPractices/README.md)
- [рел.резрек - рд╕рдиреНрджрд░реНрдн рдЗрдиреНрдЬрд┐рдирд┐рдпрд░рд┐рдЩ](../mcp-contextengineering/README.md)
- [MCP рд╕реНрдкреЗрд╕рд┐рдлрд┐рдХреЗрд╕рди рдкрд░рд┐рд╡рд░реНрддрди рд╡рд┐рд╡рд░рдг](https://spec.modelcontextprotocol.io/)

---

## рдЕрддрд┐рд░рд┐рдХреНрдд рд╕реНрд░реЛрддрд╣рд░реВ

- [MCP рд╕реНрдкреЗрд╕рд┐рдлрд┐рдХреЗрд╕рди 2025-11-25](https://spec.modelcontextprotocol.io/specification/2025-11-25/)
- [JSON-RPC 2.0 рддреНрд░реБрдЯрд┐ рдХреЛрдбрд╣рд░реВ](https://www.jsonrpc.org/specification#error_object)
- [Python SDK рдЙрджрд╛рд╣рд░рдгрд╣рд░реВ](https://github.com/modelcontextprotocol/python-sdk/tree/main/examples)
- [TypeScript SDK рдЙрджрд╛рд╣рд░рдгрд╣рд░реВ](https://github.com/modelcontextprotocol/typescript-sdk/tree/main/examples)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**рдЕрд╕реНрд╡реАрдХрд░рдг**:
рдпреЛ рджрд╕реНрддрд╛рд╡реЗрдЬ рдПрдЖрдИ рдЕрдиреБрд╡рд╛рдж рд╕реЗрд╡рд╛ [Co-op Translator](https://github.com/Azure/co-op-translator) рдкреНрд░рдпреЛрдЧ рдЧрд░реА рдЕрдиреБрд╡рд╛рдж рдЧрд░рд┐рдПрдХреЛ рд╣реЛред рд╣рд╛рдореА рд╢реБрджреНрдзрддрд╛рдХреЛ рд▓рд╛рдЧрд┐ рдкреНрд░рдпрд╛рд╕рд░рдд рдЫреМрдВ, рддрд░ рдХреГрдкрдпрд╛ рдЬрд╛рдирдХрд╛рд░рд┐ рд╣реБрдиреБрд╕реН рдХрд┐ рд╕реНрд╡рдЪрд╛рд▓рд┐рдд рдЕрдиреБрд╡рд╛рджрдорд╛ рддреНрд░реБрдЯрд┐ рд╡рд╛ рдЕрд╢реБрджреНрдзрддрд╛ рд╣реБрди рд╕рдХреНрдЫред рдореВрд▓ рджрд╕реНрддрд╛рд╡реЗрдЬ рдпрд╕рдХреЛ рдореВрд▓ рднрд╛рд╖рд╛рдореИ рдЖрдзрд┐рдХрд╛рд░рд┐рдХ рд╕реНрд░реЛрдд рдорд╛рдирд┐рдиреБрдкрд░реНрдиреЗрдЫред рдорд╣рддреНрд╡рдкреВрд░реНрдг рдЬрд╛рдирдХрд╛рд░реАрдХрд╛ рд▓рд╛рдЧрд┐ рдкреЗрд╢реЗрд╡рд░ рдорд╛рдирд╡ рдЕрдиреБрд╡рд╛рдж рд╕рд┐рдлрд╛рд░рд┐рд╕ рдЧрд░рд┐рдиреНрдЫред рдпрд╕ рдЕрдиреБрд╡рд╛рджрдХреЛ рдкреНрд░рдпреЛрдЧрдмрд╛рдЯ рд╣реБрдиреЗ рдХреБрдиреИ рдкрдирд┐ рдЧрд▓рдд рдмреБрдЭрд╛рдЗ рд╡рд╛ рд╡реНрдпрд╛рдЦреНрдпрд╛рдЧрдд рддреНрд░реБрдЯрд┐рдХреЛ рд▓рд╛рдЧрд┐ рд╣рд╛рдореА рдЙрддреНрддрд░рджрд╛рдпреА рдЫреИрдиреМрдВред
<!-- CO-OP TRANSLATOR DISCLAIMER END -->