<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "3b3c9c3f033e59a30c92b5895e0dc9fd",
  "translation_date": "2025-12-11T14:38:44+00:00",
  "source_file": "11-MCPServerHandsOnLabs/02-Security/README.md",
  "language_code": "te"
}
-->
# ‡∞≠‡∞¶‡±ç‡∞∞‡∞§ ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞¨‡∞π‡±Å‡∞≥-‡∞Ö‡∞¶‡±ç‡∞¶‡±Ü‡∞¶‡∞æ‡∞∞‡∞ø‡∞§‡∞®‡∞Ç

## üéØ ‡∞à ‡∞™‡±ç‡∞∞‡∞Ø‡±ã‡∞ó‡∞∂‡∞æ‡∞≤ ‡∞è‡∞Æ‡∞ø ‡∞ï‡∞µ‡∞∞‡±ç ‡∞ö‡±á‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø

‡∞à ‡∞™‡±ç‡∞∞‡∞Ø‡±ã‡∞ó‡∞∂‡∞æ‡∞≤ MCP ‡∞∏‡∞∞‡±ç‡∞µ‡∞∞‡±ç‡∞≤ ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞é‡∞Ç‡∞ü‡∞∞‡±ç‚Äå‡∞™‡±ç‡∞∞‡±à‡∞ú‡±ç-‡∞ó‡±ç‡∞∞‡±á‡∞°‡±ç ‡∞≠‡∞¶‡±ç‡∞∞‡∞§ ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞¨‡∞π‡±Å‡∞≥-‡∞Ö‡∞¶‡±ç‡∞¶‡±Ü‡∞¶‡∞æ‡∞∞‡∞ø‡∞§‡∞®‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞Ö‡∞Æ‡∞≤‡±Å ‡∞ö‡±á‡∞Ø‡∞°‡∞Ç‡∞™‡±à ‡∞∏‡∞Æ‡∞ó‡±ç‡∞∞ ‡∞Æ‡∞æ‡∞∞‡±ç‡∞ó‡∞¶‡∞∞‡±ç‡∞∂‡∞ï‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞Ö‡∞Ç‡∞¶‡∞ø‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø. ‡∞Æ‡±Ä‡∞∞‡±Å ‡∞∏‡±Å‡∞®‡±ç‡∞®‡∞ø‡∞§‡∞Æ‡±à‡∞® ‡∞∞‡∞ø‡∞ü‡±à‡∞≤‡±ç ‡∞°‡±á‡∞ü‡∞æ‡∞®‡±Å ‡∞∞‡∞ï‡±ç‡∞∑‡∞ø‡∞∏‡±ç‡∞§‡±Ç, ‡∞¨‡∞π‡±Å‡∞≥ ‡∞Ö‡∞¶‡±ç‡∞¶‡±Ü‡∞¶‡∞æ‡∞∞‡±Å‡∞≤ ‡∞Æ‡∞ß‡±ç‡∞Ø ‡∞∏‡±å‡∞ï‡∞∞‡±ç‡∞Ø‡∞µ‡∞Ç‡∞§‡∞Æ‡±à‡∞® ‡∞Ø‡∞æ‡∞ï‡±ç‡∞∏‡±Ü‡∞∏‡±ç ‡∞®‡∞Æ‡±Ç‡∞®‡∞æ‡∞≤‡∞®‡±Å ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡∞ø‡∞Ç‡∞ö‡±á ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ, ‡∞Ö‡∞®‡±Å‡∞ó‡±Å‡∞£‡∞Æ‡±à‡∞® ‡∞µ‡±ç‡∞Ø‡∞µ‡∞∏‡±ç‡∞•‡∞≤‡∞®‡±Å ‡∞°‡∞ø‡∞ú‡±à‡∞®‡±ç ‡∞ö‡±á‡∞Ø‡∞°‡∞Ç ‡∞®‡±á‡∞∞‡±ç‡∞ö‡±Å‡∞ï‡±Å‡∞Ç‡∞ü‡∞æ‡∞∞‡±Å.

## ‡∞Ö‡∞µ‡∞≤‡±ã‡∞ï‡∞®‡∞Ç

‡∞ï‡∞∏‡±ç‡∞ü‡∞Æ‡∞∞‡±ç ‡∞°‡±á‡∞ü‡∞æ, ‡∞ö‡±Ü‡∞≤‡±ç‡∞≤‡∞ø‡∞Ç‡∞™‡±Å ‡∞∏‡∞Æ‡∞æ‡∞ö‡∞æ‡∞∞‡∞Ç ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞µ‡±ç‡∞Ø‡∞æ‡∞™‡∞æ‡∞∞ ‡∞¨‡±Å‡∞¶‡±ç‡∞ß‡∞ø‡∞Æ‡∞§‡±ç‡∞§‡∞®‡±Å ‡∞®‡∞ø‡∞∞‡±ç‡∞µ‡∞π‡∞ø‡∞Ç‡∞ö‡±á ‡∞∞‡∞ø‡∞ü‡±à‡∞≤‡±ç ‡∞Ö‡∞®‡±Å‡∞µ‡∞∞‡±ç‡∞§‡∞®‡∞æ‡∞≤‡∞≤‡±ã ‡∞≠‡∞¶‡±ç‡∞∞‡∞§ ‡∞Ö‡∞§‡±ç‡∞Ø‡∞Ç‡∞§ ‡∞Æ‡±Å‡∞ñ‡±ç‡∞Ø‡∞Æ‡±à‡∞®‡∞¶‡∞ø. ‡∞à ‡∞™‡±ç‡∞∞‡∞Ø‡±ã‡∞ó‡∞∂‡∞æ‡∞≤ ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£ ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡∞ø‡∞®‡±Å‡∞Ç‡∞°‡∞ø ‡∞°‡±á‡∞ü‡∞æ ‡∞µ‡±á‡∞∞‡±Å‡∞ö‡±á‡∞∏‡±á ‡∞µ‡∞ø‡∞ß‡∞æ‡∞®‡∞Ç ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞Ö‡∞®‡±Å‡∞ó‡±Å‡∞£‡∞§ ‡∞™‡∞∞‡±ç‡∞Ø‡∞µ‡±á‡∞ï‡±ç‡∞∑‡∞£ ‡∞µ‡∞∞‡∞ï‡±Å ‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞µ‡∞æ‡∞∏‡±ç‡∞§‡∞µ‡∞ø‡∞ï‡∞§‡∞®‡±Å ‡∞ï‡∞µ‡∞∞‡±ç ‡∞ö‡±á‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø.

‡∞Æ‡±á‡∞Æ‡±Å Azure ‡∞ê‡∞°‡±Ü‡∞Ç‡∞ü‡∞ø‡∞ü‡±Ä ‡∞∏‡±á‡∞µ‡∞≤‡±Å, PostgreSQL ‡∞∞‡±ã ‡∞≤‡±Ü‡∞µ‡∞≤‡±ç ‡∞∏‡±Ü‡∞ï‡±ç‡∞Ø‡±Ç‡∞∞‡∞ø‡∞ü‡±Ä, ‡∞Ö‡∞®‡±Å‡∞µ‡∞∞‡±ç‡∞§‡∞® ‡∞∏‡±ç‡∞•‡∞æ‡∞Ø‡∞ø ‡∞®‡∞ø‡∞Ø‡∞Ç‡∞§‡±ç‡∞∞‡∞£‡∞≤‡±Å ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞∏‡∞Æ‡∞ó‡±ç‡∞∞ ‡∞Ü‡∞°‡∞ø‡∞ü‡±ç ‡∞≤‡∞æ‡∞ó‡∞ø‡∞Ç‡∞ó‡±ç ‡∞ï‡∞≤‡∞ø‡∞™‡∞ø ‡∞∞‡∞ï‡±ç‡∞∑‡∞£‡∞≤‡±ã ‡∞≤‡±ã‡∞§‡±à‡∞® ‡∞µ‡±ç‡∞Ø‡±Ç‡∞π‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞Ö‡∞Æ‡∞≤‡±Å ‡∞ö‡±á‡∞∏‡±ç‡∞§‡∞æ‡∞Æ‡±Å, ‡∞¶‡±Ä‡∞®‡∞ø ‡∞¶‡±ç‡∞µ‡∞æ‡∞∞‡∞æ ‡∞¨‡∞≤‡∞Æ‡±à‡∞®, ‡∞Ö‡∞®‡±Å‡∞ó‡±Å‡∞£‡∞Æ‡±à‡∞® ‡∞µ‡±á‡∞¶‡∞ø‡∞ï ‡∞∏‡±É‡∞∑‡±ç‡∞ü‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡±Å‡∞§‡±Å‡∞Ç‡∞¶‡∞ø.

## ‡∞®‡±á‡∞∞‡±ç‡∞ö‡±Å‡∞ï‡±Å‡∞®‡±á ‡∞≤‡∞ï‡±ç‡∞∑‡±ç‡∞Ø‡∞æ‡∞≤‡±Å

‡∞à ‡∞™‡±ç‡∞∞‡∞Ø‡±ã‡∞ó‡∞∂‡∞æ‡∞≤ ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞® ‡∞§‡∞∞‡±ç‡∞µ‡∞æ‡∞§, ‡∞Æ‡±Ä‡∞∞‡±Å ‡∞ö‡±á‡∞Ø‡∞ó‡∞≤‡±Å‡∞ó‡±Å‡∞§‡∞æ‡∞∞‡±Å:

- **‡∞Ö‡∞Æ‡∞≤‡±Å ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø** ‡∞¨‡∞π‡±Å‡∞≥-‡∞Ö‡∞¶‡±ç‡∞¶‡±Ü‡∞¶‡∞æ‡∞∞‡±Å‡∞≤ ‡∞°‡±á‡∞ü‡∞æ ‡∞µ‡±á‡∞∞‡±Å‡∞ö‡±á‡∞∏‡±á‡∞Ç‡∞¶‡±Å‡∞ï‡±Å ‡∞é‡∞Ç‡∞ü‡∞∞‡±ç‚Äå‡∞™‡±ç‡∞∞‡±à‡∞ú‡±ç-‡∞ó‡±ç‡∞∞‡±á‡∞°‡±ç ‡∞∞‡±ã ‡∞≤‡±Ü‡∞µ‡∞≤‡±ç ‡∞∏‡±Ü‡∞ï‡±ç‡∞Ø‡±Ç‡∞∞‡∞ø‡∞ü‡±Ä  
- **‡∞°‡∞ø‡∞ú‡±à‡∞®‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø** Azure ‡∞§‡±ã ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£ ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡∞ø ‡∞®‡∞Æ‡±Ç‡∞®‡∞æ‡∞≤‡±Å  
- **‡∞ï‡∞æ‡∞®‡±ç‡∞´‡∞ø‡∞ó‡∞∞‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø** ‡∞Ö‡∞®‡±Å‡∞ó‡±Å‡∞£‡∞§ ‡∞Ö‡∞µ‡∞∏‡∞∞‡∞æ‡∞≤ ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞∏‡∞Æ‡∞ó‡±ç‡∞∞ ‡∞Ü‡∞°‡∞ø‡∞ü‡±ç ‡∞≤‡∞æ‡∞ó‡∞ø‡∞Ç‡∞ó‡±ç  
- **‡∞Ö‡∞™‡±ç‡∞≤‡±à ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø** ‡∞Ö‡∞®‡±ç‡∞®‡∞ø ‡∞Ö‡∞®‡±Å‡∞µ‡∞∞‡±ç‡∞§‡∞® ‡∞∏‡±ç‡∞•‡∞∞‡∞æ‡∞≤‡∞≤‡±ã ‡∞∞‡∞ï‡±ç‡∞∑‡∞£‡∞≤‡±ã ‡∞≤‡±ã‡∞§‡±à‡∞® ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞µ‡±ç‡∞Ø‡±Ç‡∞π‡∞æ‡∞≤‡±Å  
- **‡∞™‡∞∞‡∞ø‡∞∂‡±Ä‡∞≤‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø** ‡∞µ‡±ç‡∞Ø‡∞µ‡∞∏‡±ç‡∞•‡∞æ‡∞™‡∞ø‡∞§ ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑‡∞≤ ‡∞¶‡±ç‡∞µ‡∞æ‡∞∞‡∞æ ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞Ö‡∞Æ‡∞≤‡±Å‡∞≤‡∞®‡±Å  
- **‡∞™‡∞∞‡±ç‡∞Ø‡∞µ‡±á‡∞ï‡±ç‡∞∑‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø** ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞∏‡∞Ç‡∞ò‡∞ü‡∞®‡∞≤‡∞®‡±Å ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞∏‡∞Ç‡∞≠‡∞æ‡∞µ‡±ç‡∞Ø ‡∞Æ‡±Å‡∞™‡±ç‡∞™‡±Å‡∞≤‡∞ï‡±Å ‡∞∏‡±ç‡∞™‡∞Ç‡∞¶‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø  

## üîê ‡∞¨‡∞π‡±Å‡∞≥-‡∞Ö‡∞¶‡±ç‡∞¶‡±Ü‡∞¶‡∞æ‡∞∞‡±Å‡∞≤ ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞µ‡∞æ‡∞∏‡±ç‡∞§‡∞µ‡∞ø‡∞ï‡∞§

### ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞∏‡±ç‡∞•‡∞∞‡∞æ‡∞≤ ‡∞Ö‡∞µ‡∞≤‡±ã‡∞ï‡∞®‡∞Ç

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               Azure Front Door                  ‚îÇ ‚Üê WAF, DDoS Protection
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ              Application Gateway                ‚îÇ ‚Üê SSL Termination, Rate Limiting
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                MCP Server                       ‚îÇ ‚Üê Authentication, Authorization
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îÇ           Connection Layer                  ‚îÇ ‚Üê Connection Pooling, Circuit Breakers
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îÇ         Business Logic Layer               ‚îÇ ‚Üê Input Validation, Business Rules
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îÇ           Data Access Layer                ‚îÇ ‚Üê Query Sanitization, RLS Context
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ              PostgreSQL RLS                    ‚îÇ ‚Üê Row Level Security, Audit Triggers
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### ‡∞¨‡∞π‡±Å‡∞≥-‡∞Ö‡∞¶‡±ç‡∞¶‡±Ü‡∞¶‡∞æ‡∞∞‡∞ø‡∞§‡∞® ‡∞®‡∞Æ‡±Ç‡∞®‡∞æ‡∞≤‡±Å

‡∞Æ‡∞æ ‡∞Ö‡∞Æ‡∞≤‡±Å **‡∞∑‡±á‡∞∞‡±ç‡∞°‡±ç ‡∞°‡±á‡∞ü‡∞æ‡∞¨‡±á‡∞∏‡±ç, ‡∞∑‡±á‡∞∞‡±ç‡∞°‡±ç ‡∞∏‡±ç‡∞ï‡±Ä‡∞Æ‡∞æ** ‡∞®‡∞Æ‡±Ç‡∞®‡∞æ‡∞®‡±Å ‡∞∞‡±ã ‡∞≤‡±Ü‡∞µ‡∞≤‡±ç ‡∞∏‡±Ü‡∞ï‡±ç‡∞Ø‡±Ç‡∞∞‡∞ø‡∞ü‡±Ä‡∞§‡±ã ‡∞â‡∞™‡∞Ø‡±ã‡∞ó‡∞ø‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø:

**‡∞≤‡∞æ‡∞≠‡∞æ‡∞≤‡±Å:**
- ‡∞ñ‡∞∞‡±ç‡∞ö‡±Å-‡∞∏‡∞Æ‡∞∞‡±ç‡∞•‡∞µ‡∞Ç‡∞§‡∞Æ‡±à‡∞® ‡∞µ‡∞®‡∞∞‡±Å‡∞≤ ‡∞µ‡∞ø‡∞®‡∞ø‡∞Ø‡±ã‡∞ó‡∞Ç  
- ‡∞∏‡±Å‡∞≤‡∞≠‡∞Æ‡±à‡∞® ‡∞®‡∞ø‡∞∞‡±ç‡∞µ‡∞π‡∞£ ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞®‡∞µ‡±Ä‡∞ï‡∞∞‡∞£‡∞≤‡±Å  
- RLS ‡∞¶‡±ç‡∞µ‡∞æ‡∞∞‡∞æ ‡∞¨‡∞≤‡∞Æ‡±à‡∞® ‡∞°‡±á‡∞ü‡∞æ ‡∞µ‡±á‡∞∞‡±Å‡∞ö‡±á‡∞∏‡±á ‡∞µ‡∞ø‡∞ß‡∞æ‡∞®‡∞Ç  
- ‡∞Ö‡∞®‡±Å‡∞ó‡±Å‡∞£‡∞§‡∞ï‡±Å ‡∞Ö‡∞®‡±Å‡∞ï‡±Ç‡∞≤‡∞Æ‡±à‡∞® ‡∞Ü‡∞°‡∞ø‡∞ü‡±ç ‡∞ü‡±ç‡∞∞‡±à‡∞≤‡±ç‡∞∏‡±ç  

**‡∞µ‡∞ø‡∞®‡∞ø‡∞Æ‡∞Ø‡∞æ‡∞≤‡±Å:**
- ‡∞ú‡∞æ‡∞ó‡±ç‡∞∞‡∞§‡±ç‡∞§‡∞ó‡∞æ RLS ‡∞µ‡∞ø‡∞ß‡∞æ‡∞® ‡∞∞‡±Ç‡∞™‡∞ï‡∞≤‡±ç‡∞™‡∞® ‡∞Ö‡∞µ‡∞∏‡∞∞‡∞Ç  
- ‡∞∏‡±ç‡∞ï‡±Ä‡∞Æ‡∞æ ‡∞Æ‡∞æ‡∞∞‡±ç‡∞™‡±Å‡∞≤‡±Å ‡∞Ö‡∞®‡±ç‡∞®‡∞ø ‡∞Ö‡∞¶‡±ç‡∞¶‡±Ü‡∞¶‡∞æ‡∞∞‡±Å‡∞≤‡∞™‡±à ‡∞™‡±ç‡∞∞‡∞≠‡∞æ‡∞µ‡∞Ç ‡∞ö‡±Ç‡∞™‡±Å‡∞§‡∞æ‡∞Ø‡∞ø  
- ‡∞¨‡∞≤‡∞Æ‡±à‡∞® ‡∞¨‡±ç‡∞Ø‡∞æ‡∞ï‡∞™‡±ç/‡∞∞‡±Ä‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞µ‡∞ø‡∞ß‡∞æ‡∞®‡∞æ‡∞≤‡±Å ‡∞Ö‡∞µ‡∞∏‡∞∞‡∞Ç  

## üõ°Ô∏è ‡∞∞‡±ã ‡∞≤‡±Ü‡∞µ‡∞≤‡±ç ‡∞∏‡±Ü‡∞ï‡±ç‡∞Ø‡±Ç‡∞∞‡∞ø‡∞ü‡±Ä ‡∞Ö‡∞Æ‡∞≤‡±Å

### RLS ‡∞™‡±Å‡∞®‡∞æ‡∞¶‡∞ø

```sql
-- Enable RLS on all multi-tenant tables
ALTER TABLE retail.customers ENABLE ROW LEVEL SECURITY;
ALTER TABLE retail.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE retail.sales_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE retail.sales_transaction_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE retail.product_embeddings ENABLE ROW LEVEL SECURITY;

-- Create application role for MCP server
CREATE ROLE mcp_user LOGIN;
GRANT USAGE ON SCHEMA retail TO mcp_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA retail TO mcp_user;
```

### ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞ï‡∞æ‡∞Ç‡∞ü‡±Ü‡∞ï‡±ç‡∞∏‡±ç‡∞ü‡±ç ‡∞®‡∞ø‡∞∞‡±ç‡∞µ‡∞π‡∞£

```sql
-- Function to securely set store context
CREATE OR REPLACE FUNCTION retail.set_store_context(store_id_param VARCHAR(50))
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = retail, pg_temp
AS $$
DECLARE
    user_info RECORD;
BEGIN
    -- Validate store exists and is active
    SELECT store_id, store_name, is_active 
    INTO user_info
    FROM retail.stores 
    WHERE store_id = store_id_param;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Store not found: %', store_id_param
            USING ERRCODE = 'invalid_parameter_value',
                  HINT = 'Verify store ID and ensure it exists in the system';
    END IF;
    
    IF NOT user_info.is_active THEN
        RAISE EXCEPTION 'Store is inactive: %', store_id_param
            USING ERRCODE = 'insufficient_privilege',
                  HINT = 'Contact administrator to activate store';
    END IF;
    
    -- Set the secure context
    PERFORM set_config('app.current_store_id', store_id_param, false);
    PERFORM set_config('app.store_name', user_info.store_name, false);
    PERFORM set_config('app.context_set_at', extract(epoch from current_timestamp)::text, false);
    
    -- Log context change for audit
    INSERT INTO retail.security_audit_log (
        event_type,
        user_name,
        store_id,
        ip_address,
        user_agent,
        details,
        severity
    ) VALUES (
        'store_context_set',
        current_user,
        store_id_param,
        inet_client_addr()::text,
        current_setting('application_name', true),
        jsonb_build_object(
            'store_name', user_info.store_name,
            'timestamp', current_timestamp,
            'session_id', pg_backend_pid()
        ),
        'INFO'
    );
END;
$$;

-- Grant execute to MCP user
GRANT EXECUTE ON FUNCTION retail.set_store_context TO mcp_user;
```

### RLS ‡∞µ‡∞ø‡∞ß‡∞æ‡∞®‡∞æ‡∞≤‡±Å

```sql
-- Customers RLS Policy
CREATE POLICY customers_store_isolation ON retail.customers
    FOR ALL
    TO mcp_user
    USING (
        store_id = current_setting('app.current_store_id', true)
        AND current_setting('app.current_store_id', true) IS NOT NULL
        AND current_setting('app.current_store_id', true) != ''
    )
    WITH CHECK (
        store_id = current_setting('app.current_store_id', true)
        AND current_setting('app.current_store_id', true) IS NOT NULL
        AND current_setting('app.current_store_id', true) != ''
    );

-- Products RLS Policy with additional business rules
CREATE POLICY products_store_isolation ON retail.products
    FOR ALL
    TO mcp_user
    USING (
        store_id = current_setting('app.current_store_id', true)
        AND current_setting('app.current_store_id', true) IS NOT NULL
        AND current_setting('app.current_store_id', true) != ''
        AND is_active = TRUE  -- Additional business rule
    )
    WITH CHECK (
        store_id = current_setting('app.current_store_id', true)
        AND current_setting('app.current_store_id', true) IS NOT NULL
        AND current_setting('app.current_store_id', true) != ''
    );

-- Sales Transactions RLS Policy
CREATE POLICY sales_transactions_store_isolation ON retail.sales_transactions
    FOR ALL
    TO mcp_user
    USING (
        store_id = current_setting('app.current_store_id', true)
        AND current_setting('app.current_store_id', true) IS NOT NULL
        AND current_setting('app.current_store_id', true) != ''
    )
    WITH CHECK (
        store_id = current_setting('app.current_store_id', true)
        AND current_setting('app.current_store_id', true) IS NOT NULL
        AND current_setting('app.current_store_id', true) != ''
    );

-- Transaction Items RLS Policy (via join)
CREATE POLICY sales_transaction_items_store_isolation ON retail.sales_transaction_items
    FOR ALL
    TO mcp_user
    USING (
        transaction_id IN (
            SELECT transaction_id 
            FROM retail.sales_transactions 
            WHERE store_id = current_setting('app.current_store_id', true)
        )
    )
    WITH CHECK (
        transaction_id IN (
            SELECT transaction_id 
            FROM retail.sales_transactions 
            WHERE store_id = current_setting('app.current_store_id', true)
        )
    );

-- Product Embeddings RLS Policy
CREATE POLICY product_embeddings_store_isolation ON retail.product_embeddings
    FOR ALL
    TO mcp_user
    USING (
        store_id = current_setting('app.current_store_id', true)
        AND current_setting('app.current_store_id', true) IS NOT NULL
        AND current_setting('app.current_store_id', true) != ''
    )
    WITH CHECK (
        store_id = current_setting('app.current_store_id', true)
        AND current_setting('app.current_store_id', true) IS NOT NULL
        AND current_setting('app.current_store_id', true) != ''
    );
```

### RLS ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑ ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£

```sql
-- Test RLS policies with different store contexts
DO $$
DECLARE
    test_result RECORD;
    customer_count INTEGER;
    product_count INTEGER;
BEGIN
    -- Test Seattle store context
    PERFORM retail.set_store_context('seattle');
    
    SELECT COUNT(*) INTO customer_count FROM retail.customers;
    SELECT COUNT(*) INTO product_count FROM retail.products;
    
    RAISE NOTICE 'Seattle store - Customers: %, Products: %', customer_count, product_count;
    
    -- Test Redmond store context
    PERFORM retail.set_store_context('redmond');
    
    SELECT COUNT(*) INTO customer_count FROM retail.customers;
    SELECT COUNT(*) INTO product_count FROM retail.products;
    
    RAISE NOTICE 'Redmond store - Customers: %, Products: %', customer_count, product_count;
    
    -- Verify data isolation
    IF customer_count > 0 AND product_count > 0 THEN
        RAISE NOTICE 'RLS policies are working correctly';
    ELSE
        RAISE WARNING 'RLS policies may not be configured correctly';
    END IF;
END;
$$;
```

## üîë ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£ ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡∞ø

### Azure Entra ID ‡∞∏‡∞Æ‡±Ä‡∞ï‡∞∞‡∞£

```python
# mcp_server/security/authentication.py
"""
Azure Entra ID authentication for MCP server.
"""
import os
import jwt
import aiohttp
import asyncio
from typing import Dict, Optional, List
from datetime import datetime, timezone
from azure.identity.aio import DefaultAzureCredential
from azure.keyvault.secrets.aio import SecretClient
import logging

logger = logging.getLogger(__name__)

class AzureAuthenticator:
    """Handle Azure Entra ID authentication and token validation."""
    
    def __init__(self):
        self.tenant_id = os.getenv('AZURE_TENANT_ID')
        self.client_id = os.getenv('AZURE_CLIENT_ID')
        self.audience = os.getenv('AZURE_AUDIENCE', self.client_id)
        self.issuer = f"https://login.microsoftonline.com/{self.tenant_id}/v2.0"
        
        # JWKS (JSON ‡∞µ‡±Ü‡∞¨‡±ç ‡∞ï‡±Ä ‡∞∏‡±Ü‡∞ü‡±ç) ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞ï‡±ç‡∞Ø‡∞æ‡∞∑‡±ç
        self._jwks_cache = None
        self._jwks_cache_expiry = None
        
        # ‡∞∞‡∞π‡∞∏‡±ç‡∞Ø‡∞æ‡∞≤ ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞ï‡±Ä ‡∞µ‡∞æ‡∞≤‡±ç‡∞ü‡±ç
        self.key_vault_url = os.getenv('AZURE_KEY_VAULT_URL')
        self.credential = DefaultAzureCredential()
        
        if self.key_vault_url:
            self.secret_client = SecretClient(
                vault_url=self.key_vault_url,
                credential=self.credential
            )
    
    async def validate_token(self, token: str) -> Dict:
        """Validate JWT token from Azure Entra ID."""
        
        try:
            # ‡∞∏‡∞Ç‡∞§‡∞ï‡∞Ç ‡∞ö‡±á‡∞∏‡±á ‡∞ï‡±Ä‡∞≤‡±Å ‡∞™‡±ä‡∞Ç‡∞¶‡∞Ç‡∞°‡∞ø
            signing_keys = await self._get_signing_keys()
            
            # ‡∞ï‡±Ä ID ‡∞™‡±ä‡∞Ç‡∞¶‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞ü‡±ã‡∞ï‡±Ü‡∞®‡±ç ‡∞π‡±Ü‡∞°‡±ç‡∞°‡∞∞‡±ç ‡∞°‡±Ä‡∞ï‡±ã‡∞°‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
            unverified_header = jwt.get_unverified_header(token)
            key_id = unverified_header.get('kid')
            
            if not key_id:
                raise ValueError("Token missing key ID")
            
            # ‡∞∏‡∞Ç‡∞¨‡∞Ç‡∞ß‡∞ø‡∞§ ‡∞ï‡±Ä‡∞®‡∞ø ‡∞ï‡∞®‡±Å‡∞ó‡±ä‡∞®‡∞Ç‡∞°‡∞ø
            signing_key = None
            for key in signing_keys:
                if key['kid'] == key_id:
                    signing_key = jwt.algorithms.RSAAlgorithm.from_jwk(key)
                    break
            
            if not signing_key:
                raise ValueError(f"Unable to find signing key for kid: {key_id}")
            
            # ‡∞ü‡±ã‡∞ï‡±Ü‡∞®‡±ç‚Äå‡∞®‡±Å ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞ø ‡∞°‡±Ä‡∞ï‡±ã‡∞°‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
            payload = jwt.decode(
                token,
                signing_key,
                algorithms=['RS256'],
                audience=self.audience,
                issuer=self.issuer,
                options={
                    'verify_exp': True,
                    'verify_aud': True,
                    'verify_iss': True
                }
            )
            
            # ‡∞µ‡∞ø‡∞®‡∞ø‡∞Ø‡±ã‡∞ó‡∞¶‡∞æ‡∞∞‡±Å ‡∞∏‡∞Æ‡∞æ‡∞ö‡∞æ‡∞∞‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞§‡±Ä‡∞∏‡±Å‡∞ï‡±ã‡∞Ç‡∞°‡∞ø
            user_info = self._extract_user_info(payload)
            
            # ‡∞µ‡∞ø‡∞ú‡∞Ø‡∞µ‡∞Ç‡∞§‡∞Æ‡±à‡∞® ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£‡∞®‡±Å ‡∞≤‡∞æ‡∞ó‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
            logger.info(
                "User authenticated successfully",
                extra={
                    'user_id': user_info['user_id'],
                    'email': user_info.get('email'),
                    'tenant_id': payload.get('tid')
                }
            )
            
            return user_info
            
        except jwt.ExpiredSignatureError:
            logger.warning("Token has expired")
            raise ValueError("Token has expired")
        except jwt.InvalidAudienceError:
            logger.warning(f"Invalid audience in token. Expected: {self.audience}")
            raise ValueError("Invalid token audience")
        except jwt.InvalidIssuerError:
            logger.warning(f"Invalid issuer in token. Expected: {self.issuer}")
            raise ValueError("Invalid token issuer")
        except Exception as e:
            logger.error(f"Token validation failed: {str(e)}")
            raise ValueError(f"Token validation failed: {str(e)}")
    
    async def _get_signing_keys(self) -> List[Dict]:
        """Get JWKS from Azure Entra ID with caching."""
        
        current_time = datetime.now(timezone.utc)
        
        # ‡∞ï‡±ç‡∞Ø‡∞æ‡∞∑‡±ç ‡∞ö‡±Ü‡∞≤‡±ç‡∞≤‡±Å‡∞¨‡∞æ‡∞ü‡±Å ‡∞Ö‡∞Ø‡±ç‡∞Ø‡∞ø‡∞Ç‡∞¶‡±ã ‡∞≤‡±á‡∞¶‡±ã ‡∞§‡∞®‡∞ø‡∞ñ‡±Ä ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
        if (self._jwks_cache and self._jwks_cache_expiry and 
            current_time < self._jwks_cache_expiry):
            return self._jwks_cache
        
        # ‡∞ï‡±ä‡∞§‡±ç‡∞§ JWKS ‡∞§‡±Ä‡∞∏‡±Å‡∞ï‡±ã‡∞Ç‡∞°‡∞ø
        jwks_url = f"{self.issuer}/keys"
        
        async with aiohttp.ClientSession() as session:
            async with session.get(jwks_url) as response:
                if response.status != 200:
                    raise Exception(f"Failed to fetch JWKS: {response.status}")
                
                jwks_data = await response.json()
                
        # 1 ‡∞ó‡∞Ç‡∞ü ‡∞™‡∞æ‡∞ü‡±Å ‡∞ï‡±ç‡∞Ø‡∞æ‡∞∑‡±ç
        self._jwks_cache = jwks_data['keys']
        self._jwks_cache_expiry = current_time.replace(
            hour=current_time.hour + 1
        )
        
        return self._jwks_cache
    
    def _extract_user_info(self, payload: Dict) -> Dict:
        """Extract user information from JWT payload."""
        
        return {
            'user_id': payload.get('oid') or payload.get('sub'),
            'email': payload.get('email') or payload.get('preferred_username'),
            'name': payload.get('name'),
            'tenant_id': payload.get('tid'),
            'roles': payload.get('roles', []),
            'groups': payload.get('groups', []),
            'app_roles': payload.get('app_roles', []),
            'scope': payload.get('scp', '').split() if payload.get('scp') else [],
            'expires_at': datetime.fromtimestamp(payload['exp'], timezone.utc),
            'issued_at': datetime.fromtimestamp(payload['iat'], timezone.utc)
        }
    
    async def get_user_store_access(self, user_id: str) -> List[str]:
        """Get list of stores the user has access to."""
        
        try:
            # ‡∞á‡∞¶‡∞ø ‡∞∏‡∞æ‡∞ß‡∞æ‡∞∞‡∞£‡∞Ç‡∞ó‡∞æ ‡∞Æ‡±Ä ‡∞µ‡∞ø‡∞®‡∞ø‡∞Ø‡±ã‡∞ó‡∞¶‡∞æ‡∞∞‡±Å/‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞Æ‡±ç‡∞Ø‡∞æ‡∞™‡∞ø‡∞Ç‡∞ó‡±ç‚Äå‡∞®‡±Å ‡∞™‡±ç‡∞∞‡∞∂‡±ç‡∞®‡∞ø‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø
            # ‡∞°‡±Ü‡∞Æ‡±ã ‡∞ï‡±ã‡∞∏‡∞Ç, ‡∞Æ‡∞®‡∞Ç ‡∞∏‡∞æ‡∞¶‡∞æ ‡∞ï‡±Ä ‡∞µ‡∞æ‡∞≤‡±ç‡∞ü‡±ç ‡∞∞‡∞π‡∞∏‡±ç‡∞Ø‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞â‡∞™‡∞Ø‡±ã‡∞ó‡∞ø‡∞∏‡±ç‡∞§‡∞æ‡∞Æ‡±Å
            secret_name = f"user-{user_id}-stores"
            
            if self.secret_client:
                secret = await self.secret_client.get_secret(secret_name)
                store_list = secret.value.split(',')
                return [store.strip() for store in store_list if store.strip()]
            
            # ‡∞´‡∞æ‡∞≤‡±ç‚Äå‡∞¨‡±ç‡∞Ø‡∞æ‡∞ï‡±ç: ‡∞°‡∞ø‡∞´‡∞æ‡∞≤‡±ç‡∞ü‡±ç ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞Ø‡∞æ‡∞ï‡±ç‡∞∏‡±Ü‡∞∏‡±ç‚Äå‡∞®‡±Å ‡∞§‡∞ø‡∞∞‡∞ø‡∞ó‡∞ø ‡∞á‡∞µ‡±ç‡∞µ‡∞Ç‡∞°‡∞ø
            logger.warning(f"No store mapping found for user {user_id}, using default")
            return ['seattle']  # ‡∞°‡∞ø‡∞´‡∞æ‡∞≤‡±ç‡∞ü‡±ç ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞Ø‡∞æ‡∞ï‡±ç‡∞∏‡±Ü‡∞∏‡±ç
            
        except Exception as e:
            logger.error(f"Failed to get store access for user {user_id}: {e}")
            return []  # ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç‡∞≤‡∞®‡±Å ‡∞®‡∞ø‡∞∞‡±ç‡∞£‡∞Ø‡∞ø‡∞Ç‡∞ö‡∞≤‡±á‡∞ï‡∞™‡±ã‡∞§‡±á ‡∞Ø‡∞æ‡∞ï‡±ç‡∞∏‡±Ü‡∞∏‡±ç ‡∞≤‡±á‡∞¶‡±Å

# ‡∞ó‡±ç‡∞≤‡±ã‡∞¨‡∞≤‡±ç ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£ ‡∞á‡∞®‡±ç‡∞∏‡±ç‡∞ü‡±Ü‡∞®‡±ç‡∞∏‡±ç
azure_authenticator = AzureAuthenticator()
```

### ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡∞ø ‡∞Æ‡∞ø‡∞°‡∞ø‡∞≤‡±ç‡∞µ‡±á‡∞∞‡±ç

```python
# mcp_server/security/authorization.py
"""
Authorization middleware and decorators for MCP server.
"""
import functools
from typing import Dict, List, Optional, Callable, Any
from fastapi import HTTPException, status, Request
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import logging

logger = logging.getLogger(__name__)

security = HTTPBearer()

class AuthorizationError(Exception):
    """Custom authorization error."""
    pass

class RoleBasedAuth:
    """Role-based access control implementation."""
    
    # ‡∞™‡∞æ‡∞§‡±ç‡∞∞ ‡∞π‡±à‡∞∞‡∞æ‡∞∞‡±ç‡∞ï‡±Ä‡∞®‡∞ø ‡∞®‡∞ø‡∞∞‡±ç‡∞µ‡∞ö‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø
    ROLE_HIERARCHY = {
        'store_admin': ['store_manager', 'store_user', 'store_readonly'],
        'store_manager': ['store_user', 'store_readonly'],
        'store_user': ['store_readonly'],
        'store_readonly': []
    }
    
    # ‡∞™‡±ç‡∞∞‡∞§‡∞ø ‡∞™‡∞æ‡∞§‡±ç‡∞∞‡∞ï‡±Å ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡±Å‡∞≤‡∞®‡±Å ‡∞®‡∞ø‡∞∞‡±ç‡∞µ‡∞ö‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø
    ROLE_PERMISSIONS = {
        'store_admin': [
            'read_all', 'write_all', 'delete_all', 'manage_users'
        ],
        'store_manager': [
            'read_all', 'write_transactions', 'write_inventory', 'read_reports'
        ],
        'store_user': [
            'read_products', 'read_customers', 'write_transactions'
        ],
        'store_readonly': [
            'read_products', 'read_basic_reports'
        ]
    }
    
    @classmethod
    def has_permission(cls, user_roles: List[str], required_permission: str) -> bool:
        """Check if user has required permission."""
        
        user_permissions = set()
        
        for role in user_roles:
            # ‡∞™‡±ç‡∞∞‡∞§‡±ç‡∞Ø‡∞ï‡±ç‡∞∑ ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡±Å‡∞≤‡∞®‡±Å ‡∞ú‡±ã‡∞°‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø
            user_permissions.update(cls.ROLE_PERMISSIONS.get(role, []))
            
            # ‡∞µ‡∞æ‡∞∞‡∞∏‡∞§‡±ç‡∞µ ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡±Å‡∞≤‡∞®‡±Å ‡∞ú‡±ã‡∞°‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø
            inherited_roles = cls.ROLE_HIERARCHY.get(role, [])
            for inherited_role in inherited_roles:
                user_permissions.update(cls.ROLE_PERMISSIONS.get(inherited_role, []))
        
        return required_permission in user_permissions
    
    @classmethod
    def get_user_stores(cls, user_info: Dict) -> List[str]:
        """Extract stores user has access to from user info."""
        
        # ‡∞á‡∞¶‡∞ø ‡∞∏‡∞æ‡∞ß‡∞æ‡∞∞‡∞£‡∞Ç‡∞ó‡∞æ ‡∞Æ‡±Ä ‡∞Ø‡±Ç‡∞ú‡∞∞‡±ç ‡∞®‡∞ø‡∞∞‡±ç‡∞µ‡∞π‡∞£ ‡∞µ‡±ç‡∞Ø‡∞µ‡∞∏‡±ç‡∞• ‡∞®‡±Å‡∞Ç‡∞°‡∞ø ‡∞µ‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø
        # ‡∞°‡±Ü‡∞Æ‡±ã ‡∞ï‡±ã‡∞∏‡∞Ç, ‡∞Æ‡±á‡∞Æ‡±Å ‡∞ï‡∞∏‡±ç‡∞ü‡∞Æ‡±ç ‡∞ï‡±ç‡∞≤‡±Ü‡∞Ø‡∞ø‡∞Æ‡±ç‡∞∏‡±ç ‡∞≤‡±á‡∞¶‡∞æ ‡∞ó‡±ç‡∞∞‡±Ç‡∞™‡±Å‡∞≤ ‡∞®‡±Å‡∞Ç‡∞°‡∞ø ‡∞§‡±Ä‡∞∏‡±Å‡∞ï‡±Å‡∞Ç‡∞ü‡∞æ‡∞Æ‡±Å
        
        stores = []
        
        # ‡∞ó‡±ç‡∞∞‡±Ç‡∞™‡±Å‡∞≤‡∞≤‡±ã ‡∞™‡±ç‡∞∞‡∞§‡±ç‡∞Ø‡∞ï‡±ç‡∞∑ ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞®‡∞ø‡∞Ø‡∞æ‡∞Æ‡∞ï‡∞æ‡∞≤‡∞®‡±Å ‡∞§‡∞®‡∞ø‡∞ñ‡±Ä ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
        for group in user_info.get('groups', []):
            if group.startswith('store_'):
                store_id = group.replace('store_', '')
                stores.append(store_id)
        
        # ‡∞Ø‡∞æ‡∞™‡±ç-‡∞™‡±ç‡∞∞‡∞§‡±ç‡∞Ø‡±á‡∞ï ‡∞™‡∞æ‡∞§‡±ç‡∞∞‡∞≤‡∞®‡±Å ‡∞§‡∞®‡∞ø‡∞ñ‡±Ä ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
        for role in user_info.get('app_roles', []):
            if 'store:' in role:
                _, store_id = role.split('store:', 1)
                stores.append(store_id)
        
        return list(set(stores))  # ‡∞™‡±ç‡∞∞‡∞§‡∞ø‡∞≤‡∞ø‡∞™‡±Å‡∞≤‡∞®‡±Å ‡∞§‡±ä‡∞≤‡∞ó‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø

def require_auth(required_permission: str = None, require_store_access: bool = True):
    """Decorator to require authentication and authorization."""
    
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            # ‡∞Ü‡∞∞‡±ç‡∞ó‡±ç‡∞∏‡±ç ‡∞®‡±Å‡∞Ç‡∞°‡∞ø ‡∞Ö‡∞≠‡±ç‡∞Ø‡∞∞‡±ç‡∞•‡∞®‡∞®‡±Å ‡∞§‡±Ä‡∞∏‡±Å‡∞ï‡±ã‡∞Ç‡∞°‡∞ø (FastAPI ‡∞°‡∞ø‡∞™‡±Ü‡∞Ç‡∞°‡±Ü‡∞®‡±ç‡∞∏‡±Ä ‡∞á‡∞Ç‡∞ú‡±Ü‡∞ï‡±ç‡∞∑‡∞®‡±ç)
            request = None
            for arg in args:
                if isinstance(arg, Request):
                    request = arg
                    break
            
            if not request:
                raise HTTPException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    detail="Request object not found"
                )
            
            # ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡∞ø ‡∞π‡±Ü‡∞°‡±ç‡∞°‡∞∞‡±ç ‡∞™‡±ä‡∞Ç‡∞¶‡∞Ç‡∞°‡∞ø
            auth_header = request.headers.get('Authorization')
            if not auth_header or not auth_header.startswith('Bearer '):
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Missing or invalid authorization header",
                    headers={"WWW-Authenticate": "Bearer"}
                )
            
            token = auth_header.split(' ')[1]
            
            try:
                # ‡∞ü‡±ã‡∞ï‡±Ü‡∞®‡±ç‚Äå‡∞®‡±Å ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø
                user_info = await azure_authenticator.validate_token(token)
                
                # ‡∞Ö‡∞µ‡∞∏‡∞∞‡∞Æ‡±à‡∞® ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡∞ø‡∞®‡∞ø ‡∞§‡∞®‡∞ø‡∞ñ‡±Ä ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
                if required_permission:
                    user_roles = user_info.get('roles', [])
                    if not RoleBasedAuth.has_permission(user_roles, required_permission):
                        raise HTTPException(
                            status_code=status.HTTP_403_FORBIDDEN,
                            detail=f"Insufficient permissions. Required: {required_permission}"
                        )
                
                # ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞Ø‡∞æ‡∞ï‡±ç‡∞∏‡±Ü‡∞∏‡±ç‚Äå‡∞®‡±Å ‡∞§‡∞®‡∞ø‡∞ñ‡±Ä ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
                if require_store_access:
                    user_stores = RoleBasedAuth.get_user_stores(user_info)
                    if not user_stores:
                        raise HTTPException(
                            status_code=status.HTTP_403_FORBIDDEN,
                            detail="No store access configured for user"
                        )
                    
                    # ‡∞°‡∞ø‡∞´‡∞æ‡∞≤‡±ç‡∞ü‡±ç ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞ï‡∞æ‡∞Ç‡∞ü‡±Ü‡∞ï‡±ç‡∞∏‡±ç‡∞ü‡±ç ‡∞∏‡±Ü‡∞ü‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø (‡∞Æ‡±ä‡∞¶‡∞ü‡∞ø ‡∞Ø‡∞æ‡∞ï‡±ç‡∞∏‡±Ü‡∞∏‡∞ø‡∞¨‡±Å‡∞≤‡±ç ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç)
                    request.state.current_store = user_stores[0]
                    request.state.accessible_stores = user_stores
                
                # ‡∞Ö‡∞≠‡±ç‡∞Ø‡∞∞‡±ç‡∞•‡∞® ‡∞∏‡±ç‡∞•‡∞ø‡∞§‡∞ø‡∞≤‡±ã ‡∞Ø‡±Ç‡∞ú‡∞∞‡±ç ‡∞∏‡∞Æ‡∞æ‡∞ö‡∞æ‡∞∞‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞ú‡±ã‡∞°‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø
                request.state.user_info = user_info
                request.state.user_id = user_info['user_id']
                
                # ‡∞Ö‡∞∏‡∞≤‡±Å ‡∞´‡∞Ç‡∞ï‡±ç‡∞∑‡∞®‡±ç‚Äå‡∞®‡±Å ‡∞™‡∞ø‡∞≤‡∞µ‡∞Ç‡∞°‡∞ø
                return await func(*args, **kwargs)
                
            except ValueError as e:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail=str(e),
                    headers={"WWW-Authenticate": "Bearer"}
                )
            except AuthorizationError as e:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=str(e)
                )
        
        return wrapper
    return decorator

def require_store_context(store_param: str = 'store_id'):
    """Decorator to validate and set store context."""
    
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            # kwargs ‡∞®‡±Å‡∞Ç‡∞°‡∞ø store_id ‡∞™‡±ä‡∞Ç‡∞¶‡∞Ç‡∞°‡∞ø
            store_id = kwargs.get(store_param)
            
            if not store_id:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Missing required parameter: {store_param}"
                )
            
            # ‡∞Ü‡∞∞‡±ç‡∞ó‡±ç‡∞∏‡±ç ‡∞®‡±Å‡∞Ç‡∞°‡∞ø ‡∞Ö‡∞≠‡±ç‡∞Ø‡∞∞‡±ç‡∞•‡∞®‡∞®‡±Å ‡∞§‡±Ä‡∞∏‡±Å‡∞ï‡±ã‡∞Ç‡∞°‡∞ø
            request = None
            for arg in args:
                if isinstance(arg, Request):
                    request = arg
                    break
            
            if not request or not hasattr(request.state, 'accessible_stores'):
                raise HTTPException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    detail="Authentication required before store context validation"
                )
            
            # ‡∞Ö‡∞≠‡±ç‡∞Ø‡∞∞‡±ç‡∞•‡∞ø‡∞Ç‡∞ö‡∞ø‡∞® ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç‚Äå‡∞ï‡±Å ‡∞Ø‡±Ç‡∞ú‡∞∞‡±ç ‡∞Ø‡∞æ‡∞ï‡±ç‡∞∏‡±Ü‡∞∏‡±ç ‡∞â‡∞Ç‡∞¶‡±ã ‡∞≤‡±á‡∞¶‡±ã ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø
            if store_id not in request.state.accessible_stores:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Access denied to store: {store_id}"
                )
            
            # ‡∞Ö‡∞≠‡±ç‡∞Ø‡∞∞‡±ç‡∞•‡∞® ‡∞∏‡±ç‡∞•‡∞ø‡∞§‡∞ø‡∞≤‡±ã ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞ï‡∞æ‡∞Ç‡∞ü‡±Ü‡∞ï‡±ç‡∞∏‡±ç‡∞ü‡±ç ‡∞∏‡±Ü‡∞ü‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
            request.state.current_store = store_id
            
            return await func(*args, **kwargs)
        
        return wrapper
    return decorator
```

## üîç ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞Ü‡∞°‡∞ø‡∞ü‡±ç ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞Ö‡∞®‡±Å‡∞ó‡±Å‡∞£‡∞§

### ‡∞∏‡∞Æ‡∞ó‡±ç‡∞∞ ‡∞Ü‡∞°‡∞ø‡∞ü‡±ç ‡∞≤‡∞æ‡∞ó‡∞ø‡∞Ç‡∞ó‡±ç

```sql
-- Security audit log table
CREATE TABLE retail.security_audit_log (
    log_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type VARCHAR(100) NOT NULL,
    user_name VARCHAR(100) NOT NULL,
    user_id VARCHAR(100),
    store_id VARCHAR(50),
    ip_address INET,
    user_agent TEXT,
    request_id VARCHAR(100),
    session_id VARCHAR(100),
    resource_type VARCHAR(100),
    resource_id VARCHAR(100),
    action VARCHAR(50) NOT NULL,
    success BOOLEAN NOT NULL DEFAULT TRUE,
    failure_reason TEXT,
    details JSONB,
    severity VARCHAR(20) DEFAULT 'INFO',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    -- Ensure proper indexing for security queries
    CONSTRAINT valid_severity CHECK (severity IN ('DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL'))
);

-- Indexes for security audit queries
CREATE INDEX idx_security_audit_event_type ON retail.security_audit_log(event_type);
CREATE INDEX idx_security_audit_user_name ON retail.security_audit_log(user_name);
CREATE INDEX idx_security_audit_store_id ON retail.security_audit_log(store_id);
CREATE INDEX idx_security_audit_created_at ON retail.security_audit_log(created_at);
CREATE INDEX idx_security_audit_success ON retail.security_audit_log(success);
CREATE INDEX idx_security_audit_severity ON retail.security_audit_log(severity);
CREATE INDEX idx_security_audit_details ON retail.security_audit_log USING GIN(details);

-- Function to log security events
CREATE OR REPLACE FUNCTION retail.log_security_event(
    p_event_type VARCHAR(100),
    p_user_name VARCHAR(100),
    p_user_id VARCHAR(100) DEFAULT NULL,
    p_store_id VARCHAR(50) DEFAULT NULL,
    p_ip_address TEXT DEFAULT NULL,
    p_action VARCHAR(50) DEFAULT 'unknown',
    p_success BOOLEAN DEFAULT TRUE,
    p_failure_reason TEXT DEFAULT NULL,
    p_details JSONB DEFAULT NULL,
    p_severity VARCHAR(20) DEFAULT 'INFO'
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    log_id UUID;
BEGIN
    INSERT INTO retail.security_audit_log (
        event_type,
        user_name,
        user_id,
        store_id,
        ip_address,
        action,
        success,
        failure_reason,
        details,
        severity
    ) VALUES (
        p_event_type,
        p_user_name,
        p_user_id,
        p_store_id,
        p_ip_address::INET,
        p_action,
        p_success,
        p_failure_reason,
        p_details,
        p_severity
    ) RETURNING log_id INTO log_id;
    
    RETURN log_id;
END;
$$;

-- Grant execute to MCP user
GRANT EXECUTE ON FUNCTION retail.log_security_event TO mcp_user;
```

### ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞™‡∞∞‡±ç‡∞Ø‡∞µ‡±á‡∞ï‡±ç‡∞∑‡∞£ ‡∞µ‡±Ä‡∞ï‡±ç‡∞∑‡∞£‡∞≤‡±Å

```sql
-- Failed authentication attempts
CREATE VIEW retail.security_failed_auth AS
SELECT 
    event_type,
    user_name,
    ip_address,
    COUNT(*) as attempt_count,
    MIN(created_at) as first_attempt,
    MAX(created_at) as last_attempt,
    ARRAY_AGG(DISTINCT failure_reason) as failure_reasons
FROM retail.security_audit_log
WHERE success = FALSE 
  AND event_type IN ('authentication_failed', 'token_validation_failed')
  AND created_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours'
GROUP BY event_type, user_name, ip_address
HAVING COUNT(*) >= 3  -- 3 or more failures
ORDER BY attempt_count DESC, last_attempt DESC;

-- Suspicious access patterns
CREATE VIEW retail.security_suspicious_access AS
SELECT 
    user_name,
    user_id,
    COUNT(DISTINCT ip_address) as ip_count,
    COUNT(DISTINCT store_id) as store_count,
    ARRAY_AGG(DISTINCT ip_address::TEXT) as ip_addresses,
    ARRAY_AGG(DISTINCT store_id) as stores_accessed,
    MIN(created_at) as first_access,
    MAX(created_at) as last_access
FROM retail.security_audit_log
WHERE created_at >= CURRENT_TIMESTAMP - INTERVAL '1 hour'
  AND success = TRUE
GROUP BY user_name, user_id
HAVING COUNT(DISTINCT ip_address) > 3  -- Access from multiple IPs
   OR COUNT(DISTINCT store_id) > 2     -- Access to multiple stores
ORDER BY ip_count DESC, store_count DESC;

-- Data access patterns
CREATE VIEW retail.security_data_access_summary AS
SELECT 
    DATE_TRUNC('hour', created_at) as access_hour,
    store_id,
    resource_type,
    action,
    COUNT(*) as access_count,
    COUNT(DISTINCT user_id) as unique_users
FROM retail.security_audit_log
WHERE resource_type IS NOT NULL
  AND created_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours'
GROUP BY DATE_TRUNC('hour', created_at), store_id, resource_type, action
ORDER BY access_hour DESC, access_count DESC;
```

### ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞∏‡∞Ç‡∞ò‡∞ü‡∞® ‡∞™‡∞∞‡±ç‡∞Ø‡∞µ‡±á‡∞ï‡±ç‡∞∑‡∞£

```python
# mcp_server/security/monitoring.py
"""
Security monitoring and alerting for MCP server.
"""
import asyncio
import asyncpg
from typing import Dict, List, Any
from datetime import datetime, timedelta
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class SecurityAlert:
    """Security alert data structure."""
    alert_type: str
    severity: str
    message: str
    details: Dict[str, Any]
    timestamp: datetime

class SecurityMonitor:
    """Monitor security events and generate alerts."""
    
    def __init__(self, db_connection_string: str):
        self.db_connection_string = db_connection_string
        self.alert_handlers = []
        
        # ‡∞Ö‡∞≤‡∞∞‡±ç‡∞ü‡±ç ‡∞™‡∞∞‡∞ø‡∞Æ‡∞ø‡∞§‡±Å‡∞≤‡±Å
        self.thresholds = {
            'failed_auth_attempts': 5,      # ‡∞™‡±ç‡∞∞‡∞§‡∞ø ‡∞µ‡∞ø‡∞®‡∞ø‡∞Ø‡±ã‡∞ó‡∞¶‡∞æ‡∞∞‡±Å‡∞®‡∞ø‡∞ï‡∞ø ‡∞™‡±ç‡∞∞‡∞§‡∞ø ‡∞ó‡∞Ç‡∞ü‡∞ï‡±Å
            'multiple_ip_access': 3,        # ‡∞™‡±ç‡∞∞‡∞§‡∞ø ‡∞µ‡∞ø‡∞®‡∞ø‡∞Ø‡±ã‡∞ó‡∞¶‡∞æ‡∞∞‡±Å‡∞®‡∞ø‡∞ï‡∞ø ‡∞™‡±ç‡∞∞‡∞§‡∞ø ‡∞ó‡∞Ç‡∞ü‡∞ï‡±Å ‡∞µ‡±á‡∞∞‡±á IP‡∞≤‡±Å
            'excessive_data_access': 1000,  # ‡∞™‡±ç‡∞∞‡∞§‡∞ø ‡∞µ‡∞ø‡∞®‡∞ø‡∞Ø‡±ã‡∞ó‡∞¶‡∞æ‡∞∞‡±Å‡∞®‡∞ø‡∞ï‡∞ø ‡∞™‡±ç‡∞∞‡∞§‡∞ø ‡∞ó‡∞Ç‡∞ü‡∞ï‡±Å ‡∞™‡±ç‡∞∞‡∞∂‡±ç‡∞®‡∞≤‡±Å
            'privilege_escalation': 1,      # ‡∞è‡∞¶‡±à‡∞®‡∞æ ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞Ç
            'unauthorized_store_access': 1  # ‡∞è‡∞¶‡±à‡∞®‡∞æ ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞Ç
        }
    
    async def start_monitoring(self):
        """Start security monitoring loop."""
        logger.info("Starting security monitoring")
        
        while True:
            try:
                await self._check_security_events()
                await asyncio.sleep(300)  # ‡∞™‡±ç‡∞∞‡∞§‡∞ø 5 ‡∞®‡∞ø‡∞Æ‡∞ø‡∞∑‡∞æ‡∞≤‡∞ï‡±Å ‡∞§‡∞®‡∞ø‡∞ñ‡±Ä ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
            except Exception as e:
                logger.error(f"Security monitoring error: {e}")
                await asyncio.sleep(60)  # ‡∞≤‡±ã‡∞™‡∞Ç ‡∞µ‡∞ö‡±ç‡∞ö‡∞ø‡∞®‡∞™‡±ç‡∞™‡±Å‡∞°‡±Å ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ ‡∞∞‡±Ä‡∞ü‡±ç‡∞∞‡±à
    
    async def _check_security_events(self):
        """Check for security events and generate alerts."""
        
        conn = await asyncpg.connect(self.db_connection_string)
        
        try:
            # ‡∞µ‡∞ø‡∞´‡∞≤‡∞Æ‡±à‡∞® ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£ ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞æ‡∞≤‡∞®‡±Å ‡∞§‡∞®‡∞ø‡∞ñ‡±Ä ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
            await self._check_failed_auth(conn)
            
            # ‡∞Ö‡∞®‡±Å‡∞Æ‡∞æ‡∞®‡∞æ‡∞∏‡±ç‡∞™‡∞¶ ‡∞Ø‡∞æ‡∞ï‡±ç‡∞∏‡±Ü‡∞∏‡±ç ‡∞®‡∞Æ‡±Ç‡∞®‡∞æ‡∞≤‡∞®‡±Å ‡∞§‡∞®‡∞ø‡∞ñ‡±Ä ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
            await self._check_suspicious_access(conn)
            
            # ‡∞°‡±á‡∞ü‡∞æ ‡∞Ø‡∞æ‡∞ï‡±ç‡∞∏‡±Ü‡∞∏‡±ç ‡∞Ö‡∞∏‡∞æ‡∞ß‡∞æ‡∞∞‡∞£‡∞§‡∞≤‡∞®‡±Å ‡∞§‡∞®‡∞ø‡∞ñ‡±Ä ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
            await self._check_data_access_anomalies(conn)
            
            # ‡∞Ö‡∞®‡∞ß‡∞ø‡∞ï‡∞æ‡∞∞ ‡∞Ø‡∞æ‡∞ï‡±ç‡∞∏‡±Ü‡∞∏‡±ç ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞æ‡∞≤‡∞®‡±Å ‡∞§‡∞®‡∞ø‡∞ñ‡±Ä ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
            await self._check_unauthorized_access(conn)
            
        finally:
            await conn.close()
    
    async def _check_failed_auth(self, conn):
        """Check for excessive failed authentication attempts."""
        
        query = """
        SELECT 
            user_name,
            ip_address,
            COUNT(*) as attempt_count,
            MAX(created_at) as last_attempt
        FROM retail.security_audit_log
        WHERE success = FALSE 
          AND event_type IN ('authentication_failed', 'token_validation_failed')
          AND created_at >= CURRENT_TIMESTAMP - INTERVAL '1 hour'
        GROUP BY user_name, ip_address
        HAVING COUNT(*) >= $1
        """
        
        results = await conn.fetch(query, self.thresholds['failed_auth_attempts'])
        
        for record in results:
            alert = SecurityAlert(
                alert_type='failed_authentication',
                severity='HIGH',
                message=f"Excessive failed login attempts for user {record['user_name']}",
                details={
                    'user_name': record['user_name'],
                    'ip_address': str(record['ip_address']),
                    'attempt_count': record['attempt_count'],
                    'last_attempt': record['last_attempt'].isoformat()
                },
                timestamp=datetime.now()
            )
            
            await self._send_alert(alert)
    
    async def _check_suspicious_access(self, conn):
        """Check for suspicious access patterns."""
        
        query = """
        SELECT 
            user_name,
            user_id,
            COUNT(DISTINCT ip_address) as ip_count,
            ARRAY_AGG(DISTINCT ip_address::TEXT) as ip_addresses
        FROM retail.security_audit_log
        WHERE created_at >= CURRENT_TIMESTAMP - INTERVAL '1 hour'
          AND success = TRUE
        GROUP BY user_name, user_id
        HAVING COUNT(DISTINCT ip_address) >= $1
        """
        
        results = await conn.fetch(query, self.thresholds['multiple_ip_access'])
        
        for record in results:
            alert = SecurityAlert(
                alert_type='suspicious_access',
                severity='MEDIUM',
                message=f"User {record['user_name']} accessed from multiple IP addresses",
                details={
                    'user_name': record['user_name'],
                    'user_id': record['user_id'],
                    'ip_count': record['ip_count'],
                    'ip_addresses': record['ip_addresses']
                },
                timestamp=datetime.now()
            )
            
            await self._send_alert(alert)
    
    async def _check_unauthorized_access(self, conn):
        """Check for unauthorized store access attempts."""
        
        query = """
        SELECT 
            user_name,
            user_id,
            store_id,
            failure_reason,
            created_at
        FROM retail.security_audit_log
        WHERE success = FALSE 
          AND event_type = 'unauthorized_store_access'
          AND created_at >= CURRENT_TIMESTAMP - INTERVAL '1 hour'
        """
        
        results = await conn.fetch(query)
        
        for record in results:
            alert = SecurityAlert(
                alert_type='unauthorized_access',
                severity='HIGH',
                message=f"Unauthorized store access attempt by {record['user_name']}",
                details={
                    'user_name': record['user_name'],
                    'user_id': record['user_id'],
                    'store_id': record['store_id'],
                    'failure_reason': record['failure_reason'],
                    'timestamp': record['created_at'].isoformat()
                },
                timestamp=datetime.now()
            )
            
            await self._send_alert(alert)
    
    async def _send_alert(self, alert: SecurityAlert):
        """Send security alert to all configured handlers."""
        
        logger.warning(
            f"Security Alert: {alert.alert_type} - {alert.message}",
            extra={'alert_details': alert.details}
        )
        
        # ‡∞ï‡∞æ‡∞®‡±ç‡∞´‡∞ø‡∞ó‡∞∞‡±ç ‡∞ö‡±á‡∞∏‡∞ø‡∞® ‡∞Ö‡∞≤‡∞∞‡±ç‡∞ü‡±ç ‡∞π‡±ç‡∞Ø‡∞æ‡∞Ç‡∞°‡±ç‡∞≤‡∞∞‡±ç‡∞≤‡∞ï‡±Å ‡∞™‡∞Ç‡∞™‡∞Ç‡∞°‡∞ø
        for handler in self.alert_handlers:
            try:
                await handler.send_alert(alert)
            except Exception as e:
                logger.error(f"Failed to send alert via {handler.__class__.__name__}: {e}")
    
    def add_alert_handler(self, handler):
        """Add alert handler."""
        self.alert_handlers.append(handler)
```

## üß™ ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑ ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£

### ‡∞Ü‡∞ü‡±ã‡∞Æ‡±á‡∞ü‡±Ü‡∞°‡±ç ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑‡∞≤‡±Å

```python
# tests/security/test_security.py
"""
Comprehensive security tests for MCP server.
"""
import pytest
import asyncio
import asyncpg
from datetime import datetime, timezone
import jwt
from unittest.mock import Mock, patch

class TestRowLevelSecurity:
    """Test Row Level Security implementation."""
    
    @pytest.fixture
    async def db_connection(self):
        """Database connection for testing."""
        conn = await asyncpg.connect(
            "postgresql://mcp_user:password@localhost:5432/retail_test"
        )
        yield conn
        await conn.close()
    
    async def test_store_context_isolation(self, db_connection):
        """Test that RLS properly isolates data by store."""
        
        # ‡∞∏‡∞ø‡∞Ø‡∞æ‡∞ü‡∞ø‡∞≤‡±ç ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞∏‡∞Ç‡∞¶‡∞∞‡±ç‡∞≠‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞∏‡±Ü‡∞ü‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
        await db_connection.execute("SELECT retail.set_store_context('seattle')")
        
        # ‡∞ï‡∞∏‡±ç‡∞ü‡∞Æ‡∞∞‡±ç ‡∞∏‡∞Ç‡∞ñ‡±ç‡∞Ø‡∞®‡±Å ‡∞™‡±ä‡∞Ç‡∞¶‡∞Ç‡∞°‡∞ø
        seattle_customers = await db_connection.fetchval(
            "SELECT COUNT(*) FROM retail.customers"
        )
        
        # ‡∞∞‡±Ü‡∞°‡±ç‚Äå‡∞Æ‡∞Ç‡∞°‡±ç ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞∏‡∞Ç‡∞¶‡∞∞‡±ç‡∞≠‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞∏‡±Ü‡∞ü‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
        await db_connection.execute("SELECT retail.set_store_context('redmond')")
        
        # ‡∞ï‡∞∏‡±ç‡∞ü‡∞Æ‡∞∞‡±ç ‡∞∏‡∞Ç‡∞ñ‡±ç‡∞Ø‡∞®‡±Å ‡∞™‡±ä‡∞Ç‡∞¶‡∞Ç‡∞°‡∞ø
        redmond_customers = await db_connection.fetchval(
            "SELECT COUNT(*) FROM retail.customers"
        )
        
        # ‡∞µ‡±á‡∞∞‡±Å‡∞™‡∞°‡∞ü‡∞Ç ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø (‡∞∏‡∞Ç‡∞ñ‡±ç‡∞Ø‡∞≤‡±Å ‡∞≠‡∞ø‡∞®‡±ç‡∞®‡∞Ç‡∞ó‡∞æ ‡∞â‡∞Ç‡∞°‡∞æ‡∞≤‡∞ø)
        assert seattle_customers != redmond_customers or (
            seattle_customers == 0 and redmond_customers == 0
        )
    
    async def test_unauthorized_store_access(self, db_connection):
        """Test that invalid store access is blocked."""
        
        with pytest.raises(Exception) as exc_info:
            await db_connection.execute("SELECT retail.set_store_context('invalid_store')")
        
        assert "Store not found" in str(exc_info.value)
    
    async def test_cross_store_data_leakage(self, db_connection):
        """Test that users cannot access data from other stores."""
        
        # ‡∞í‡∞ï ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç‚Äå‡∞ï‡±Å ‡∞∏‡∞Ç‡∞¶‡∞∞‡±ç‡∞≠‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞∏‡±Ü‡∞ü‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
        await db_connection.execute("SELECT retail.set_store_context('seattle')")
        
        # ‡∞µ‡±á‡∞∞‡±á store_id ‡∞§‡±ã ‡∞°‡±á‡∞ü‡∞æ‡∞®‡±Å ‡∞ö‡±á‡∞∞‡±ç‡∞ö‡∞°‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø
        with pytest.raises(Exception):
            await db_connection.execute("""
                INSERT INTO retail.customers (store_id, first_name, last_name, email)
                VALUES ('redmond', 'Test', 'User', 'test@example.com')
            """)

class TestAuthentication:
    """Test authentication and authorization."""
    
    def test_valid_jwt_token(self):
        """Test valid JWT token validation."""
        
        # ‡∞∏‡∞∞‡±à‡∞® ‡∞ü‡±ã‡∞ï‡±Ü‡∞®‡±ç‚Äå‡∞®‡±Å ‡∞Æ‡∞æ‡∞ï‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø
        token_payload = {
            'oid': 'user-123',
            'email': 'test@example.com',
            'name': 'Test User',
            'tid': 'tenant-123',
            'aud': 'app-client-id',
            'iss': 'https://login.microsoftonline.com/tenant-123/v2.0',
            'exp': int((datetime.now(timezone.utc)).timestamp()) + 3600,
            'iat': int((datetime.now(timezone.utc)).timestamp()),
            'roles': ['store_user']
        }
        
        # ‡∞á‡∞¶‡∞ø JWKS ‡∞é‡∞Ç‡∞°‡±ç‚Äå‡∞™‡∞æ‡∞Ø‡∞ø‡∞Ç‡∞ü‡±ç‚Äå‡∞®‡±Å ‡∞Æ‡∞æ‡∞ï‡±ç ‡∞ö‡±á‡∞Ø‡∞°‡∞Ç ‡∞Ö‡∞µ‡∞∏‡∞∞‡∞Ç
        # ‡∞®‡∞ø‡∞ú‡∞Æ‡±à‡∞® ‡∞Ö‡∞Æ‡∞≤‡±Å‡∞≤‡±ã, ‡∞∏‡∞∞‡±à‡∞® ‡∞ü‡±Ü‡∞∏‡±ç‡∞ü‡±ç JWT ‡∞ü‡±ã‡∞ï‡±Ü‡∞®‡±ç‡∞≤‡∞®‡±Å ‡∞â‡∞™‡∞Ø‡±ã‡∞ó‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø
        
    def test_expired_token_rejection(self):
        """Test that expired tokens are rejected."""
        
        token_payload = {
            'oid': 'user-123',
            'exp': int((datetime.now(timezone.utc)).timestamp()) - 3600,  # ‡∞ï‡∞æ‡∞≤‡∞™‡∞∞‡∞ø‡∞Æ‡∞ø‡∞§‡∞ø ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞Ç‡∞¶‡∞ø
            'iat': int((datetime.now(timezone.utc)).timestamp()) - 7200
        }
        
        # ‡∞ï‡∞æ‡∞≤‡∞™‡∞∞‡∞ø‡∞Æ‡∞ø‡∞§‡∞ø ‡∞Æ‡±Å‡∞ó‡∞ø‡∞∏‡∞ø‡∞® ‡∞ü‡±ã‡∞ï‡±Ü‡∞®‡±ç‡∞≤‡±Å ‡∞§‡∞ø‡∞∞‡∞∏‡±ç‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞§‡∞æ‡∞Ø‡∞®‡∞ø ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑ ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞ø‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø
        
    def test_invalid_audience_rejection(self):
        """Test that tokens with wrong audience are rejected."""
        
        token_payload = {
            'oid': 'user-123',
            'aud': 'wrong-audience',  # ‡∞ö‡±Ü‡∞≤‡±ç‡∞≤‡∞®‡∞ø ‡∞™‡±ç‡∞∞‡±á‡∞ï‡±ç‡∞∑‡∞ï‡±Å‡∞≤‡±Å
            'exp': int((datetime.now(timezone.utc)).timestamp()) + 3600,
            'iat': int((datetime.now(timezone.utc)).timestamp())
        }
        
        # ‡∞§‡∞™‡±ç‡∞™‡±Å ‡∞™‡±ç‡∞∞‡±á‡∞ï‡±ç‡∞∑‡∞ï‡±Å‡∞≤ ‡∞ü‡±ã‡∞ï‡±Ü‡∞®‡±ç‡∞≤‡±Å ‡∞§‡∞ø‡∞∞‡∞∏‡±ç‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞§‡∞æ‡∞Ø‡∞®‡∞ø ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑ ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞ø‡∞∏‡±ç‡∞§‡±Å‡∞Ç‡∞¶‡∞ø

class TestAuthorization:
    """Test role-based authorization."""
    
    def test_role_hierarchy(self):
        """Test that role hierarchy works correctly."""
        
        from mcp_server.security.authorization import RoleBasedAuth
        
        # ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞Ö‡∞°‡±ç‡∞Æ‡∞ø‡∞®‡±ç‚Äå‡∞ï‡±Å ‡∞Ö‡∞®‡±ç‡∞®‡∞ø ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡±Å‡∞≤‡±Å ‡∞â‡∞Ç‡∞°‡∞æ‡∞≤‡∞ø
        assert RoleBasedAuth.has_permission(['store_admin'], 'read_all')
        assert RoleBasedAuth.has_permission(['store_admin'], 'write_all')
        assert RoleBasedAuth.has_permission(['store_admin'], 'delete_all')
        
        # ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞Ø‡±Ç‡∞ú‡∞∞‡±ç‚Äå‡∞ï‡±Å ‡∞™‡∞∞‡∞ø‡∞Æ‡∞ø‡∞§ ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡±Å‡∞≤‡±Å ‡∞â‡∞Ç‡∞°‡∞æ‡∞≤‡∞ø
        assert RoleBasedAuth.has_permission(['store_user'], 'read_products')
        assert not RoleBasedAuth.has_permission(['store_user'], 'delete_all')
        
        # ‡∞∏‡±ç‡∞ü‡±ã‡∞∞‡±ç ‡∞∞‡±Ä‡∞°‡±ã‡∞®‡±ç‡∞≤‡±Ä‡∞ï‡∞ø ‡∞ï‡∞®‡∞ø‡∞∑‡±ç‡∞ü ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡±Å‡∞≤‡±Å ‡∞â‡∞Ç‡∞°‡∞æ‡∞≤‡∞ø
        assert RoleBasedAuth.has_permission(['store_readonly'], 'read_products')
        assert not RoleBasedAuth.has_permission(['store_readonly'], 'write_transactions')
    
    def test_permission_inheritance(self):
        """Test that permissions are properly inherited."""
        
        from mcp_server.security.authorization import RoleBasedAuth
        
        # ‡∞Æ‡±á‡∞®‡±á‡∞ú‡∞∞‡±ç ‡∞Ø‡±Ç‡∞ú‡∞∞‡±ç ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡±Å‡∞≤‡∞®‡±Å ‡∞µ‡∞æ‡∞∞‡∞∏‡∞§‡±ç‡∞µ‡∞Ç‡∞ó‡∞æ ‡∞™‡±ä‡∞Ç‡∞¶‡∞æ‡∞≤‡∞ø
        assert RoleBasedAuth.has_permission(['store_manager'], 'read_products')
        assert RoleBasedAuth.has_permission(['store_manager'], 'write_transactions')

# ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑ ‡∞∞‡∞®‡±ç‡∞®‡∞∞‡±ç
if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

### ‡∞™‡±Ü‡∞®‡∞ø‡∞ü‡±ç‡∞∞‡±á‡∞∑‡∞®‡±ç ‡∞ü‡±Ü‡∞∏‡±ç‡∞ü‡∞ø‡∞Ç‡∞ó‡±ç ‡∞ö‡±Ü‡∞ï‡±ç‡∞≤‡∞ø‡∞∏‡±ç‡∞ü‡±ç

```yaml
# security-test-checklist.yml
penetration_testing:
  
  authentication_bypass:
    - name: "Test authentication bypass attempts"
      tests:
        - "Missing Authorization header"
        - "Malformed JWT tokens"
        - "Replay attack with expired tokens"
        - "Token signature manipulation"
        - "Audience/issuer manipulation"
    
  authorization_escalation:
    - name: "Test privilege escalation attempts"
      tests:
        - "Role manipulation in token"
        - "Store access boundary testing"
        - "Cross-tenant data access attempts"
        - "Administrative function access"
    
  sql_injection:
    - name: "Test SQL injection vulnerabilities"
      tests:
        - "Parameter injection in search queries"
        - "Store ID manipulation"
        - "JSON parameter injection"
        - "Union-based injection attempts"
    
  data_exposure:
    - name: "Test for data exposure vulnerabilities"
      tests:
        - "Error message information disclosure"
        - "Timing attack possibilities"
        - "Cross-store data leakage"
        - "Audit log exposure"
    
  rate_limiting:
    - name: "Test rate limiting and DoS protection"
      tests:
        - "Authentication endpoint flooding"
        - "API endpoint rate limits"
        - "Resource exhaustion attempts"
        - "Connection pool exhaustion"
```

## üéØ ‡∞Æ‡±Å‡∞ñ‡±ç‡∞Ø‡∞Æ‡±à‡∞® ‡∞™‡∞æ‡∞†‡∞æ‡∞≤‡±Å

‡∞à ‡∞™‡±ç‡∞∞‡∞Ø‡±ã‡∞ó‡∞∂‡∞æ‡∞≤ ‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞ö‡±á‡∞∏‡∞ø‡∞® ‡∞§‡∞∞‡±ç‡∞µ‡∞æ‡∞§, ‡∞Æ‡±Ä‡∞∞‡±Å ‡∞ï‡∞≤‡∞ø‡∞ó‡∞ø ‡∞â‡∞Ç‡∞°‡∞æ‡∞≤‡∞ø:

‚úÖ **‡∞¨‡∞π‡±Å‡∞≥-‡∞Ö‡∞¶‡±ç‡∞¶‡±Ü‡∞¶‡∞æ‡∞∞‡±Å‡∞≤ ‡∞≠‡∞¶‡±ç‡∞∞‡∞§**: ‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞°‡±á‡∞ü‡∞æ ‡∞µ‡±á‡∞∞‡±Å‡∞ö‡±á‡∞∏‡±á‡∞Ç‡∞¶‡±Å‡∞ï‡±Å ‡∞∞‡±ã ‡∞≤‡±Ü‡∞µ‡∞≤‡±ç ‡∞∏‡±Ü‡∞ï‡±ç‡∞Ø‡±Ç‡∞∞‡∞ø‡∞ü‡±Ä ‡∞Ö‡∞Æ‡∞≤‡±Å ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø  
‚úÖ **Azure ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£**: Azure Entra ID ‡∞®‡∞ø JWT ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£‡∞§‡±ã ‡∞∏‡∞Æ‡±Ä‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞æ‡∞∞‡±Å  
‚úÖ **‡∞™‡∞æ‡∞§‡±ç‡∞∞ ‡∞Ü‡∞ß‡∞æ‡∞∞‡∞ø‡∞§ ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡∞ø**: ‡∞π‡±à‡∞∞‡∞æ‡∞∞‡±ç‡∞ï‡∞ø‡∞ï‡∞≤‡±ç ‡∞™‡∞æ‡∞§‡±ç‡∞∞ ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞Ö‡∞®‡±Å‡∞Æ‡∞§‡∞ø ‡∞µ‡±ç‡∞Ø‡∞µ‡∞∏‡±ç‡∞•‡∞®‡±Å ‡∞ï‡∞æ‡∞®‡±ç‡∞´‡∞ø‡∞ó‡∞∞‡±ç ‡∞ö‡±á‡∞∂‡∞æ‡∞∞‡±Å  
‚úÖ **‡∞∏‡∞Æ‡∞ó‡±ç‡∞∞ ‡∞Ü‡∞°‡∞ø‡∞ü‡±ç ‡∞≤‡∞æ‡∞ó‡∞ø‡∞Ç‡∞ó‡±ç**: ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞∏‡∞Ç‡∞ò‡∞ü‡∞® ‡∞ü‡±ç‡∞∞‡∞æ‡∞ï‡∞ø‡∞Ç‡∞ó‡±ç ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞™‡∞∞‡±ç‡∞Ø‡∞µ‡±á‡∞ï‡±ç‡∞∑‡∞£‡∞®‡±Å ‡∞∏‡±ç‡∞•‡∞æ‡∞™‡∞ø‡∞Ç‡∞ö‡∞æ‡∞∞‡±Å  
‚úÖ **‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑**: ‡∞Ü‡∞ü‡±ã‡∞Æ‡±á‡∞ü‡±Ü‡∞°‡±ç ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£ ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑‡∞≤‡∞®‡±Å ‡∞Ö‡∞Æ‡∞≤‡±Å ‡∞ö‡±á‡∞∂‡∞æ‡∞∞‡±Å  
‚úÖ **‡∞Æ‡±Å‡∞™‡±ç‡∞™‡±Å ‡∞™‡∞∞‡±ç‡∞Ø‡∞µ‡±á‡∞ï‡±ç‡∞∑‡∞£**: ‡∞∞‡∞ø‡∞Ø‡∞≤‡±ç-‡∞ü‡±à‡∞Æ‡±ç ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞∏‡∞Ç‡∞ò‡∞ü‡∞® ‡∞ó‡±Å‡∞∞‡±ç‡∞§‡∞ø‡∞Ç‡∞™‡±Å ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞Ö‡∞≤‡∞∞‡±ç‡∞ü‡∞ø‡∞Ç‡∞ó‡±ç ‡∞∏‡±É‡∞∑‡±ç‡∞ü‡∞ø‡∞Ç‡∞ö‡∞æ‡∞∞‡±Å  

## üöÄ ‡∞§‡∞¶‡±Å‡∞™‡∞∞‡∞ø ‡∞è‡∞Æ‡∞ø‡∞ü‡∞ø

**[Lab 03: Environment Setup](../03-Setup/README.md)** ‡∞§‡±ã ‡∞ï‡±ä‡∞®‡∞∏‡∞æ‡∞ó‡∞Ç‡∞°‡∞ø:

- ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞â‡∞§‡±ç‡∞§‡∞Æ ‡∞Ü‡∞ö‡∞æ‡∞∞‡∞æ‡∞≤‡∞§‡±ã ‡∞Ö‡∞≠‡∞ø‡∞µ‡±É‡∞¶‡±ç‡∞ß‡∞ø ‡∞µ‡∞æ‡∞§‡∞æ‡∞µ‡∞∞‡∞£‡∞æ‡∞≤‡∞®‡±Å ‡∞ï‡∞æ‡∞®‡±ç‡∞´‡∞ø‡∞ó‡∞∞‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø  
- ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞£ ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞™‡∞∞‡±ç‡∞Ø‡∞µ‡±á‡∞ï‡±ç‡∞∑‡∞£ ‡∞ï‡±ã‡∞∏‡∞Ç Azure ‡∞∏‡±á‡∞µ‡∞≤‡∞®‡±Å ‡∞∏‡±Ü‡∞ü‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø  
- ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞°‡±á‡∞ü‡∞æ‡∞¨‡±á‡∞∏‡±ç ‡∞ï‡∞®‡±Ü‡∞ï‡±ç‡∞∑‡∞®‡±ç‡∞≤‡±Å ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞∏‡±Ä‡∞ï‡±ç‡∞∞‡±Ü‡∞ü‡±ç‡∞∏‡±ç ‡∞®‡∞ø‡∞∞‡±ç‡∞µ‡∞π‡∞£‡∞®‡±Å ‡∞Ö‡∞Æ‡∞≤‡±Å ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø  
- ‡∞Ö‡∞≠‡∞ø‡∞µ‡±É‡∞¶‡±ç‡∞ß‡∞ø ‡∞µ‡∞æ‡∞§‡∞æ‡∞µ‡∞∞‡∞£‡∞æ‡∞≤‡∞≤‡±ã ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞ï‡∞æ‡∞®‡±ç‡∞´‡∞ø‡∞ó‡∞∞‡±á‡∞∑‡∞®‡±ç‡∞≤‡∞®‡±Å ‡∞ß‡±É‡∞µ‡±Ä‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø  

## üìö ‡∞Ö‡∞¶‡∞®‡∞™‡±Å ‡∞µ‡∞®‡∞∞‡±Å‡∞≤‡±Å

### Azure ‡∞≠‡∞¶‡±ç‡∞∞‡∞§  
- [Azure Entra ID ‡∞°‡∞æ‡∞ï‡±ç‡∞Ø‡±Å‡∞Æ‡±Ü‡∞Ç‡∞ü‡±á‡∞∑‡∞®‡±ç](https://docs.microsoft.com/azure/active-directory/) - ‡∞™‡±Ç‡∞∞‡±ç‡∞§‡∞ø ‡∞ê‡∞°‡±Ü‡∞Ç‡∞ü‡∞ø‡∞ü‡±Ä ‡∞™‡±ç‡∞≤‡∞æ‡∞ü‡±ç‚Äå‡∞´‡∞æ‡∞∞‡∞Æ‡±ç ‡∞ó‡±à‡∞°‡±ç  
- [Azure ‡∞ï‡±Ä ‡∞µ‡∞æ‡∞≤‡±ç‡∞ü‡±ç](https://docs.microsoft.com/azure/key-vault/) - ‡∞∏‡±Ä‡∞ï‡±ç‡∞∞‡±Ü‡∞ü‡±ç‡∞∏‡±ç ‡∞®‡∞ø‡∞∞‡±ç‡∞µ‡∞π‡∞£ ‡∞∏‡±á‡∞µ  
- [Azure ‡∞≠‡∞¶‡±ç‡∞∞‡∞§ ‡∞â‡∞§‡±ç‡∞§‡∞Æ ‡∞Ü‡∞ö‡∞æ‡∞∞‡∞æ‡∞≤‡±Å](https://docs.microsoft.com/azure/security/fundamentals/best-practices-and-patterns) - ‡∞≠‡∞¶‡±ç‡∞∞‡∞§ ‡∞Æ‡∞æ‡∞∞‡±ç‡∞ó‡∞¶‡∞∞‡±ç‡∞∂‡∞ï‡∞æ‡∞≤‡±Å  

### ‡∞°‡±á‡∞ü‡∞æ‡∞¨‡±á‡∞∏‡±ç ‡∞≠‡∞¶‡±ç‡∞∞‡∞§  
- [PostgreSQL ‡∞∞‡±ã ‡∞≤‡±Ü‡∞µ‡∞≤‡±ç ‡∞∏‡±Ü‡∞ï‡±ç‡∞Ø‡±Ç‡∞∞‡∞ø‡∞ü‡±Ä](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) - ‡∞Ö‡∞ß‡∞ø‡∞ï‡∞æ‡∞∞‡∞ø‡∞ï RLS ‡∞°‡∞æ‡∞ï‡±ç‡∞Ø‡±Å‡∞Æ‡±Ü‡∞Ç‡∞ü‡±á‡∞∑‡∞®‡±ç  
- [‡∞°‡±á‡∞ü‡∞æ‡∞¨‡±á‡∞∏‡±ç ‡∞≠‡∞¶‡±ç‡∞∞‡∞§ ‡∞ö‡±Ü‡∞ï‡±ç‡∞≤‡∞ø‡∞∏‡±ç‡∞ü‡±ç](https://www.postgresql.org/docs/current/security.html) - PostgreSQL ‡∞≠‡∞¶‡±ç‡∞∞‡∞§ ‡∞ó‡±à‡∞°‡±ç  
- [‡∞¨‡∞π‡±Å‡∞≥-‡∞Ö‡∞¶‡±ç‡∞¶‡±Ü‡∞¶‡∞æ‡∞∞‡±Å‡∞≤ ‡∞°‡±á‡∞ü‡∞æ‡∞¨‡±á‡∞∏‡±ç ‡∞®‡∞Æ‡±Ç‡∞®‡∞æ‡∞≤‡±Å](https://docs.microsoft.com/azure/architecture/patterns/multitenancy) - ‡∞µ‡∞æ‡∞∏‡±ç‡∞§‡∞µ‡∞ø‡∞ï ‡∞®‡∞Æ‡±Ç‡∞®‡∞æ‡∞≤‡±Å  

### ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑  
- [OWASP ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑ ‡∞ó‡±à‡∞°‡±ç](https://owasp.org/www-project-web-security-testing-guide/) - ‡∞∏‡∞Æ‡∞ó‡±ç‡∞∞ ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑  
- [JWT ‡∞≠‡∞¶‡±ç‡∞∞‡∞§ ‡∞â‡∞§‡±ç‡∞§‡∞Æ ‡∞Ü‡∞ö‡∞æ‡∞∞‡∞æ‡∞≤‡±Å](https://tools.ietf.org/html/rfc8725) - JWT ‡∞≠‡∞¶‡±ç‡∞∞‡∞§ ‡∞™‡∞∞‡∞ø‡∞ó‡∞£‡∞®‡∞≤‡±Å  
- [API ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑](https://owasp.org/www-project-api-security/) - API-‡∞∏‡±ç‡∞™‡±Ü‡∞∏‡∞ø‡∞´‡∞ø‡∞ï‡±ç ‡∞≠‡∞¶‡±ç‡∞∞‡∞§‡∞æ ‡∞™‡∞∞‡±Ä‡∞ï‡±ç‡∞∑  

---

**‡∞Æ‡±Å‡∞®‡±Å‡∞™‡∞ü‡∞ø**: [Lab 01: Core Architecture Concepts](../01-Architecture/README.md)  
**‡∞§‡∞¶‡±Å‡∞™‡∞∞‡∞ø**: [Lab 03: Environment Setup](../03-Setup/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**‡∞Ö‡∞∏‡±ç‡∞™‡∞∑‡±ç‡∞ü‡∞§**:  
‡∞à ‡∞°‡∞æ‡∞ï‡±ç‡∞Ø‡±Å‡∞Æ‡±Ü‡∞Ç‡∞ü‡±ç‚Äå‡∞®‡±Å AI ‡∞Ö‡∞®‡±Å‡∞µ‡∞æ‡∞¶ ‡∞∏‡±á‡∞µ [Co-op Translator](https://github.com/Azure/co-op-translator) ‡∞â‡∞™‡∞Ø‡±ã‡∞ó‡∞ø‡∞Ç‡∞ö‡∞ø ‡∞Ö‡∞®‡±Å‡∞µ‡∞¶‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø. ‡∞Æ‡±á‡∞Æ‡±Å ‡∞ñ‡∞ö‡±ç‡∞ö‡∞ø‡∞§‡∞§‡±ç‡∞µ‡∞æ‡∞®‡∞ø‡∞ï‡∞ø ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞ø‡∞®‡∞™‡±ç‡∞™‡∞ü‡∞ø‡∞ï‡±Ä, ‡∞Ü‡∞ü‡±ã‡∞Æ‡±á‡∞ü‡±Ü‡∞°‡±ç ‡∞Ö‡∞®‡±Å‡∞µ‡∞æ‡∞¶‡∞æ‡∞≤‡±ç‡∞≤‡±ã ‡∞™‡±ä‡∞∞‡∞™‡∞æ‡∞ü‡±ç‡∞≤‡±Å ‡∞≤‡±á‡∞¶‡∞æ ‡∞§‡∞™‡±ç‡∞™‡±Å‡∞≤‡±Å ‡∞â‡∞Ç‡∞°‡∞µ‡∞ö‡±ç‡∞ö‡±Å. ‡∞Æ‡±Ç‡∞≤ ‡∞°‡∞æ‡∞ï‡±ç‡∞Ø‡±Å‡∞Æ‡±Ü‡∞Ç‡∞ü‡±ç ‡∞¶‡∞æ‡∞®‡∞ø ‡∞∏‡±ç‡∞µ‡∞¶‡±á‡∞∂‡±Ä ‡∞≠‡∞æ‡∞∑‡∞≤‡±ã ‡∞Ö‡∞ß‡∞ø‡∞ï‡∞æ‡∞∞‡∞ø‡∞ï ‡∞Æ‡±Ç‡∞≤‡∞Ç‡∞ó‡∞æ ‡∞™‡∞∞‡∞ø‡∞ó‡∞£‡∞ø‡∞Ç‡∞ö‡∞æ‡∞≤‡∞ø. ‡∞Æ‡±Å‡∞ñ‡±ç‡∞Ø‡∞Æ‡±à‡∞® ‡∞∏‡∞Æ‡∞æ‡∞ö‡∞æ‡∞∞‡∞æ‡∞®‡∞ø‡∞ï‡∞ø, ‡∞™‡±ç‡∞∞‡±ä‡∞´‡±Ü‡∞∑‡∞®‡∞≤‡±ç ‡∞Æ‡∞æ‡∞®‡∞µ ‡∞Ö‡∞®‡±Å‡∞µ‡∞æ‡∞¶‡∞Ç ‡∞∏‡∞ø‡∞´‡∞æ‡∞∞‡±ç‡∞∏‡±Å ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡±Å‡∞§‡±Å‡∞Ç‡∞¶‡∞ø. ‡∞à ‡∞Ö‡∞®‡±Å‡∞µ‡∞æ‡∞¶‡∞Ç ‡∞µ‡∞æ‡∞°‡∞ï‡∞Ç‡∞≤‡±ã ‡∞è‡∞∞‡±ç‡∞™‡∞°‡∞ø‡∞® ‡∞è‡∞µ‡±à‡∞®‡∞æ ‡∞Ö‡∞™‡∞æ‡∞∞‡±ç‡∞•‡∞æ‡∞≤‡±Å ‡∞≤‡±á‡∞¶‡∞æ ‡∞§‡∞™‡±ç‡∞™‡±Å‡∞¶‡∞æ‡∞∞‡∞ø‡∞§‡±Ä‡∞∏‡±á ‡∞Ö‡∞∞‡±ç‡∞•‡∞æ‡∞≤‡±Å ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞Æ‡±á‡∞Æ‡±Å ‡∞¨‡∞æ‡∞ß‡±ç‡∞Ø‡∞§ ‡∞µ‡∞π‡∞ø‡∞Ç‡∞ö‡∞Æ‡±Å.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->