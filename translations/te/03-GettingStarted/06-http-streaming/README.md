# HTTPS స్ట్రీమింగ్ మోడల్ కాంటెక్స్ట్ ప్రోటోకాల్ (MCP) తో

ఈ అధ్యాయం HTTPS ఉపయోగించి మోడల్ కాంటెక్స్ట్ ప్రోటోకాల్ (MCP) తో సురక్షితమైన, స్కేలబుల్ మరియు రియల్-టైమ్ స్ట్రీమింగ్ అమలు చేయడానికి సమగ్ర మార్గదర్శకాన్ని అందిస్తుంది. ఇది స్ట్రీమింగ్ కోసం ప్రేరణ, అందుబాటులో ఉన్న ట్రాన్స్‌పోర్ట్ మెకానిజమ్స్, MCPలో స్ట్రీమబుల్ HTTPని ఎలా అమలు చేయాలో, భద్రతా ఉత్తమ పద్ధతులు, SSE నుండి మైగ్రేషన్, మరియు మీ స్వంత స్ట్రీమింగ్ MCP అప్లికేషన్లను నిర్మించడానికి ప్రాక్టికల్ మార్గదర్శకాన్ని కవర్ చేస్తుంది.

## MCPలో ట్రాన్స్‌పోర్ట్ మెకానిజమ్స్ మరియు స్ట్రీమింగ్

ఈ విభాగం MCPలో అందుబాటులో ఉన్న వివిధ ట్రాన్స్‌పోర్ట్ మెకానిజమ్స్ మరియు క్లయింట్లు మరియు సర్వర్ల మధ్య రియల్-టైమ్ కమ్యూనికేషన్ కోసం స్ట్రీమింగ్ సామర్థ్యాలను సాధించడంలో వాటి పాత్రను పరిశీలిస్తుంది.

### ట్రాన్స్‌పోర్ట్ మెకానిజం అంటే ఏమిటి?

ట్రాన్స్‌పోర్ట్ మెకానిజం అనేది క్లయింట్ మరియు సర్వర్ మధ్య డేటా ఎలా మార్పిడి అవుతుందో నిర్వచిస్తుంది. MCP వివిధ వాతావరణాలు మరియు అవసరాలకు అనుగుణంగా బహుళ ట్రాన్స్‌పోర్ట్ రకాల్ని మద్దతు ఇస్తుంది:

- **stdio**: స్టాండర్డ్ ఇన్‌పుట్/అవుట్‌పుట్, స్థానిక మరియు CLI-ఆధారిత టూల్స్‌కు అనుకూలం. సులభమైనది కానీ వెబ్ లేదా క్లౌడ్‌కు అనుకూలం కాదు.
- **SSE (సర్వర్-సెంట్ ఈవెంట్స్)**: సర్వర్లు HTTP ద్వారా క్లయింట్లకు రియల్-టైమ్ అప్డేట్లను పంపగలుగుతాయి. వెబ్ UIలకు మంచిది, కానీ స్కేలబిలిటీ మరియు ఫ్లెక్సిబిలిటీ పరిమితమైనది.
- **స్ట్రీమబుల్ HTTP**: ఆధునిక HTTP-ఆధారిత స్ట్రీమింగ్ ట్రాన్స్‌పోర్ట్, నోటిఫికేషన్లు మరియు మెరుగైన స్కేలబిలిటీని మద్దతు ఇస్తుంది. ఎక్కువగా ప్రొడక్షన్ మరియు క్లౌడ్ సందర్భాలకు సిఫార్సు చేయబడింది.

### పోలిక పట్టిక

ఈ క్రింది పోలిక పట్టికను చూడండి, ఈ ట్రాన్స్‌పోర్ట్ మెకానిజమ్స్ మధ్య తేడాలను అర్థం చేసుకోండి:

| ట్రాన్స్‌పోర్ట్       | రియల్-టైమ్ అప్డేట్లు | స్ట్రీమింగ్ | స్కేలబిలిటీ | ఉపయోగం                |
|---------------------|----------------------|------------|-------------|-------------------------|
| stdio               | లేదు                 | లేదు       | తక్కువ     | స్థానిక CLI టూల్స్     |
| SSE                 | అవును                 | అవును       | మధ్యస్థం   | వెబ్, రియల్-టైమ్ అప్డేట్లు |
| స్ట్రీమబుల్ HTTP     | అవును                 | అవును       | అధికం      | క్లౌడ్, బహుళ క్లయింట్లు |

> **సూచన:** సరైన ట్రాన్స్‌పోర్ట్ ఎంపిక పనితీరు, స్కేలబిలిటీ మరియు వినియోగదారు అనుభవంపై ప్రభావం చూపుతుంది. ఆధునిక, స్కేలబుల్ మరియు క్లౌడ్-సిద్ధ అప్లికేషన్ల కోసం **స్ట్రీమబుల్ HTTP** సిఫార్సు చేయబడింది.

మునుపటి అధ్యాయాల్లో మీరు చూసిన stdio మరియు SSE ట్రాన్స్‌పోర్ట్లను గమనించండి మరియు ఈ అధ్యాయంలో కవర్ చేసిన స్ట్రీమబుల్ HTTP ట్రాన్స్‌పోర్ట్ ఎలా ఉన్నదో చూడండి.

## స్ట్రీమింగ్: భావనలు మరియు ప్రేరణ

స్ట్రీమింగ్ వెనుక ఉన్న ప్రాథమిక భావనలు మరియు ప్రేరణలను అర్థం చేసుకోవడం సమర్థవంతమైన రియల్-టైమ్ కమ్యూనికేషన్ సిస్టమ్స్ అమలుకు అవసరం.

**స్ట్రీమింగ్** అనేది నెట్‌వర్క్ ప్రోగ్రామింగ్‌లో ఒక సాంకేతికత, ఇది మొత్తం ప్రతిస్పందన సిద్ధంగా ఉండే వరకు వేచి ఉండకుండా, డేటాను చిన్న, నిర్వహించదగిన భాగాలుగా లేదా ఈవెంట్ల సీక్వెన్స్‌గా పంపించడానికి మరియు స్వీకరించడానికి అనుమతిస్తుంది. ఇది ప్రత్యేకంగా ఉపయోగకరం:

- పెద్ద ఫైళ్ళు లేదా డేటాసెట్‌లు.
- రియల్-టైమ్ అప్డేట్లు (ఉదా: చాట్, ప్రోగ్రెస్ బార్లు).
- దీర్ఘకాలిక గణనలలో యూజర్‌ను సమాచారం అందించడానికి.

స్ట్రీమింగ్ గురించి మీరు తెలుసుకోవలసిన ముఖ్యాంశాలు:

- డేటా క్రమంగా అందించబడుతుంది, ఒకేసారి కాదు.
- క్లయింట్ డేటాను అందుకున్న వెంటనే ప్రాసెస్ చేయగలదు.
- అనుభూతి లోతు తగ్గించి వినియోగదారు అనుభవాన్ని మెరుగుపరుస్తుంది.

### స్ట్రీమింగ్ ఎందుకు ఉపయోగించాలి?

స్ట్రీమింగ్ ఉపయోగించే కారణాలు:

- వినియోగదారులు తక్షణమే ఫీడ్‌బ్యాక్ పొందుతారు, కేవలం చివరలో కాదు
- రియల్-టైమ్ అప్లికేషన్లు మరియు స్పందనాత్మక UIలను సాధ్యం చేస్తుంది
- నెట్‌వర్క్ మరియు కంప్యూట్ వనరుల మరింత సమర్థవంతమైన వినియోగం

### సాదా ఉదాహరణ: HTTP స్ట్రీమింగ్ సర్వర్ & క్లయింట్

స్ట్రీమింగ్ ఎలా అమలు చేయవచ్చో ఒక సాదా ఉదాహరణ ఇక్కడ ఉంది:

#### Python

**సర్వర్ (Python, FastAPI మరియు StreamingResponse ఉపయోగించి):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**క్లయింట్ (Python, requests ఉపయోగించి):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

ఈ ఉదాహరణలో సర్వర్ అందుబాటులో ఉన్న సందేశాలను క్రమంగా క్లయింట్‌కు పంపుతుంది, అన్ని సందేశాలు సిద్ధంగా ఉండే వరకు వేచి ఉండదు.

**ఇది ఎలా పనిచేస్తుంది:**

- సర్వర్ ప్రతి సందేశాన్ని సిద్ధమైన వెంటనే ఇస్తుంది.
- క్లయింట్ అందుకున్న ప్రతి భాగాన్ని ప్రింట్ చేస్తుంది.

**అవసరాలు:**

- సర్వర్ స్ట్రీమింగ్ ప్రతిస్పందన (ఉదా: FastAPIలో `StreamingResponse`) ఉపయోగించాలి.
- క్లయింట్ ప్రతిస్పందనను స్ట్రీమ్‌గా ప్రాసెస్ చేయాలి (`requests`లో `stream=True`).
- కంటెంట్-టైప్ సాధారణంగా `text/event-stream` లేదా `application/octet-stream` ఉంటుంది.

#### Java

**సర్వర్ (Java, Spring Boot మరియు Server-Sent Events ఉపయోగించి):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**క్లయింట్ (Java, Spring WebFlux WebClient ఉపయోగించి):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java అమలు గమనికలు:**

- స్ట్రీమింగ్ కోసం Spring Boot యొక్క రియాక్టివ్ స్టాక్ `Flux` ఉపయోగిస్తుంది
- `ServerSentEvent` ఈవెంట్ రకాలతో నిర్మిత ఈవెంట్ స్ట్రీమింగ్ అందిస్తుంది
- `WebClient` లో `bodyToFlux()` రియాక్టివ్ స్ట్రీమింగ్ వినియోగాన్ని సులభతరం చేస్తుంది
- `delayElements()` ఈవెంట్ల మధ్య ప్రాసెసింగ్ సమయాన్ని అనుకరిస్తుంది
- ఈవెంట్లకు మెరుగైన క్లయింట్ హ్యాండ్లింగ్ కోసం రకాల (ఉదా: `info`, `result`) ఉండవచ్చు

### పోలిక: క్లాసిక్ స్ట్రీమింగ్ vs MCP స్ట్రీమింగ్

"క్లాసిక్" విధానంలో స్ట్రీమింగ్ ఎలా పనిచేస్తుందో మరియు MCPలో స్ట్రీమింగ్ ఎలా పనిచేస్తుందో మధ్య తేడాలు ఇలా ఉంటాయి:

| లక్షణం                | క్లాసిక్ HTTP స్ట్రీమింగ్       | MCP స్ట్రీమింగ్ (నోటిఫికేషన్లు)  |
|-----------------------|-------------------------------|----------------------------------|
| ప్రధాన ప్రతిస్పందన     | చంక్‌లుగా                    | ఒకటే, చివరలో                    |
| ప్రోగ్రెస్ అప్డేట్లు   | డేటా చంక్‌లుగా పంపబడతాయి  | నోటిఫికేషన్లుగా పంపబడతాయి     |
| క్లయింట్ అవసరాలు     | స్ట్రీమ్ ప్రాసెస్ చేయాలి      | సందేశ హ్యాండ్లర్ అమలు చేయాలి    |
| ఉపయోగం               | పెద్ద ఫైళ్ళు, AI టోకెన్ స్ట్రీమ్స్ | ప్రోగ్రెస్, లాగ్స్, రియల్-టైమ్ ఫీడ్‌బ్యాక్ |

### ముఖ్య తేడాలు

ఇంకా కొన్ని ముఖ్య తేడాలు:

- **కమ్యూనికేషన్ ప్యాటర్న్:**
  - క్లాసిక్ HTTP స్ట్రీమింగ్: సాదా చంక్ ట్రాన్స్‌ఫర్ ఎంకోడింగ్ ఉపయోగించి డేటాను చంక్‌లుగా పంపుతుంది
  - MCP స్ట్రీమింగ్: JSON-RPC ప్రోటోకాల్‌తో నిర్మిత నోటిఫికేషన్ సిస్టమ్ ఉపయోగిస్తుంది

- **సందేశ ఫార్మాట్:**
  - క్లాసిక్ HTTP: కొత్త లైన్లతో సాధారణ టెక్స్ట్ చంక్స్
  - MCP: మెటాడేటాతో నిర్మిత LoggingMessageNotification ఆబ్జెక్టులు

- **క్లయింట్ అమలు:**
  - క్లాసిక్ HTTP: స్ట్రీమింగ్ ప్రతిస్పందనలను ప్రాసెస్ చేసే సాదా క్లయింట్
  - MCP: వివిధ రకాల సందేశాలను ప్రాసెస్ చేయడానికి సందేశ హ్యాండ్లర్ ఉన్న అధునాతన క్లయింట్

- **ప్రోగ్రెస్ అప్డేట్లు:**
  - క్లాసిక్ HTTP: ప్రోగ్రెస్ ప్రధాన ప్రతిస్పందన స్ట్రీమ్‌లో భాగం
  - MCP: ప్రోగ్రెస్ వేర్వేరు నోటిఫికేషన్ సందేశాల ద్వారా పంపబడుతుంది, ప్రధాన ప్రతిస్పందన చివరలో వస్తుంది

### సిఫార్సులు

క్లాసిక్ స్ట్రీమింగ్ (ముందు చూపిన `/stream` ఎండ్‌పాయింట్ ఉపయోగించి) మరియు MCP ద్వారా స్ట్రీమింగ్ ఎంపికలో కొన్ని సిఫార్సులు:

- **సాదా స్ట్రీమింగ్ అవసరాలకు:** క్లాసిక్ HTTP స్ట్రీమింగ్ అమలు చేయడం సులభం మరియు ప్రాథమిక అవసరాలకు సరిపోతుంది.

- **సంక్లిష్ట, ఇంటరాక్టివ్ అప్లికేషన్లకు:** MCP స్ట్రీమింగ్ మెటాడేటాతో నిర్మిత విధానాన్ని అందిస్తుంది, నోటిఫికేషన్లు మరియు తుది ఫలితాల మధ్య వేరుపడటం ఉంటుంది.

- **AI అప్లికేషన్లకు:** MCP నోటిఫికేషన్ సిస్టమ్ దీర్ఘకాలిక AI పనులలో ప్రోగ్రెస్ గురించి వినియోగదారులకు సమాచారం అందించడానికి చాలా ఉపయోగకరం.

## MCPలో స్ట్రీమింగ్

ఇప్పటి వరకు క్లాసిక్ స్ట్రీమింగ్ మరియు MCP స్ట్రీమింగ్ మధ్య తేడాలపై కొన్ని సిఫార్సులు మరియు పోలికలు చూశారు. ఇప్పుడు MCPలో స్ట్రీమింగ్‌ను మీరు ఎలా ఉపయోగించుకోవచ్చో వివరంగా తెలుసుకుందాం.

MCP ఫ్రేమ్‌వర్క్‌లో స్ట్రీమింగ్ ఎలా పనిచేస్తుందో అర్థం చేసుకోవడం, దీర్ఘకాలిక ఆపరేషన్ల సమయంలో వినియోగదారులకు రియల్-టైమ్ ఫీడ్‌బ్యాక్ అందించే స్పందనాత్మక అప్లికేషన్లను నిర్మించడానికి అవసరం.

MCPలో, ప్రధాన ప్రతిస్పందనను చంక్‌లుగా పంపడం కాదు, కానీ టూల్ అభ్యర్థనను ప్రాసెస్ చేస్తున్నప్పుడు క్లయింట్‌కు **నోటిఫికేషన్లు** పంపడం. ఈ నోటిఫికేషన్లు ప్రోగ్రెస్ అప్డేట్లు, లాగ్స్ లేదా ఇతర ఈవెంట్లను కలిగి ఉండవచ్చు.

### ఇది ఎలా పనిచేస్తుంది

ప్రధాన ఫలితం ఇంకా ఒకే ప్రతిస్పందనగా పంపబడుతుంది. అయితే, ప్రాసెసింగ్ సమయంలో వేర్వేరు సందేశాలుగా నోటిఫికేషన్లు పంపబడతాయి మరియు క్లయింట్‌ను రియల్-టైమ్‌లో అప్డేట్ చేస్తాయి. క్లయింట్ ఈ నోటిఫికేషన్లను హ్యాండిల్ చేసి ప్రదర్శించగలగాలి.

## నోటిఫికేషన్ అంటే ఏమిటి?

మనం "నోటిఫికేషన్" అని చెప్పాము, MCP సందర్భంలో దాని అర్థం ఏమిటి?

నోటిఫికేషన్ అనేది సర్వర్ నుండి క్లయింట్‌కు పంపే సందేశం, దీర్ఘకాలిక ఆపరేషన్ సమయంలో ప్రోగ్రెస్, స్థితి లేదా ఇతర ఈవెంట్ల గురించి సమాచారం అందిస్తుంది. నోటిఫికేషన్లు పారదర్శకత మరియు వినియోగదారు అనుభవాన్ని మెరుగుపరుస్తాయి.

ఉదాహరణకు, క్లయింట్ సర్వర్‌తో ప్రారంభ హ్యాండ్‌షేక్ పూర్తయిన వెంటనే ఒక నోటిఫికేషన్ పంపాలి.

నోటిఫికేషన్ JSON సందేశం ఇలా ఉంటుంది:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

నోటిఫికేషన్లు MCPలో ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) అనే టాపిక్‌కు చెందుతాయి.

లాగింగ్ పనిచేయడానికి, సర్వర్ దాన్ని ఫీచర్/సామర్థ్యంగా క్రింది విధంగా ఎనేబుల్ చేయాలి:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> ఉపయోగిస్తున్న SDK ఆధారంగా, లాగింగ్ డిఫాల్ట్‌గా ఎనేబుల్ అయి ఉండవచ్చు లేదా మీరు సర్వర్ కాన్ఫిగరేషన్‌లో స్పష్టంగా ఎనేబుల్ చేయవలసి ఉండవచ్చు.

వివిధ రకాల నోటిఫికేషన్లు ఉన్నాయి:

| స్థాయి       | వివరణ                         | ఉదాహరణ ఉపయోగం               |
|-------------|-------------------------------|-------------------------------|
| debug       | వివరమైన డీబగ్గింగ్ సమాచారం  | ఫంక్షన్ ఎంట్రీ/ఎగ్జిట్ పాయింట్లు |
| info        | సాధారణ సమాచార సందేశాలు     | ఆపరేషన్ ప్రోగ్రెస్ అప్డేట్లు   |
| notice      | సాధారణ కానీ ముఖ్య ఈవెంట్లు    | కాన్ఫిగరేషన్ మార్పులు           |
| warning     | హెచ్చరిక పరిస్థితులు            | డిప్రికేటెడ్ ఫీచర్ వినియోగం  |
| error       | లోప పరిస్థితులు                | ఆపరేషన్ వైఫల్యాలు             |
| critical    | అత్యవసర పరిస్థితులు           | సిస్టమ్ భాగాల వైఫల్యాలు       |
| alert       | తక్షణ చర్య అవసరం             | డేటా కరప్షన్ గుర్తింపు       |
| emergency   | సిస్టమ్ ఉపయోగించలేనిది       | పూర్తి సిస్టమ్ వైఫల్యం         |

## MCPలో నోటిఫికేషన్లు అమలు చేయడం

MCPలో నోటిఫికేషన్లు అమలు చేయడానికి, మీరు సర్వర్ మరియు క్లయింట్ రెండింటినీ రియల్-టైమ్ అప్డేట్లను హ్యాండిల్ చేయడానికి సెట్ చేయాలి. ఇది మీ అప్లికేషన్‌ను దీర్ఘకాలిక ఆపరేషన్ల సమయంలో వినియోగదారులకు తక్షణ ఫీడ్‌బ్యాక్ అందించడానికి అనుమతిస్తుంది.

### సర్వర్-సైడ్: నోటిఫికేషన్లు పంపడం

ముందుగా సర్వర్ వైపు ప్రారంభిద్దాం. MCPలో, మీరు అభ్యర్థనలను ప్రాసెస్ చేస్తున్నప్పుడు నోటిఫికేషన్లు పంపగల టూల్స్‌ను నిర్వచిస్తారు. సర్వర్ కాంటెక్స్ట్ ఆబ్జెక్ట్ (సాధారణంగా `ctx`) ఉపయోగించి క్లయింట్‌కు సందేశాలు పంపుతుంది.

#### Python

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

ముందటి ఉదాహరణలో, `process_files` టూల్ ప్రతి ఫైల్ ప్రాసెస్ చేస్తున్నప్పుడు మూడు నోటిఫికేషన్లు క్లయింట్‌కు పంపుతుంది. `ctx.info()` పద్ధతి సమాచార సందేశాలను పంపడానికి ఉపయోగించబడుతుంది.

అదనంగా, నోటిఫికేషన్లు ఎనేబుల్ చేయడానికి, మీ సర్వర్ స్ట్రీమింగ్ ట్రాన్స్‌పోర్ట్ (ఉదా: `streamable-http`) ఉపయోగించాలి మరియు మీ క్లయింట్ నోటిఫికేషన్లను ప్రాసెస్ చేయడానికి సందేశ హ్యాండ్లర్ అమలు చేయాలి. సర్వర్‌ను `streamable-http` ట్రాన్స్‌పోర్ట్ ఉపయోగించడానికి ఎలా సెట్ చేయాలో ఇక్కడ ఉంది:

```python
mcp.run(transport="streamable-http")
```

#### .NET

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

ఈ .NET ఉదాహరణలో, `ProcessFiles` టూల్ `Tool` అట్రిబ్యూట్‌తో అలంకరించబడింది మరియు ప్రతి ఫైల్ ప్రాసెస్ చేస్తున్నప్పుడు మూడు నోటిఫికేషన్లు క్లయింట్‌కు పంపుతుంది. `ctx.Info()` పద్ధతి సమాచార సందేశాలను పంపడానికి ఉపయోగించబడుతుంది.

మీ .NET MCP సర్వర్‌లో నోటిఫికేషన్లు ఎనేబుల్ చేయడానికి, స్ట్రీమింగ్ ట్రాన్స్‌పోర్ట్ ఉపయోగిస్తున్నారని నిర్ధారించుకోండి:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

### క్లయింట్-సైడ్: నోటిఫికేషన్లు స్వీకరించడం

క్లయింట్ నోటిఫికేషన్లు వచ్చినప్పుడు వాటిని ప్రాసెస్ చేసి ప్రదర్శించడానికి సందేశ హ్యాండ్లర్ అమలు చేయాలి.

#### Python

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

ముందటి కోడ్‌లో, `message_handler` ఫంక్షన్ వచ్చే సందేశం నోటిఫికేషన్ అయితే దాన్ని ప్రింట్ చేస్తుంది; లేకపోతే సాధారణ సర్వర్ సందేశంగా ప్రాసెస్ చేస్తుంది. అలాగే, `ClientSession`ని `message_handler`తో ప్రారంభించడం ద్వారా నోటిఫికేషన్లను హ్యాండిల్ చేస్తుంది.

#### .NET

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

ఈ .NET ఉదాహరణలో, `MessageHandler` ఫంక్షన్ వచ్చే సందేశం నోటిఫికేషన్ అయితే దాన్ని ప్రింట్ చేస్తుంది; లేకపోతే సాధారణ సర్వర్ సందేశంగా ప్రాసెస్ చేస్తుంది. `
## SSE నుండి Streamable HTTP కి అప్‌గ్రేడ్ చేయడం

ప్రస్తుతం Server-Sent Events (SSE) ఉపయోగిస్తున్న అప్లికేషన్ల కోసం, Streamable HTTP కి మారడం మీ MCP అమలులకు మెరుగైన సామర్థ్యాలు మరియు దీర్ఘకాలిక స్థిరత్వాన్ని అందిస్తుంది.

### ఎందుకు అప్‌గ్రేడ్ చేయాలి?

SSE నుండి Streamable HTTP కి అప్‌గ్రేడ్ చేయడానికి రెండు ప్రధాన కారణాలు ఉన్నాయి:

- Streamable HTTP SSE కంటే మెరుగైన స్కేలబిలిటీ, అనుకూలత మరియు సమృద్ధిగా నోటిఫికేషన్ మద్దతును అందిస్తుంది.
- ఇది కొత్త MCP అప్లికేషన్ల కోసం సిఫార్సు చేయబడిన ట్రాన్స్‌పోర్ట్.

### మార్పిడి దశలు

మీ MCP అప్లికేషన్లలో SSE నుండి Streamable HTTP కి ఎలా మారాలో ఇక్కడ ఉంది:

- **సర్వర్ కోడ్‌ను నవీకరించండి** `mcp.run()` లో `transport="streamable-http"` ఉపయోగించడానికి.
- **క్లయింట్ కోడ్‌ను నవీకరించండి** SSE క్లయింట్ స్థానంలో `streamablehttp_client` ఉపయోగించడానికి.
- **క్లయింట్‌లో ఒక సందేశ హ్యాండ్లర్ అమలు చేయండి** నోటిఫికేషన్లను ప్రాసెస్ చేయడానికి.
- **ఉపకరణాలు మరియు వర్క్‌ఫ్లోలతో అనుకూలత కోసం పరీక్షించండి**.

### అనుకూలతను నిర్వహించడం

మార్పిడి ప్రక్రియలో ప్రస్తుత SSE క్లయింట్లతో అనుకూలతను నిర్వహించడం సిఫార్సు చేయబడింది. కొన్ని వ్యూహాలు:

- మీరు SSE మరియు Streamable HTTP రెండింటినీ వేర్వేరు ఎండ్‌పాయింట్లపై రెండింటినీ నడిపించి మద్దతు ఇవ్వవచ్చు.
- క్లయింట్లను కొత్త ట్రాన్స్‌పోర్ట్‌కు క్రమంగా మార్చండి.

### సవాళ్లు

మార్పిడి సమయంలో ఈ సవాళ్లను పరిష్కరించండి:

- అన్ని క్లయింట్లు నవీకరించబడినట్లు నిర్ధారించడం
- నోటిఫికేషన్ డెలివరీలో తేడాలను నిర్వహించడం

## భద్రతా పరిగణనలు

ఏ సర్వర్‌ను అమలు చేయడంలో భద్రత అత్యంత ప్రాధాన్యత కలిగి ఉండాలి, ముఖ్యంగా MCPలో Streamable HTTP వంటి HTTP ఆధారిత ట్రాన్స్‌పోర్ట్‌లను ఉపయోగిస్తున్నప్పుడు.

HTTP ఆధారిత ట్రాన్స్‌పోర్ట్‌లతో MCP సర్వర్‌లను అమలు చేయడంలో భద్రత అనేక దాడి మార్గాలు మరియు రక్షణ యంత్రాంగాలపై జాగ్రత్తగా దృష్టి పెట్టాల్సిన అత్యంత ముఖ్యమైన అంశం అవుతుంది.

### అవలోకనం

MCP సర్వర్‌లను HTTP ద్వారా ప్రదర్శించేటప్పుడు భద్రత అత్యంత కీలకం. Streamable HTTP కొత్త దాడి ఉపరితలాలను పరిచయం చేస్తుంది మరియు జాగ్రత్తగా కాన్ఫిగర్ చేయాల్సి ఉంటుంది.

ఇక్కడ కొన్ని ముఖ్యమైన భద్రతా పరిగణనలు ఉన్నాయి:

- **Origin హెడ్డర్ ధృవీకరణ**: DNS రీబైండింగ్ దాడులను నివారించడానికి ఎప్పుడూ `Origin` హెడ్డర్‌ను ధృవీకరించండి.
- **Localhost బైండింగ్**: స్థానిక అభివృద్ధి కోసం సర్వర్‌లను `localhost` కు బైండ్ చేయండి, ప్రజా ఇంటర్నెట్‌కు ప్రదర్శించకుండా.
- **ప్రామాణీకరణ**: ఉత్పత్తి అమరికల కోసం ప్రామాణీకరణ (ఉదా: API కీలు, OAuth) అమలు చేయండి.
- **CORS**: యాక్సెస్‌ను పరిమితం చేయడానికి క్రాస్-ఒరిజిన్ రిసోర్స్ షేరింగ్ (CORS) విధానాలను కాన్ఫిగర్ చేయండి.
- **HTTPS**: ట్రాఫిక్‌ను ఎన్‌క్రిప్ట్ చేయడానికి ఉత్పత్తిలో HTTPS ఉపయోగించండి.

### ఉత్తమ ఆచారాలు

మీ MCP స్ట్రీమింగ్ సర్వర్‌లో భద్రతను అమలు చేయడంలో పాటించాల్సిన కొన్ని ఉత్తమ ఆచారాలు:

- ధృవీకరణ లేకుండా వచ్చే అభ్యర్థనలను ఎప్పుడూ నమ్మకండి.
- అన్ని యాక్సెస్ మరియు లోపాలను లాగ్ చేసి పర్యవేక్షించండి.
- భద్రతా లోపాలను ప్యాచ్ చేయడానికి ఆధారాలను తరచుగా నవీకరించండి.

### సవాళ్లు

MCP స్ట్రీమింగ్ సర్వర్‌లలో భద్రతను అమలు చేయడంలో మీరు ఎదుర్కొనే కొన్ని సవాళ్లు:

- అభివృద్ధి సౌలభ్యంతో భద్రతను సమతుల్యం చేయడం
- వివిధ క్లయింట్ వాతావరణాలతో అనుకూలతను నిర్ధారించడం

### అసైన్‌మెంట్: మీ స్వంత స్ట్రీమింగ్ MCP యాప్‌ను నిర్మించండి

**సన్నివేశం:**
సర్వర్ ఒక అంశాల జాబితాను (ఉదా: ఫైళ్లు లేదా డాక్యుమెంట్లు) ప్రాసెస్ చేసి ప్రతి అంశం ప్రాసెస్ అయినప్పుడు ఒక నోటిఫికేషన్ పంపే MCP సర్వర్ మరియు క్లయింట్‌ను నిర్మించండి. క్లయింట్ ప్రతి నోటిఫికేషన్ వచ్చిన వెంటనే ప్రదర్శించాలి.

**దశలు:**

1. ఒక సర్వర్ టూల్‌ను అమలు చేయండి, ఇది జాబితాను ప్రాసెస్ చేసి ప్రతి అంశానికి నోటిఫికేషన్లు పంపుతుంది.
2. నోటిఫికేషన్లను రియల్ టైంలో ప్రదర్శించడానికి సందేశ హ్యాండ్లర్‌తో ఒక క్లయింట్‌ను అమలు చేయండి.
3. సర్వర్ మరియు క్లయింట్ రెండింటినీ నడిపించి, నోటిఫికేషన్లను గమనించి మీ అమలును పరీక్షించండి.

[Solution](./solution/README.md)

## మరింత చదవడం & తదుపరి ఏమిటి?

MCP స్ట్రీమింగ్‌తో మీ ప్రయాణాన్ని కొనసాగించడానికి మరియు మీ జ్ఞానాన్ని విస్తరించడానికి, ఈ విభాగం అదనపు వనరులు మరియు మరింత అభివృద్ధి చెందిన అప్లికేషన్లను నిర్మించడానికి సూచించిన తదుపరి దశలను అందిస్తుంది.

### మరింత చదవడం

- [Microsoft: HTTP స్ట్రీమింగ్ పరిచయం](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: ASP.NET Core లో CORS](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: స్ట్రీమింగ్ అభ్యర్థనలు](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### తదుపరి ఏమిటి?

- రియల్ టైమ్ అనలిటిక్స్, చాట్ లేదా సహకార ఎడిటింగ్ కోసం స్ట్రీమింగ్ ఉపయోగించే మరింత అభివృద్ధి చెందిన MCP టూల్స్‌ను నిర్మించడానికి ప్రయత్నించండి.
- MCP స్ట్రీమింగ్‌ను ఫ్రంట్‌ఎండ్ ఫ్రేమ్‌వర్క్‌ల (React, Vue, మొదలైనవి)తో లైవ్ UI నవీకరణల కోసం ఏకీకృతం చేయడం అన్వేషించండి.
- తదుపరి: [VSCode కోసం AI టూల్‌కిట్ ఉపయోగించడం](../07-aitk/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**అస్పష్టత**:  
ఈ పత్రాన్ని AI అనువాద సేవ [Co-op Translator](https://github.com/Azure/co-op-translator) ఉపయోగించి అనువదించబడింది. మేము ఖచ్చితత్వానికి ప్రయత్నించినప్పటికీ, ఆటోమేటెడ్ అనువాదాల్లో పొరపాట్లు లేదా తప్పిదాలు ఉండవచ్చు. మూల పత్రం దాని స్వదేశీ భాషలో అధికారిక మూలంగా పరిగణించాలి. ముఖ్యమైన సమాచారానికి, ప్రొఫెషనల్ మానవ అనువాదం సిఫార్సు చేయబడుతుంది. ఈ అనువాదం వాడకంలో ఏర్పడిన ఏవైనా అపార్థాలు లేదా తప్పుదారితీసే అర్థాలు కోసం మేము బాధ్యత వహించము.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->