<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "904b59de1de9264801242d90a42cdd9d",
  "translation_date": "2025-12-11T10:16:11+00:00",
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "te"
}
-->
# MCP కోర్ కాన్సెప్ట్‌లు: AI ఇంటిగ్రేషన్ కోసం మోడల్ కాంటెక్స్ట్ ప్రోటోకాల్‌ను మాస్టర్ చేయడం

[![MCP Core Concepts](../../../translated_images/02.8203e26c6fb5a797f38a10012061013ec66c95bb3260f6c9cfd2bf74b00860e1.te.png)](https://youtu.be/earDzWGtE84)

_(ఈ పాఠం వీడియోను చూడడానికి పై చిత్రాన్ని క్లిక్ చేయండి)_

[Model Context Protocol (MCP)](https://github.com/modelcontextprotocol) అనేది పెద్ద భాషా మోడల్స్ (LLMs) మరియు బాహ్య టూల్స్, అప్లికేషన్లు, మరియు డేటా సోర్సుల మధ్య కమ్యూనికేషన్‌ను ఆప్టిమైజ్ చేసే శక్తివంతమైన, ప్రమాణీకృత ఫ్రేమ్‌వర్క్.  
ఈ గైడ్ MCP యొక్క కోర్ కాన్సెప్ట్‌ల ద్వారా మీకు మార్గనిర్దేశం చేస్తుంది. మీరు దాని క్లయింట్-సర్వర్ ఆర్కిటెక్చర్, ముఖ్య భాగాలు, కమ్యూనికేషన్ మెకానిక్స్, మరియు అమలు ఉత్తమ పద్ధతుల గురించి నేర్చుకుంటారు.

- **స్పష్టమైన యూజర్ అనుమతి**: అన్ని డేటా యాక్సెస్ మరియు ఆపరేషన్లు అమలు ముందు స్పష్టమైన యూజర్ ఆమోదం అవసరం. యూజర్లు ఏ డేటా యాక్సెస్ చేయబడుతుందో మరియు ఏ చర్యలు తీసుకోబడతాయో స్పష్టంగా అర్థం చేసుకోవాలి, అనుమతులు మరియు అధికారాలపై సూక్ష్మ నియంత్రణతో.

- **డేటా గోప్యత రక్షణ**: యూజర్ డేటా స్పష్టమైన అనుమతితో మాత్రమే ప్రదర్శించబడుతుంది మరియు మొత్తం ఇంటరాక్షన్ లైఫ్‌సైకిల్‌లో బలమైన యాక్సెస్ నియంత్రణలతో రక్షించబడాలి. అమలు అనధికార డేటా ప్రసారం నివారించాలి మరియు కఠిన గోప్యత సరిహద్దులను నిర్వహించాలి.

- **టూల్ అమలు భద్రత**: ప్రతి టూల్ పిలుపు స్పష్టమైన యూజర్ అనుమతితో అవసరం, టూల్ యొక్క ఫంక్షనాలిటీ, పారామీటర్లు, మరియు సంభావ్య ప్రభావం స్పష్టంగా అర్థం చేసుకోవాలి. బలమైన భద్రతా సరిహద్దులు అనుకోని, అప్రమత్తం కాని, లేదా దుర్మార్గ టూల్ అమలును నిరోధించాలి.

- **ట్రాన్స్‌పోర్ట్ లేయర్ సెక్యూరిటీ**: అన్ని కమ్యూనికేషన్ ఛానెల్స్ సరైన ఎన్‌క్రిప్షన్ మరియు ధృవీకరణ మెకానిజంలను ఉపయోగించాలి. రిమోట్ కనెక్షన్లు సురక్షిత ట్రాన్స్‌పోర్ట్ ప్రోటోకాల్స్ మరియు సరైన క్రెడెన్షియల్ నిర్వహణను అమలు చేయాలి.

#### అమలు మార్గదర్శకాలు:

- **అనుమతి నిర్వహణ**: యూజర్లు ఏ సర్వర్లు, టూల్స్, మరియు వనరులు యాక్సెస్ చేయగలరో నియంత్రించడానికి సూక్ష్మ అనుమతి వ్యవస్థలను అమలు చేయండి  
- **ధృవీకరణ & అధికారం**: సురక్షిత ధృవీకరణ పద్ధతులు (OAuth, API కీలు) సరైన టోకెన్ నిర్వహణ మరియు గడువు తో ఉపయోగించండి  
- **ఇన్‌పుట్ ధృవీకరణ**: ఇంజెక్షన్ దాడులను నివారించడానికి నిర్వచించిన స్కీమాల ప్రకారం అన్ని పారామీటర్లు మరియు డేటా ఇన్‌పుట్‌లను ధృవీకరించండి  
- **ఆడిట్ లాగింగ్**: భద్రతా పర్యవేక్షణ మరియు అనుగుణత కోసం అన్ని ఆపరేషన్ల సమగ్ర లాగ్‌లను నిర్వహించండి

## అవలోకనం

ఈ పాఠం Model Context Protocol (MCP) ఎకోసిస్టమ్‌ను రూపొందించే ప్రాథమిక ఆర్కిటెక్చర్ మరియు భాగాలను అన్వేషిస్తుంది. మీరు క్లయింట్-సర్వర్ ఆర్కిటెక్చర్, ముఖ్య భాగాలు, మరియు MCP ఇంటరాక్షన్లను శక్తివంతం చేసే కమ్యూనికేషన్ మెకానిజంల గురించి నేర్చుకుంటారు.

## ముఖ్యమైన నేర్చుకునే లక్ష్యాలు

ఈ పాఠం ముగింపు వరకు, మీరు:

- MCP క్లయింట్-సర్వర్ ఆర్కిటెక్చర్‌ను అర్థం చేసుకుంటారు.  
- హోస్ట్లు, క్లయింట్లు, మరియు సర్వర్ల పాత్రలు మరియు బాధ్యతలను గుర్తిస్తారు.  
- MCP ను ఒక సౌలభ్యమైన ఇంటిగ్రేషన్ లేయర్‌గా చేసే కోర్ ఫీచర్లను విశ్లేషిస్తారు.  
- MCP ఎకోసిస్టమ్‌లో సమాచారం ఎలా ప్రవహిస్తుందో నేర్చుకుంటారు.  
- .NET, జావా, పైథాన్, మరియు జావాస్క్రిప్ట్‌లో కోడ్ ఉదాహరణల ద్వారా ప్రాక్టికల్ అవగాహన పొందుతారు.

## MCP ఆర్కిటెక్చర్: లోతైన దృష్టి

MCP ఎకోసిస్టమ్ క్లయింట్-సర్వర్ మోడల్‌పై నిర్మించబడింది. ఈ మాడ్యులర్ నిర్మాణం AI అప్లికేషన్లు టూల్స్, డేటాబేసులు, APIs, మరియు సందర్భ సంబంధ వనరులతో సమర్థవంతంగా ఇంటరాక్ట్ అవ్వడానికి అనుమతిస్తుంది. ఈ ఆర్కిటెక్చర్‌ను దాని ముఖ్య భాగాలుగా విభజిద్దాం.

మూలంగా, MCP ఒక క్లయింట్-సర్వర్ ఆర్కిటెక్చర్‌ను అనుసరిస్తుంది, ఇక్కడ ఒక హోస్ట్ అప్లికేషన్ అనేక సర్వర్లకు కనెక్ట్ అవుతుంది:

```mermaid
flowchart LR
    subgraph "మీ కంప్యూటర్"
        Host["MCP తో హోస్ట్ (విజువల్ స్టూడియో, VS కోడ్, IDEలు, టూల్స్)"]
        S1["MCP సర్వర్ A"]
        S2["MCP సర్వర్ B"]
        S3["MCP సర్వర్ C"]
        Host <-->|"MCP ప్రోటోకాల్"| S1
        Host <-->|"MCP ప్రోటోకాల్"| S2
        Host <-->|"MCP ప్రోటోకాల్"| S3
        S1 <--> D1[("స్థానిక\డేటా మూలం A")]
        S2 <--> D2[("స్థానిక\డేటా మూలం B")]
    end
    subgraph "ఇంటర్నెట్"
        S3 <-->|"వెబ్ APIs"| D3[("దూర\సేవలు")]
    end
```
- **MCP హోస్ట్లు**: VSCode, Claude Desktop, IDEలు, లేదా MCP ద్వారా డేటా యాక్సెస్ చేయాలనుకునే AI టూల్స్ వంటి ప్రోగ్రామ్లు  
- **MCP క్లయింట్లు**: సర్వర్లతో 1:1 కనెక్షన్లను నిర్వహించే ప్రోటోకాల్ క్లయింట్లు  
- **MCP సర్వర్లు**: ప్రతి ఒక్కటి ప్రమాణీకృత Model Context Protocol ద్వారా నిర్దిష్ట సామర్థ్యాలను ప్రదర్శించే లైట్‌వెయిట్ ప్రోగ్రామ్లు  
- **లోకల్ డేటా సోర్సులు**: మీ కంప్యూటర్ ఫైళ్లు, డేటాబేసులు, మరియు MCP సర్వర్లు సురక్షితంగా యాక్సెస్ చేయగల సేవలు  
- **రిమోట్ సర్వీసులు**: ఇంటర్నెట్ ద్వారా అందుబాటులో ఉన్న బాహ్య సిస్టమ్లు, MCP సర్వర్లు APIs ద్వారా కనెక్ట్ అవ్వగలవు.

MCP ప్రోటోకాల్ ఒక అభివృద్ధి చెందుతున్న ప్రమాణం, తేదీ ఆధారిత వెర్షనింగ్ (YYYY-MM-DD ఫార్మాట్) ఉపయోగిస్తుంది. ప్రస్తుత ప్రోటోకాల్ వెర్షన్ **2025-06-18**. మీరు తాజా నవీకరణలను [ప్రోటోకాల్ స్పెసిఫికేషన్](https://modelcontextprotocol.io/specification/2025-06-18/)లో చూడవచ్చు.

### 1. హోస్ట్లు

Model Context Protocol (MCP)లో, **హోస్ట్లు** అనేవి యూజర్లు ప్రోటోకాల్‌తో ఇంటరాక్ట్ అయ్యే ప్రాథమిక ఇంటర్‌ఫేస్‌గా పనిచేసే AI అప్లికేషన్లు. హోస్ట్లు అనేక MCP సర్వర్లకు కనెక్షన్లను సమన్వయపరచి నిర్వహిస్తాయి, ప్రతి సర్వర్ కనెక్షన్ కోసం ప్రత్యేక MCP క్లయింట్లను సృష్టించడం ద్వారా. హోస్ట్ల ఉదాహరణలు:

- **AI అప్లికేషన్లు**: Claude Desktop, Visual Studio Code, Claude Code  
- **డెవలప్‌మెంట్ ఎన్విరాన్‌మెంట్లు**: MCP ఇంటిగ్రేషన్ ఉన్న IDEలు మరియు కోడ్ ఎడిటర్లు  
- **కస్టమ్ అప్లికేషన్లు**: ప్రత్యేకంగా రూపొందించిన AI ఏజెంట్లు మరియు టూల్స్

**హోస్ట్లు** అనేవి AI మోడల్ ఇంటరాక్షన్లను సమన్వయపరుస్తాయి. అవి:

- **AI మోడల్స్‌ను ఆర్కెస్ట్రేట్ చేస్తాయి**: LLMs తో స్పందనలు సృష్టించడానికి లేదా ఇంటరాక్ట్ చేయడానికి మరియు AI వర్క్‌ఫ్లోలను సమన్వయపరచడానికి  
- **క్లయింట్ కనెక్షన్లను నిర్వహిస్తాయి**: ప్రతి MCP సర్వర్ కనెక్షన్‌కు ఒక MCP క్లయింట్‌ను సృష్టించి నిర్వహిస్తాయి  
- **యూజర్ ఇంటర్‌ఫేస్‌ను నియంత్రిస్తాయి**: సంభాషణ ప్రవాహం, యూజర్ ఇంటరాక్షన్లు, మరియు స్పందన ప్రదర్శనను నిర్వహిస్తాయి  
- **భద్రతను అమలు చేస్తాయి**: అనుమతులు, భద్రతా పరిమితులు, మరియు ధృవీకరణను నియంత్రిస్తాయి  
- **యూజర్ అనుమతిని నిర్వహిస్తాయి**: డేటా పంచుకోవడం మరియు టూల్ అమలుకు యూజర్ ఆమోదాన్ని నిర్వహిస్తాయి

### 2. క్లయింట్లు

**క్లయింట్లు** అనేవి హోస్ట్ మరియు MCP సర్వర్ల మధ్య ప్రత్యేకమైన ఒకటి-ఒకటి కనెక్షన్లను నిర్వహించే ముఖ్య భాగాలు. ప్రతి MCP క్లయింట్ ఒక నిర్దిష్ట MCP సర్వర్‌కు కనెక్ట్ కావడానికి హోస్ట్ ద్వారా సృష్టించబడుతుంది, క్రమబద్ధీకరించిన మరియు సురక్షిత కమ్యూనికేషన్ ఛానెల్స్‌ను నిర్ధారిస్తుంది. అనేక క్లయింట్లు హోస్ట్లకు అనేక సర్వర్లకు ఒకేసారి కనెక్ట్ కావడానికి అనుమతిస్తాయి.

**క్లయింట్లు** అనేవి హోస్ట్ అప్లికేషన్‌లో కనెక్టర్ భాగాలు. అవి:

- **ప్రోటోకాల్ కమ్యూనికేషన్**: ప్రాంప్ట్‌లు మరియు సూచనలతో సర్వర్లకు JSON-RPC 2.0 అభ్యర్థనలను పంపుతాయి  
- **సామర్థ్య చర్చ**: ప్రారంభ సమయంలో సర్వర్లతో మద్దతు ఉన్న ఫీచర్లు మరియు ప్రోటోకాల్ వెర్షన్లను చర్చిస్తాయి  
- **టూల్ అమలు**: మోడల్స్ నుండి టూల్ అమలు అభ్యర్థనలను నిర్వహించి స్పందనలను ప్రాసెస్ చేస్తాయి  
- **రియల్-టైమ్ అప్డేట్లు**: సర్వర్ల నుండి నోటిఫికేషన్లు మరియు రియల్-టైమ్ అప్డేట్లను నిర్వహిస్తాయి  
- **స్పందన ప్రాసెసింగ్**: ప్రదర్శన కోసం సర్వర్ స్పందనలను ప్రాసెస్ చేసి ఫార్మాట్ చేస్తాయి

### 3. సర్వర్లు

**సర్వర్లు** అనేవి MCP క్లయింట్లకు సందర్భం, టూల్స్, మరియు సామర్థ్యాలను అందించే ప్రోగ్రామ్లు. అవి లోకల్‌గా (హోస్ట్‌తో అదే యంత్రం) లేదా రిమోట్‌గా (బాహ్య ప్లాట్‌ఫారమ్‌లపై) అమలు చేయవచ్చు, మరియు క్లయింట్ అభ్యర్థనలను నిర్వహించి నిర్మిత స్పందనలను అందించడానికి బాధ్యత వహిస్తాయి. సర్వర్లు ప్రమాణీకృత Model Context Protocol ద్వారా నిర్దిష్ట ఫంక్షనాలిటీని ప్రదర్శిస్తాయి.

**సర్వర్లు** అనేవి సందర్భం మరియు సామర్థ్యాలను అందించే సేవలు. అవి:

- **ఫీచర్ రిజిస్ట్రేషన్**: క్లయింట్లకు అందుబాటులో ఉన్న ప్రిమిటివ్స్ (వనరులు, ప్రాంప్ట్‌లు, టూల్స్)ను నమోదు చేసి ప్రదర్శిస్తాయి  
- **అభ్యర్థన ప్రాసెసింగ్**: క్లయింట్ల నుండి టూల్ కాల్స్, వనరు అభ్యర్థనలు, మరియు ప్రాంప్ట్ అభ్యర్థనలను స్వీకరించి అమలు చేస్తాయి  
- **సందర్భం అందించడం**: మోడల్ స్పందనలను మెరుగుపరచడానికి సందర్భ సంబంధ సమాచారం మరియు డేటాను అందిస్తాయి  
- **స్టేట్ నిర్వహణ**: అవసరమైతే సెషన్ స్థితిని నిర్వహించి స్థితిసంబంధ ఇంటరాక్షన్లను నిర్వహిస్తాయి  
- **రియల్-టైమ్ నోటిఫికేషన్లు**: సామర్థ్య మార్పులు మరియు అప్డేట్ల గురించి కనెక్ట్ అయిన క్లయింట్లకు నోటిఫికేషన్లు పంపుతాయి

సర్వర్లు ప్రత్యేక ఫంక్షనాలిటీతో మోడల్ సామర్థ్యాలను విస్తరించడానికి ఎవరికైనా అభివృద్ధి చేయవచ్చు, మరియు అవి లోకల్ మరియు రిమోట్ అమలు పరిస్థితులను మద్దతు ఇస్తాయి.

### 4. సర్వర్ ప్రిమిటివ్స్

Model Context Protocol (MCP)లో సర్వర్లు మూడు ప్రధాన **ప్రిమిటివ్స్**ను అందిస్తాయి, ఇవి క్లయింట్లు, హోస్ట్లు, మరియు భాషా మోడల్స్ మధ్య సంపన్నమైన ఇంటరాక్షన్లకు ప్రాథమిక నిర్మాణ బ్లాక్స్‌ను నిర్వచిస్తాయి. ఈ ప్రిమిటివ్స్ ప్రోటోకాల్ ద్వారా అందుబాటులో ఉన్న సందర్భ సంబంధ సమాచారం మరియు చర్యల రకాలను స్పష్టంగా పేర్కొంటాయి.

MCP సర్వర్లు క్రింది మూడు ప్రధాన ప్రిమిటివ్స్ ఏదైనా కలిపి ప్రదర్శించవచ్చు:

#### వనరులు

**వనరులు** అనేవి AI అప్లికేషన్లకు సందర్భ సంబంధ సమాచారాన్ని అందించే డేటా సోర్సులు. అవి మోడల్ అర్థం చేసుకోవడం మరియు నిర్ణయాలు తీసుకోవడాన్ని మెరుగుపరచగల స్థిరమైన లేదా డైనమిక్ కంటెంట్‌ను సూచిస్తాయి:

- **సందర్భ డేటా**: AI మోడల్ వినియోగానికి నిర్మిత సమాచారం మరియు సందర్భం  
- **జ్ఞాన ఆధారాలు**: డాక్యుమెంట్ రిపాజిటరీలు, వ్యాసాలు, మాన్యువల్స్, మరియు పరిశోధనా పత్రాలు  
- **లోకల్ డేటా సోర్సులు**: ఫైళ్లు, డేటాబేసులు, మరియు లోకల్ సిస్టమ్ సమాచారం  
- **బాహ్య డేటా**: API స్పందనలు, వెబ్ సర్వీసులు, మరియు రిమోట్ సిస్టమ్ డేటా  
- **డైనమిక్ కంటెంట్**: బాహ్య పరిస్థితుల ఆధారంగా నవీకరించబడే రియల్-టైమ్ డేటా

వనరులు URIల ద్వారా గుర్తించబడతాయి మరియు `resources/list` ద్వారా కనుగొనబడతాయి, `resources/read` ద్వారా పొందబడతాయి:

```text
file://documents/project-spec.md
database://production/users/schema
api://weather/current
```

#### ప్రాంప్ట్‌లు

**ప్రాంప్ట్‌లు** అనేవి భాషా మోడల్స్‌తో ఇంటరాక్షన్లను నిర్మించడానికి సహాయపడే పునర్వినియోగపరచదగిన టెంప్లేట్లు. అవి ప్రమాణీకృత ఇంటరాక్షన్ నమూనాలు మరియు టెంప్లేటెడ్ వర్క్‌ఫ్లోలను అందిస్తాయి:

- **టెంప్లేట్ ఆధారిత ఇంటరాక్షన్లు**: ముందుగా నిర్మించబడిన సందేశాలు మరియు సంభాషణ ప్రారంభకులు  
- **వర్క్‌ఫ్లో టెంప్లేట్లు**: సాధారణ పనులు మరియు ఇంటరాక్షన్ల కోసం ప్రమాణీకృత క్రమాలు  
- **ఫ్యూ-షాట్ ఉదాహరణలు**: మోడల్ సూచన కోసం ఉదాహరణ ఆధారిత టెంప్లేట్లు  
- **సిస్టమ్ ప్రాంప్ట్‌లు**: మోడల్ ప్రవర్తన మరియు సందర్భాన్ని నిర్వచించే ప్రాథమిక ప్రాంప్ట్‌లు  
- **డైనమిక్ టెంప్లేట్లు**: నిర్దిష్ట సందర్భాలకు అనుగుణంగా మారే పారామీటరైజ్డ్ ప్రాంప్ట్‌లు

ప్రాంప్ట్‌లు వేరియబుల్ స్థానంలో పెట్టడం మద్దతు ఇస్తాయి మరియు `prompts/list` ద్వారా కనుగొనబడతాయి, `prompts/get` ద్వారా పొందబడతాయి:

```markdown
Generate a {{task_type}} for {{product}} targeting {{audience}} with the following requirements: {{requirements}}
```

#### టూల్స్

**టూల్స్** అనేవి AI మోడల్స్ నిర్దిష్ట చర్యలు చేయడానికి పిలవగల అమలు చేయదగిన ఫంక్షన్లు. అవి MCP ఎకోసిస్టమ్‌లో "క్రియాపదాలు"ని సూచిస్తాయి, మోడల్స్ బాహ్య సిస్టమ్లతో ఇంటరాక్ట్ అవ్వడానికి వీలు కల్పిస్తాయి:

- **అమలు చేయదగిన ఫంక్షన్లు**: మోడల్స్ నిర్దిష్ట పారామీటర్లతో పిలవగల విడివిడిగా ఆపరేషన్లు  
- **బాహ్య సిస్టమ్ ఇంటిగ్రేషన్**: API కాల్స్, డేటాబేస్ క్వెరీలు, ఫైల్ ఆపరేషన్లు, లెక్కింపులు  
- **అనన్య గుర్తింపు**: ప్రతి టూల్‌కు ప్రత్యేక పేరు, వివరణ, మరియు పారామీటర్ స్కీమా ఉంటుంది  
- **నిర్మిత I/O**: టూల్స్ ధృవీకరించబడిన పారామీటర్లను స్వీకరిస్తాయి మరియు నిర్మిత, టైప్ చేయబడిన స్పందనలను ఇస్తాయి  
- **చర్య సామర్థ్యాలు**: మోడల్స్‌కు వాస్తవ ప్రపంచ చర్యలు చేయడానికి మరియు ప్రత్యక్ష డేటాను పొందడానికి వీలు కల్పిస్తాయి

టూల్స్ పారామీటర్ ధృవీకరణ కోసం JSON స్కీమాతో నిర్వచించబడతాయి మరియు `tools/list` ద్వారా కనుగొనబడతాయి, `tools/call` ద్వారా అమలు చేయబడతాయి:

```typescript
server.tool(
  "search_products", 
  {
    query: z.string().describe("Search query for products"),
    category: z.string().optional().describe("Product category filter"),
    max_results: z.number().default(10).describe("Maximum results to return")
  }, 
  async (params) => {
    // శోధనను అమలు చేసి నిర్మిత ఫలితాలను తిరిగి ఇవ్వండి
    return await productService.search(params);
  }
);
```

## క్లయింట్ ప్రిమిటివ్స్

Model Context Protocol (MCP)లో, **క్లయింట్లు** హోస్ట్ అప్లికేషన్ నుండి అదనపు సామర్థ్యాలను సర్వర్లకు అభ్యర్థించడానికి ప్రిమిటివ్స్‌ను ప్రదర్శించవచ్చు. ఈ క్లయింట్-సైడ్ ప్రిమిటివ్స్ మరింత సంపన్నమైన, ఇంటరాక్టివ్ సర్వర్ అమలులకు అనుమతిస్తాయి
- **లైఫ్‌సైకిల్ నిర్వహణ**: క్లయింట్లు మరియు సర్వర్ల మధ్య కనెక్షన్ ప్రారంభం, సామర్థ్య చర్చ, మరియు సెషన్ ముగింపు నిర్వహిస్తుంది  
- **సర్వర్ ప్రిమిటివ్స్**: సర్వర్లు టూల్స్, వనరులు, మరియు ప్రాంప్ట్‌ల ద్వారా ప్రాథమిక ఫంక్షనాలిటీని అందించగలుగుతాయి  
- **క్లయింట్ ప్రిమిటివ్స్**: సర్వర్లు LLMల నుండి శాంప్లింగ్ కోరడం, వినియోగదారుల ఇన్‌పుట్ పొందడం, మరియు లాగ్ సందేశాలు పంపడం చేయగలుగుతాయి  
- **రియల్-టైమ్ నోటిఫికేషన్లు**: పోలింగ్ లేకుండా డైనమిక్ అప్‌డేట్ల కోసం అసింక్రనస్ నోటిఫికేషన్లను మద్దతు ఇస్తుంది  

#### ముఖ్య లక్షణాలు:

- **ప్రోటోకాల్ వెర్షన్ చర్చ**: అనుకూలత కోసం తేదీ ఆధారిత వెర్షనింగ్ (YYYY-MM-DD) ఉపయోగిస్తుంది  
- **సామర్థ్య కనుగొనడం**: ప్రారంభ సమయంలో క్లయింట్లు మరియు సర్వర్లు మద్దతు ఉన్న ఫీచర్ల సమాచారాన్ని మార్పిడి చేస్తాయి  
- **స్టేట్‌ఫుల్ సెషన్లు**: కాంటెక్స్ట్ నిరంతరత్వం కోసం అనేక పరస్పర చర్యలలో కనెక్షన్ స్థితిని నిర్వహిస్తుంది  

### ట్రాన్స్‌పోర్ట్ లేయర్

**ట్రాన్స్‌పోర్ట్ లేయర్** MCP పాల్గొనేవారికి మధ్య కమ్యూనికేషన్ ఛానల్స్, సందేశ ఫ్రేమింగ్, మరియు ఆథెంటికేషన్‌ను నిర్వహిస్తుంది:

#### మద్దతు పొందిన ట్రాన్స్‌పోర్ట్ మెకానిజమ్స్:

1. **STDIO ట్రాన్స్‌పోర్ట్**:  
   - డైరెక్ట్ ప్రాసెస్ కమ్యూనికేషన్ కోసం స్టాండర్డ్ ఇన్‌పుట్/అవుట్‌పుట్ స్ట్రీమ్స్ ఉపయోగిస్తుంది  
   - అదే యంత్రంపై స్థానిక ప్రాసెస్‌లకు నెట్‌వర్క్ ఓవర్‌హెడ్ లేకుండా ఉత్తమం  
   - స్థానిక MCP సర్వర్ అమలులకు సాధారణంగా ఉపయోగిస్తారు  

2. **స్ట్రీమబుల్ HTTP ట్రాన్స్‌పోర్ట్**:  
   - క్లయింట్-టు-సర్వర్ సందేశాల కోసం HTTP POST ఉపయోగిస్తుంది  
   - సర్వర్-టు-క్లయింట్ స్ట్రీమింగ్ కోసం ఐచ్ఛిక Server-Sent Events (SSE)  
   - నెట్‌వర్క్‌ల ద్వారా రిమోట్ సర్వర్ కమ్యూనికేషన్‌ను సులభతరం చేస్తుంది  
   - స్టాండర్డ్ HTTP ఆథెంటికేషన్ (బేర్ టోకెన్లు, API కీలు, కస్టమ్ హెడ్డర్లు) మద్దతు ఇస్తుంది  
   - సురక్షిత టోకెన్-ఆధారిత ఆథెంటికేషన్ కోసం MCP OAuthని సిఫార్సు చేస్తుంది  

#### ట్రాన్స్‌పోర్ట్ అభిసరణ:

ట్రాన్స్‌పోర్ట్ లేయర్ కమ్యూనికేషన్ వివరాలను డేటా లేయర్ నుండి వేరుచేస్తుంది, అందువల్ల అన్ని ట్రాన్స్‌పోర్ట్ మెకానిజమ్స్‌లో ఒకే JSON-RPC 2.0 సందేశ ఫార్మాట్ ఉపయోగించవచ్చు. ఈ అభిసరణ అనువర్తనాలు స్థానిక మరియు రిమోట్ సర్వర్ల మధ్య సులభంగా మార్పిడి చేయగలుగుతుంది.

### భద్రతా పరిగణనలు

MCP అమలులు అన్ని ప్రోటోకాల్ ఆపరేషన్లలో సురక్షిత, నమ్మదగిన, మరియు భద్రత కలిగిన పరస్పర చర్యలను నిర్ధారించడానికి కొన్ని కీలక భద్రతా సూత్రాలను పాటించాలి:

- **వినియోగదారుల అనుమతి మరియు నియంత్రణ**: ఏ డేటా యాక్సెస్ చేయబడక ముందు లేదా ఆపరేషన్లు చేయబడక ముందు వినియోగదారులు స్పష్టమైన అనుమతిని ఇవ్వాలి. వారు ఏ డేటా పంచుకోవాలో మరియు ఏ చర్యలు అనుమతించబడ్డాయో స్పష్టంగా నియంత్రించగలగాలి, మరియు కార్యకలాపాలను సమీక్షించడానికి మరియు ఆమోదించడానికి సులభమైన వినియోగదారు ఇంటర్‌ఫేస్‌లు ఉండాలి.

- **డేటా గోప్యత**: వినియోగదారుల డేటా స్పష్టమైన అనుమతితో మాత్రమే ప్రదర్శించబడాలి మరియు సరైన యాక్సెస్ నియంత్రణలతో రక్షించబడాలి. MCP అమలులు అనధికార డేటా ప్రసారం నుండి రక్షించాలి మరియు అన్ని పరస్పర చర్యలలో గోప్యతను నిర్ధారించాలి.

- **టూల్ భద్రత**: ఏ టూల్‌ను పిలవడానికి ముందు స్పష్టమైన వినియోగదారుల అనుమతి అవసరం. వినియోగదారులు ప్రతి టూల్ యొక్క ఫంక్షనాలిటీని స్పష్టంగా అర్థం చేసుకోవాలి, మరియు అనుకోని లేదా అసురక్షిత టూల్ అమలును నివారించడానికి బలమైన భద్రతా సరిహద్దులు అమలు చేయాలి.

ఈ భద్రతా సూత్రాలను పాటించడం ద్వారా MCP అన్ని ప్రోటోకాల్ పరస్పర చర్యలలో వినియోగదారుల నమ్మకం, గోప్యత, మరియు భద్రతను కాపాడుతుంది, మరియు శక్తివంతమైన AI ఇంటిగ్రేషన్లను సాధ్యమవుతుంది.

## కోడ్ ఉదాహరణలు: ముఖ్య భాగాలు

క్రింది కోడ్ ఉదాహరణలు కొన్ని ప్రముఖ ప్రోగ్రామింగ్ భాషలలో MCP సర్వర్ ముఖ్య భాగాలు మరియు టూల్స్ ఎలా అమలు చేయాలో చూపిస్తాయి.

### .NET ఉదాహరణ: టూల్స్‌తో సింపుల్ MCP సర్వర్ సృష్టించడం

ఇది ఒక ప్రాక్టికల్ .NET కోడ్ ఉదాహరణ, ఇది కస్టమ్ టూల్స్‌తో సింపుల్ MCP సర్వర్‌ను ఎలా అమలు చేయాలో చూపిస్తుంది. ఈ ఉదాహరణ టూల్స్ నిర్వచించడం, రిజిస్టర్ చేయడం, అభ్యర్థనలను నిర్వహించడం, మరియు మోడల్ కాంటెక్స్ట్ ప్రోటోకాల్ ఉపయోగించి సర్వర్ కనెక్ట్ చేయడం ఎలా చేయాలో చూపిస్తుంది.

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```

### జావా ఉదాహరణ: MCP సర్వర్ భాగాలు

ఈ ఉదాహరణ .NET ఉదాహరణలో ఉన్న MCP సర్వర్ మరియు టూల్ రిజిస్ట్రేషన్‌ను జావాలో అమలు చేయడం చూపిస్తుంది.

```java
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpToolDefinition;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.server.tool.ToolExecutionContext;
import io.modelcontextprotocol.server.tool.ToolResponse;

public class WeatherMcpServer {
    public static void main(String[] args) throws Exception {
        // ఒక MCP సర్వర్ సృష్టించండి
        McpServer server = McpServer.builder()
            .name("Weather MCP Server")
            .version("1.0.0")
            .build();
            
        // ఒక వాతావరణ సాధనాన్ని నమోదు చేయండి
        server.registerTool(McpToolDefinition.builder("weatherTool")
            .description("Gets current weather for a location")
            .parameter("location", String.class)
            .execute((ToolExecutionContext ctx) -> {
                String location = ctx.getParameter("location", String.class);
                
                // వాతావరణ డేటాను పొందండి (సరళీకృతం)
                WeatherData data = getWeatherData(location);
                
                // ఫార్మాట్ చేయబడిన ప్రతిస్పందనను తిరిగి ఇవ్వండి
                return ToolResponse.content(
                    String.format("Temperature: %.1f°F, Conditions: %s, Location: %s", 
                    data.getTemperature(), 
                    data.getConditions(), 
                    data.getLocation())
                );
            })
            .build());
        
        // stdio ట్రాన్స్‌పోర్ట్ ఉపయోగించి సర్వర్‌ను కనెక్ట్ చేయండి
        try (StdioServerTransport transport = new StdioServerTransport()) {
            server.connect(transport);
            System.out.println("Weather MCP Server started");
            // ప్రాసెస్ ముగిసేవరకు సర్వర్ నడుస్తూనే ఉంచండి
            Thread.currentThread().join();
        }
    }
    
    private static WeatherData getWeatherData(String location) {
        // అమలు వాతావరణ APIని పిలుస్తుంది
        // ఉదాహరణ కోసం సరళీకృతం చేయబడింది
        return new WeatherData(72.5, "Sunny", location);
    }
}

class WeatherData {
    private double temperature;
    private String conditions;
    private String location;
    
    public WeatherData(double temperature, String conditions, String location) {
        this.temperature = temperature;
        this.conditions = conditions;
        this.location = location;
    }
    
    public double getTemperature() {
        return temperature;
    }
    
    public String getConditions() {
        return conditions;
    }
    
    public String getLocation() {
        return location;
    }
}
```

### పైథాన్ ఉదాహరణ: MCP సర్వర్ నిర్మాణం

ఈ ఉదాహరణ fastmcp ఉపయోగిస్తుంది, కాబట్టి దయచేసి ముందుగా దాన్ని ఇన్‌స్టాల్ చేసుకోండి:

```python
pip install fastmcp
```
కోడ్ నమూనా:

```python
#!/usr/bin/env python3
import asyncio
from fastmcp import FastMCP
from fastmcp.transports.stdio import serve_stdio

# ఒక FastMCP సర్వర్ సృష్టించండి
mcp = FastMCP(
    name="Weather MCP Server",
    version="1.0.0"
)

@mcp.tool()
def get_weather(location: str) -> dict:
    """Gets current weather for a location."""
    return {
        "temperature": 72.5,
        "conditions": "Sunny",
        "location": location
    }

# ఒక తరగతి ఉపయోగించి ప్రత్యామ్నాయ విధానం
class WeatherTools:
    @mcp.tool()
    def forecast(self, location: str, days: int = 1) -> dict:
        """Gets weather forecast for a location for the specified number of days."""
        return {
            "location": location,
            "forecast": [
                {"day": i+1, "temperature": 70 + i, "conditions": "Partly Cloudy"}
                for i in range(days)
            ]
        }

# తరగతి టూల్స్‌ను నమోదు చేయండి
weather_tools = WeatherTools()

# సర్వర్‌ను ప్రారంభించండి
if __name__ == "__main__":
    asyncio.run(serve_stdio(mcp))
```

### జావాస్క్రిప్ట్ ఉదాహరణ: MCP సర్వర్ సృష్టించడం

ఈ ఉదాహరణ జావాస్క్రిప్ట్‌లో MCP సర్వర్ సృష్టించడం మరియు రెండు వాతావరణ సంబంధిత టూల్స్‌ను రిజిస్టర్ చేయడం చూపిస్తుంది.

```javascript
// అధికారిక మోడల్ కాంటెక్స్ట్ ప్రోటోకాల్ SDK ఉపయోగించడం
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod"; // పారామితి ధృవీకరణ కోసం

// ఒక MCP సర్వర్ సృష్టించండి
const server = new McpServer({
  name: "Weather MCP Server",
  version: "1.0.0"
});

// ఒక వాతావరణ సాధనం నిర్వచించండి
server.tool(
  "weatherTool",
  {
    location: z.string().describe("The location to get weather for")
  },
  async ({ location }) => {
    // ఇది సాధారణంగా వాతావరణ API ని పిలుస్తుంది
    // ప్రదర్శన కోసం సరళీకృతం
    const weatherData = await getWeatherData(location);
    
    return {
      content: [
        { 
          type: "text", 
          text: `Temperature: ${weatherData.temperature}°F, Conditions: ${weatherData.conditions}, Location: ${weatherData.location}` 
        }
      ]
    };
  }
);

// ఒక ముందస్తు సూచన సాధనం నిర్వచించండి
server.tool(
  "forecastTool",
  {
    location: z.string(),
    days: z.number().default(3).describe("Number of days for forecast")
  },
  async ({ location, days }) => {
    // ఇది సాధారణంగా వాతావరణ API ని పిలుస్తుంది
    // ప్రదర్శన కోసం సరళీకృతం
    const forecast = await getForecastData(location, days);
    
    return {
      content: [
        { 
          type: "text", 
          text: `${days}-day forecast for ${location}: ${JSON.stringify(forecast)}` 
        }
      ]
    };
  }
);

// సహాయక ఫంక్షన్లు
async function getWeatherData(location) {
  // API కాల్ ను అనుకరించండి
  return {
    temperature: 72.5,
    conditions: "Sunny",
    location: location
  };
}

async function getForecastData(location, days) {
  // API కాల్ ను అనుకరించండి
  return Array.from({ length: days }, (_, i) => ({
    day: i + 1,
    temperature: 70 + Math.floor(Math.random() * 10),
    conditions: i % 2 === 0 ? "Sunny" : "Partly Cloudy"
  }));
}

// stdio ట్రాన్స్‌పోర్ట్ ఉపయోగించి సర్వర్ ను కనెక్ట్ చేయండి
const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

console.log("Weather MCP Server started");
```
  
ఈ జావాస్క్రిప్ట్ ఉదాహరణ MCP క్లయింట్‌ను సృష్టించడం, సర్వర్‌కు కనెక్ట్ కావడం, ప్రాంప్ట్ పంపడం, మరియు టూల్ కాల్స్ సహా ప్రతిస్పందనను ప్రాసెస్ చేయడం ఎలా చేయాలో చూపిస్తుంది.

## భద్రత మరియు అనుమతి

MCP ప్రోటోకాల్ అంతటా భద్రత మరియు అనుమతిని నిర్వహించడానికి కొన్ని అంతర్గత భావనలు మరియు మెకానిజమ్స్ కలిగి ఉంది:

1. **టూల్ అనుమతి నియంత్రణ**:  
   సెషన్ సమయంలో మోడల్ ఉపయోగించగల టూల్స్‌ను క్లయింట్లు నిర్దేశించవచ్చు. ఇది స్పష్టంగా అనుమతించబడిన టూల్స్ మాత్రమే యాక్సెస్ చేయబడేలా చేస్తుంది, అనుకోని లేదా అసురక్షిత ఆపరేషన్ల ప్రమాదాన్ని తగ్గిస్తుంది. అనుమతులు వినియోగదారుల ఇష్టాలు, సంస్థా విధానాలు, లేదా పరస్పర చర్యల సందర్భం ఆధారంగా డైనమిక్‌గా సెట్ చేయవచ్చు.

2. **ఆథెంటికేషన్**:  
   సర్వర్లు టూల్స్, వనరులు, లేదా సున్నితమైన ఆపరేషన్ల యాక్సెస్‌కు ముందు ఆథెంటికేషన్ అవసరం చేయవచ్చు. ఇది API కీలు, OAuth టోకెన్లు, లేదా ఇతర ఆథెంటికేషన్ పద్ధతులను ఉపయోగించవచ్చు. సరైన ఆథెంటికేషన్ ద్వారా మాత్రమే నమ్మదగిన క్లయింట్లు మరియు వినియోగదారులు సర్వర్-సైడ్ సామర్థ్యాలను పిలవగలుగుతారు.

3. **వాలిడేషన్**:  
   అన్ని టూల్ పిలుపులకు పారామీటర్ వాలిడేషన్ అమలు చేయబడుతుంది. ప్రతి టూల్ తన పారామీటర్ల కోసం అంచనా వేయబడిన రకాలు, ఫార్మాట్లు, మరియు పరిమితులను నిర్వచిస్తుంది, మరియు సర్వర్ వచ్చే అభ్యర్థనలను అనుగుణంగా ధృవీకరిస్తుంది. ఇది తప్పు లేదా దుష్టమైన ఇన్‌పుట్ టూల్ అమలులకు చేరకుండా నిరోధిస్తుంది మరియు ఆపరేషన్ల సమగ్రతను కాపాడుతుంది.

4. **రేట్ లిమిటింగ్**:  
   దుర్వినియోగం నివారించడానికి మరియు సర్వర్ వనరుల సమాన వినియోగాన్ని నిర్ధారించడానికి MCP సర్వర్లు టూల్ కాల్స్ మరియు వనరు యాక్సెస్‌కు రేట్ లిమిటింగ్ అమలు చేయవచ్చు. రేట్ పరిమితులు వినియోగదారుని, సెషన్‌ను, లేదా గ్లోబల్‌గా వర్తించవచ్చు, మరియు డినయల్-ఆఫ్-సర్వీస్ దాడులు లేదా అధిక వనరు వినియోగం నుండి రక్షణ ఇస్తాయి.

ఈ మెకానిజమ్స్ కలిపి MCP భాషా మోడల్స్‌ను బాహ్య టూల్స్ మరియు డేటా వనరులతో సురక్షితంగా ఇంటిగ్రేట్ చేయడానికి, మరియు వినియోగదారులు మరియు డెవలపర్లకు యాక్సెస్ మరియు వినియోగంపై సున్నితమైన నియంత్రణను అందిస్తుంది.

## ప్రోటోకాల్ సందేశాలు & కమ్యూనికేషన్ ప్రవాహం

MCP కమ్యూనికేషన్ స్పష్టమైన మరియు నమ్మదగిన పరస్పర చర్యలకు నిర్మితమైన **JSON-RPC 2.0** సందేశాలను ఉపయోగిస్తుంది. ప్రోటోకాల్ వివిధ రకాల ఆపరేషన్ల కోసం నిర్దిష్ట సందేశ నమూనాలను నిర్వచిస్తుంది:

### ప్రాథమిక సందేశ రకాలు:

#### **ప్రారంభ సందేశాలు**  
- **`initialize` అభ్యర్థన**: కనెక్షన్ స్థాపించి ప్రోటోకాల్ వెర్షన్ మరియు సామర్థ్యాలను చర్చిస్తుంది  
- **`initialize` ప్రతిస్పందన**: మద్దతు ఉన్న ఫీచర్లు మరియు సర్వర్ సమాచారాన్ని నిర్ధారిస్తుంది  
- **`notifications/initialized`**: ప్రారంభం పూర్తయిందని మరియు సెషన్ సిద్ధంగా ఉందని సంకేతం ఇస్తుంది  

#### **కనుగొనడం సందేశాలు**  
- **`tools/list` అభ్యర్థన**: సర్వర్ నుండి అందుబాటులో ఉన్న టూల్స్ కనుగొంటుంది  
- **`resources/list` అభ్యర్థన**: అందుబాటులో ఉన్న వనరుల (డేటా సోర్సులు) జాబితా  
- **`prompts/list` అభ్యర్థన**: అందుబాటులో ఉన్న ప్రాంప్ట్ టెంప్లేట్లను పొందుతుంది  

#### **నిర్వహణ సందేశాలు**  
- **`tools/call` అభ్యర్థన**: అందించిన పారామీటర్లతో నిర్దిష్ట టూల్‌ను అమలు చేస్తుంది  
- **`resources/read` అభ్యర్థన**: నిర్దిష్ట వనరు నుండి కంటెంట్‌ను పొందుతుంది  
- **`prompts/get` అభ్యర్థన**: ఐచ్ఛిక పారామీటర్లతో ప్రాంప్ట్ టెంప్లేట్‌ను తెస్తుంది  

#### **క్లయింట్-సైడ్ సందేశాలు**  
- **`sampling/complete` అభ్యర్థన**: సర్వర్ క్లయింట్ నుండి LLM పూర్తి కోరుతుంది  
- **`elicitation/request`**: సర్వర్ వినియోగదారుల ఇన్‌పుట్ కోసం క్లయింట్ ఇంటర్‌ఫేస్ ద్వారా అభ్యర్థిస్తుంది  
- **లాగింగ్ సందేశాలు**: సర్వర్ క్లయింట్‌కు నిర్మిత లాగ్ సందేశాలు పంపుతుంది  

#### **నోటిఫికేషన్ సందేశాలు**  
- **`notifications/tools/list_changed`**: టూల్ మార్పుల గురించి క్లయింట్‌కు సర్వర్ నోటిఫై చేస్తుంది  
- **`notifications/resources/list_changed`**: వనరు మార్పుల గురించి క్లయింట్‌కు సర్వర్ నోటిఫై చేస్తుంది  
- **`notifications/prompts/list_changed`**: ప్రాంప్ట్ మార్పుల గురించి క్లయింట్‌కు సర్వర్ నోటిఫై చేస్తుంది  

### సందేశ నిర్మాణం:

అన్ని MCP సందేశాలు JSON-RPC 2.0 ఫార్మాట్‌ను అనుసరిస్తాయి:  
- **అభ్యర్థన సందేశాలు**: `id`, `method`, మరియు ఐచ్ఛిక `params` కలిగి ఉంటాయి  
- **ప్రతిస్పందన సందేశాలు**: `id` మరియు `result` లేదా `error` కలిగి ఉంటాయి  
- **నోటిఫికేషన్ సందేశాలు**: `method` మరియు ఐచ్ఛిక `params` కలిగి ఉంటాయి (id లేదా ప్రతిస్పందన అవసరం లేదు)  

ఈ నిర్మిత కమ్యూనికేషన్ నమ్మదగిన, ట్రేస్ చేయదగిన, మరియు విస్తరించదగిన పరస్పర చర్యలను నిర్ధారిస్తుంది, రియల్-టైమ్ అప్‌డేట్లు, టూల్ చైనింగ్, మరియు బలమైన లోపాల నిర్వహణ వంటి ఆధునిక సన్నివేశాలను మద్దతు ఇస్తుంది.

## ముఖ్యమైన పాఠాలు

- **ఆర్కిటెక్చర్**: MCP క్లయింట్-సర్వర్ ఆర్కిటెక్చర్‌ను ఉపయోగిస్తుంది, ఇక్కడ హోస్టులు సర్వర్లకు అనేక క్లయింట్ కనెక్షన్లను నిర్వహిస్తాయి  
- **పాల్గొనేవారు**: ఈ ఎకోసిస్టమ్‌లో హోస్టులు (AI అనువర్తనాలు), క్లయింట్లు (ప్రోటోకాల్ కనెక్టర్లు), మరియు సర్వర్లు (సామర్థ్య ప్రదాతలు) ఉంటారు  
- **ట్రాన్స్‌పోర్ట్ మెకానిజమ్స్**: కమ్యూనికేషన్ STDIO (స్థానిక) మరియు స్ట్రీమబుల్ HTTP ఐచ్ఛిక SSEతో (రిమోట్) మద్దతు ఇస్తుంది  
- **ప్రాథమిక ప్రిమిటివ్స్**: సర్వర్లు టూల్స్ (నిర్వహించదగిన ఫంక్షన్లు), వనరులు (డేటా సోర్సులు), మరియు ప్రాంప్ట్‌లు (టెంప్లేట్లు) అందిస్తాయి  
- **క్లయింట్ ప్రిమిటివ్స్**: సర్వర్లు శాంప్లింగ్ (LLM పూర్తి), ఎలిసిటేషన్ (వినియోగదారుల ఇన్‌పుట్), మరియు లాగింగ్ కోసం క్లయింట్లను కోరగలుగుతాయి  
- **ప్రోటోకాల్ పునాది**: JSON-RPC 2.0 ఆధారంగా, తేదీ ఆధారిత వెర్షనింగ్ (ప్రస్తుత: 2025-06-18)  
- **రియల్-టైమ్ సామర్థ్యాలు**: డైనమిక్ అప్‌డేట్లు మరియు రియల్-టైమ్ సమకాలీకరణ కోసం నోటిఫికేషన్లను మద్దతు ఇస్తుంది  
- **భద్రత మొదటి ప్రాధాన్యం**: స్పష్టమైన వినియోగదారుల అనుమతి, డేటా గోప్యత రక్షణ, మరియు సురక్షిత ట్రాన్స్‌పోర్ట్ ప్రధాన అవసరాలు  

## వ్యాయామం

మీ డొమైన్‌లో ఉపయోగకరమైన సింపుల్ MCP టూల్‌ను డిజైన్ చేయండి. నిర్వచించండి:  
1. ఆ టూల్ పేరు ఏమిటి  
2. అది ఏ పారామీటర్లను స్వీకరిస్తుంది  
3. అది ఏ అవుట్‌పుట్‌ను ఇస్తుంది  
4. వినియోగదారుల సమస్యలను పరిష్కరించడానికి మోడల్ ఈ టూల్‌ను ఎలా ఉపయోగించవచ్చు  

---

## తదుపరి

తదుపరి: [అధ్యాయం 2: భద్రత](../02-Security/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**అస్పష్టత**:  
ఈ పత్రాన్ని AI అనువాద సేవ [Co-op Translator](https://github.com/Azure/co-op-translator) ఉపయోగించి అనువదించబడింది. మేము ఖచ్చితత్వానికి ప్రయత్నించినప్పటికీ, ఆటోమేటెడ్ అనువాదాల్లో పొరపాట్లు లేదా తప్పిదాలు ఉండవచ్చు. మూల పత్రం దాని స్వదేశీ భాషలో అధికారిక మూలంగా పరిగణించాలి. ముఖ్యమైన సమాచారానికి, ప్రొఫెషనల్ మానవ అనువాదం సిఫార్సు చేయబడుతుంది. ఈ అనువాదం వాడకంలో ఏర్పడిన ఏవైనా అపార్థాలు లేదా తప్పుదారుల కోసం మేము బాధ్యత వహించము.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->