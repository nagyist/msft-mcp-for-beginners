# HTTPS ಸ್ಟ್ರೀಮಿಂಗ್ ಮಾದರಿ ಸಾಂದರ್ಭಿಕ ಪ್ರೋಟೋಕಾಲ್ (MCP) ಜೊತೆಗೆ

ಈ ಅಧ್ಯಾಯವು HTTPS ಬಳಸಿ ಮಾದರಿ ಸಾಂದರ್ಭಿಕ ಪ್ರೋಟೋಕಾಲ್ (MCP) ಮೂಲಕ ಸುರಕ್ಷಿತ, ವಿಸ್ತಾರಗೊಳ್ಳುವ ಮತ್ತು ರಿಯಲ್-ಟೈಮ್ ಸ್ಟ್ರೀಮಿಂಗ್ ಅನ್ನು ಅನುಷ್ಠಾನಗೊಳಿಸುವ ಸಮಗ್ರ ಮಾರ್ಗದರ್ಶಿಯನ್ನು ಒದಗಿಸುತ್ತದೆ. ಇದು ಸ್ಟ್ರೀಮಿಂಗ್‌ಗೆ ಪ್ರೇರಣೆ, ಲಭ್ಯವಿರುವ ಸಾರಿಗೆ ಯಂತ್ರಗಳು, MCP ನಲ್ಲಿ ಸ್ಟ್ರೀಮಬಲ್ HTTP ಅನ್ನು ಹೇಗೆ ಅನುಷ್ಠಾನಗೊಳಿಸುವುದು, ಭದ್ರತಾ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು, SSE ನಿಂದ ಸ್ಥಳಾಂತರ ಮತ್ತು ನಿಮ್ಮ ಸ್ವಂತ ಸ್ಟ್ರೀಮಿಂಗ್ MCP ಅಪ್ಲಿಕೇಶನ್‌ಗಳನ್ನು ನಿರ್ಮಿಸುವ ಪ್ರಾಯೋಗಿಕ ಮಾರ್ಗದರ್ಶನವನ್ನು ಒಳಗೊಂಡಿದೆ.

## MCP ನಲ್ಲಿ ಸಾರಿಗೆ ಯಂತ್ರಗಳು ಮತ್ತು ಸ್ಟ್ರೀಮಿಂಗ್

ಈ ವಿಭಾಗವು MCP ನಲ್ಲಿ ಲಭ್ಯವಿರುವ ವಿವಿಧ ಸಾರಿಗೆ ಯಂತ್ರಗಳನ್ನು ಮತ್ತು ಗ್ರಾಹಕರು ಮತ್ತು ಸರ್ವರ್‌ಗಳ ನಡುವೆ ರಿಯಲ್-ಟೈಮ್ ಸಂವಹನಕ್ಕಾಗಿ ಸ್ಟ್ರೀಮಿಂಗ್ ಸಾಮರ್ಥ್ಯಗಳನ್ನು ಸಕ್ರಿಯಗೊಳಿಸುವ ಅವರ ಪಾತ್ರವನ್ನು ಅನ್ವೇಷಿಸುತ್ತದೆ.

### ಸಾರಿಗೆ ಯಂತ್ರ ಎಂದರೆ ಏನು?

ಸಾರಿಗೆ ಯಂತ್ರವು ಗ್ರಾಹಕ ಮತ್ತು ಸರ್ವರ್ ನಡುವೆ ಡೇಟಾ ಹೇಗೆ ವಿನಿಮಯವಾಗುತ್ತದೆ ಎಂಬುದನ್ನು ವ್ಯಾಖ್ಯಾನಿಸುತ್ತದೆ. MCP ವಿವಿಧ ಪರಿಸರಗಳು ಮತ್ತು ಅಗತ್ಯಗಳಿಗೆ ಹೊಂದಿಕೊಳ್ಳಲು ಹಲವಾರು ಸಾರಿಗೆ ಪ್ರಕಾರಗಳನ್ನು ಬೆಂಬಲಿಸುತ್ತದೆ:

- **stdio**: ಸ್ಟ್ಯಾಂಡರ್ಡ್ ಇನ್‌ಪುಟ್/ಔಟ್‌ಪುಟ್, ಸ್ಥಳೀಯ ಮತ್ತು CLI ಆಧಾರಿತ ಸಾಧನಗಳಿಗೆ ಸೂಕ್ತ. ಸರಳ ಆದರೆ ವೆಬ್ ಅಥವಾ ಕ್ಲೌಡ್‌ಗೆ ಸೂಕ್ತವಲ್ಲ.
- **SSE (ಸರ್ವರ್-ಸೆಂಟ್ ಇವೆಂಟ್ಸ್)**: ಸರ್ವರ್‌ಗಳು HTTP ಮೂಲಕ ಗ್ರಾಹಕರಿಗೆ ರಿಯಲ್-ಟೈಮ್ ನವೀಕರಣಗಳನ್ನು ಒತ್ತಬಹುದು. ವೆಬ್ UI ಗಾಗಿ ಉತ್ತಮ, ಆದರೆ ವಿಸ್ತಾರಗೊಳ್ಳುವಿಕೆ ಮತ್ತು ಲವಚಿಕತೆಯಲ್ಲಿ ಮಿತವಾಗಿದೆ.
- **ಸ್ಟ್ರೀಮಬಲ್ HTTP**: ಆಧುನಿಕ HTTP ಆಧಾರಿತ ಸ್ಟ್ರೀಮಿಂಗ್ ಸಾರಿಗೆ, ಸೂಚನೆಗಳನ್ನು ಮತ್ತು ಉತ್ತಮ ವಿಸ್ತಾರಗೊಳ್ಳುವಿಕೆಯನ್ನು ಬೆಂಬಲಿಸುತ್ತದೆ. ಬಹುತೇಕ ಉತ್ಪಾದನೆ ಮತ್ತು ಕ್ಲೌಡ್ ಪರಿಸರಗಳಿಗೆ ಶಿಫಾರಸು ಮಾಡಲಾಗಿದೆ.

### ಹೋಲಿಕೆ ಟೇಬಲ್

ಈ ಸಾರಿಗೆ ಯಂತ್ರಗಳ ನಡುವಿನ ವ್ಯತ್ಯಾಸಗಳನ್ನು ಅರ್ಥಮಾಡಿಕೊಳ್ಳಲು ಕೆಳಗಿನ ಹೋಲಿಕೆ ಟೇಬಲ್ ನೋಡಿ:

| ಸಾರಿಗೆ           | ರಿಯಲ್-ಟೈಮ್ ನವೀಕರಣಗಳು | ಸ್ಟ್ರೀಮಿಂಗ್ | ವಿಸ್ತಾರಗೊಳ್ಳುವಿಕೆ | ಬಳಕೆ ಪ್ರಕರಣ          |
|------------------|-----------------------|------------|-----------------|-----------------------|
| stdio            | ಇಲ್ಲ                  | ಇಲ್ಲ       | ಕಡಿಮೆ           | ಸ್ಥಳೀಯ CLI ಸಾಧನಗಳು    |
| SSE              | ಹೌದು                  | ಹೌದು       | ಮಧ್ಯಮ           | ವೆಬ್, ರಿಯಲ್-ಟೈಮ್ ನವೀಕರಣಗಳು |
| ಸ್ಟ್ರೀಮಬಲ್ HTTP   | ಹೌದು                  | ಹೌದು       | ಹೆಚ್ಚು           | ಕ್ಲೌಡ್, ಬಹು-ಗ್ರಾಹಕ    |

> **ಸೂಚನೆ:** ಸರಿಯಾದ ಸಾರಿಗೆ ಆಯ್ಕೆ ಕಾರ್ಯಕ್ಷಮತೆ, ವಿಸ್ತಾರಗೊಳ್ಳುವಿಕೆ ಮತ್ತು ಬಳಕೆದಾರ ಅನುಭವವನ್ನು ಪ್ರಭಾವಿಸುತ್ತದೆ. ಆಧುನಿಕ, ವಿಸ್ತಾರಗೊಳ್ಳುವ ಮತ್ತು ಕ್ಲೌಡ್-ಸಿದ್ಧ ಅಪ್ಲಿಕೇಶನ್‌ಗಳಿಗೆ **ಸ್ಟ್ರೀಮಬಲ್ HTTP** ಶಿಫಾರಸು ಮಾಡಲಾಗಿದೆ.

ಹಿಂದಿನ ಅಧ್ಯಾಯಗಳಲ್ಲಿ ನೀವು ನೋಡಿದ stdio ಮತ್ತು SSE ಸಾರಿಗೆಗಳನ್ನು ಗಮನಿಸಿ ಮತ್ತು ಈ ಅಧ್ಯಾಯದಲ್ಲಿ ಚರ್ಚಿಸಲಾದ ಸ್ಟ್ರೀಮಬಲ್ HTTP ಸಾರಿಗೆ ಹೇಗೆ ಇದೆ ಎಂದು ಗಮನಿಸಿ.

## ಸ್ಟ್ರೀಮಿಂಗ್: ತತ್ವಗಳು ಮತ್ತು ಪ್ರೇರಣೆ

ಸ್ಟ್ರೀಮಿಂಗ್‌ನ ಮೂಲಭೂತ ತತ್ವಗಳು ಮತ್ತು ಪ್ರೇರಣೆಗಳನ್ನು ಅರ್ಥಮಾಡಿಕೊಳ್ಳುವುದು ಪರಿಣಾಮಕಾರಿ ರಿಯಲ್-ಟೈಮ್ ಸಂವಹನ ವ್ಯವಸ್ಥೆಗಳನ್ನು ಅನುಷ್ಠಾನಗೊಳಿಸಲು ಅಗತ್ಯ.

**ಸ್ಟ್ರೀಮಿಂಗ್** ಎಂದರೆ ನೆಟ್‌ವರ್ಕ್ ಪ್ರೋಗ್ರಾಮಿಂಗ್‌ನಲ್ಲಿ ಡೇಟಾವನ್ನು ಸಣ್ಣ, ನಿರ್ವಹಣೀಯ ತುಂಡುಗಳಾಗಿ ಅಥವಾ ಘಟನೆಗಳ ಸರಣಿಯಾಗಿ ಕಳುಹಿಸುವ ಮತ್ತು ಸ್ವೀಕರಿಸುವ ತಂತ್ರ, ಸಂಪೂರ್ಣ ಪ್ರತಿಕ್ರಿಯೆ ಸಿದ್ಧವಾಗುವವರೆಗೆ ಕಾಯದೆ. ಇದು ವಿಶೇಷವಾಗಿ ಉಪಯುಕ್ತ:

- ದೊಡ್ಡ ಫೈಲ್‌ಗಳು ಅಥವಾ ಡೇಟಾಸೆಟ್‌ಗಳು.
- ರಿಯಲ್-ಟೈಮ್ ನವೀಕರಣಗಳು (ಉದಾ: ಚಾಟ್, ಪ್ರಗತಿ ಬಾರ್‌ಗಳು).
- ದೀರ್ಘಕಾಲದ ಗಣನೆಗಳು, ಬಳಕೆದಾರರನ್ನು ಮಾಹಿತಿ ನೀಡಲು.

ಸ್ಟ್ರೀಮಿಂಗ್ ಬಗ್ಗೆ ನೀವು ತಿಳಿದುಕೊಳ್ಳಬೇಕಾದವು:

- ಡೇಟಾ ಕ್ರಮೇಣ ವಿತರಿಸಲಾಗುತ್ತದೆ, ಎಲ್ಲವನ್ನೂ ಒಟ್ಟಿಗೆ ಅಲ್ಲ.
- ಗ್ರಾಹಕ ಡೇಟಾವನ್ನು ಬಂದಂತೆ ಪ್ರಕ್ರಿಯೆ ಮಾಡಬಹುದು.
- ಅನುಭವದ ವಿಳಂಬವನ್ನು ಕಡಿಮೆ ಮಾಡುತ್ತದೆ ಮತ್ತು ಬಳಕೆದಾರ ಅನುಭವವನ್ನು ಸುಧಾರಿಸುತ್ತದೆ.

### ಸ್ಟ್ರೀಮಿಂಗ್ ಬಳಸುವ ಕಾರಣವೇನು?

ಸ್ಟ್ರೀಮಿಂಗ್ ಬಳಸುವ ಕಾರಣಗಳು ಇವು:

- ಬಳಕೆದಾರರು ತಕ್ಷಣ ಪ್ರತಿಕ್ರಿಯೆ ಪಡೆಯುತ್ತಾರೆ, ಕೊನೆಯಲ್ಲಿ ಮಾತ್ರವಲ್ಲ
- ರಿಯಲ್-ಟೈಮ್ ಅಪ್ಲಿಕೇಶನ್‌ಗಳು ಮತ್ತು ಪ್ರತಿಕ್ರಿಯಾಶೀಲ UI ಗಳನ್ನು ಸಕ್ರಿಯಗೊಳಿಸುತ್ತದೆ
- ನೆಟ್‌ವರ್ಕ್ ಮತ್ತು ಗಣನೆ ಸಂಪನ್ಮೂಲಗಳ ಹೆಚ್ಚು ಪರಿಣಾಮಕಾರಿ ಬಳಕೆ

### ಸರಳ ಉದಾಹರಣೆ: HTTP ಸ್ಟ್ರೀಮಿಂಗ್ ಸರ್ವರ್ ಮತ್ತು ಗ್ರಾಹಕ

ಸ್ಟ್ರೀಮಿಂಗ್ ಅನ್ನು ಹೇಗೆ ಅನುಷ್ಠಾನಗೊಳಿಸಬಹುದು ಎಂಬ ಸರಳ ಉದಾಹರಣೆ ಇಲ್ಲಿದೆ:

#### ಪೈಥಾನ್

**ಸರ್ವರ್ (ಪೈಥಾನ್, FastAPI ಮತ್ತು StreamingResponse ಬಳಸಿ):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**ಗ್ರಾಹಕ (ಪೈಥಾನ್, requests ಬಳಸಿ):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

ಈ ಉದಾಹರಣೆ ಸರ್ವರ್ ಎಲ್ಲಾ ಸಂದೇಶಗಳು ಸಿದ್ಧವಾಗುವವರೆಗೆ ಕಾಯದೆ, ಲಭ್ಯವಾಗುವಂತೆ ಗ್ರಾಹಕಕ್ಕೆ ಸಂದೇಶಗಳ ಸರಣಿಯನ್ನು ಕಳುಹಿಸುವುದನ್ನು ತೋರಿಸುತ್ತದೆ.

**ಹೇಗೆ ಕಾರ್ಯನಿರ್ವಹಿಸುತ್ತದೆ:**

- ಸರ್ವರ್ ಪ್ರತಿ ಸಂದೇಶವನ್ನು ಸಿದ್ಧವಾಗುತ್ತಿದ್ದಂತೆ ನೀಡುತ್ತದೆ.
- ಗ್ರಾಹಕ ಪ್ರತಿ ತುಂಡನ್ನು ಬಂದಂತೆ ಸ್ವೀಕರಿಸಿ ಮುದ್ರಿಸುತ್ತದೆ.

**ಅಗತ್ಯತೆಗಳು:**

- ಸರ್ವರ್ ಸ್ಟ್ರೀಮಿಂಗ್ ಪ್ರತಿಕ್ರಿಯೆಯನ್ನು ಬಳಸಬೇಕು (ಉದಾ: FastAPI ನಲ್ಲಿ `StreamingResponse`).
- ಗ್ರಾಹಕ ಪ್ರತಿಕ್ರಿಯೆಯನ್ನು ಸ್ಟ್ರೀಮ್ ಆಗಿ ಪ್ರಕ್ರಿಯೆ ಮಾಡಬೇಕು (`stream=True` requests ನಲ್ಲಿ).
- ವಿಷಯ ಪ್ರಕಾರ ಸಾಮಾನ್ಯವಾಗಿ `text/event-stream` ಅಥವಾ `application/octet-stream` ಆಗಿರುತ್ತದೆ.

#### ಜಾವಾ

**ಸರ್ವರ್ (ಜಾವಾ, Spring Boot ಮತ್ತು Server-Sent Events ಬಳಸಿ):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**ಗ್ರಾಹಕ (ಜಾವಾ, Spring WebFlux WebClient ಬಳಸಿ):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**ಜಾವಾ ಅನುಷ್ಠಾನ ಟಿಪ್ಪಣಿಗಳು:**

- ಸ್ಟ್ರೀಮಿಂಗ್‌ಗೆ Spring Boot ರಿಯಾಕ್ಟಿವ್ ಸ್ಟ್ಯಾಕ್ ಮತ್ತು `Flux` ಬಳಕೆ
- `ServerSentEvent` ಘಟನಾ ಪ್ರಕಾರಗಳೊಂದಿಗೆ ರಚನಾತ್ಮಕ ಘಟನೆ ಸ್ಟ್ರೀಮಿಂಗ್ ಒದಗಿಸುತ್ತದೆ
- `WebClient` ಮತ್ತು `bodyToFlux()` ರಿಯಾಕ್ಟಿವ್ ಸ್ಟ್ರೀಮಿಂಗ್ ಗ್ರಹಣಕ್ಕೆ
- `delayElements()` ಘಟನೆಗಳ ನಡುವೆ ಪ್ರಕ್ರಿಯೆ ಸಮಯವನ್ನು ಅನುಕರಿಸುತ್ತದೆ
- ಘಟನೆಗಳಿಗೆ ಉತ್ತಮ ಗ್ರಾಹಕ ನಿರ್ವಹಣೆಗೆ ಪ್ರಕಾರಗಳು (`info`, `result`) ಇರಬಹುದು

### ಹೋಲಿಕೆ: ಕ್ಲಾಸಿಕ್ ಸ್ಟ್ರೀಮಿಂಗ್ vs MCP ಸ್ಟ್ರೀಮಿಂಗ್

ಕ್ಲಾಸಿಕ್ ರೀತಿಯಲ್ಲಿ ಸ್ಟ್ರೀಮಿಂಗ್ ಹೇಗೆ ಕಾರ್ಯನಿರ್ವಹಿಸುತ್ತದೆ ಮತ್ತು MCP ನಲ್ಲಿ ಹೇಗೆ ಕಾರ್ಯನಿರ್ವಹಿಸುತ್ತದೆ ಎಂಬ ವ್ಯತ್ಯಾಸವನ್ನು ಹೀಗಾಗಿ ಚಿತ್ರಿಸಬಹುದು:

| ವೈಶಿಷ್ಟ್ಯ               | ಕ್ಲಾಸಿಕ್ HTTP ಸ್ಟ್ರೀಮಿಂಗ್       | MCP ಸ್ಟ್ರೀಮಿಂಗ್ (ಸೂಚನೆಗಳು)       |
|------------------------|-------------------------------|----------------------------------|
| ಮುಖ್ಯ ಪ್ರತಿಕ್ರಿಯೆ       | ತುಂಡುಗಳಾಗಿ                   | ಒಬ್ಬರಾಗಿ, ಕೊನೆಯಲ್ಲಿ              |
| ಪ್ರಗತಿ ನವೀಕರಣಗಳು       | ಡೇಟಾ ತುಂಡುಗಳಾಗಿ ಕಳುಹಿಸಲಾಗುತ್ತದೆ | ಸೂಚನೆಗಳಾಗಿ ಕಳುಹಿಸಲಾಗುತ್ತದೆ       |
| ಗ್ರಾಹಕ ಅಗತ್ಯಗಳು         | ಸ್ಟ್ರೀಮ್ ಪ್ರಕ್ರಿಯೆ ಮಾಡಬೇಕು     | ಸಂದೇಶ ನಿರ್ವಹಣೆಯನ್ನು ಅನುಷ್ಠಾನಗೊಳಿಸಬೇಕು |
| ಬಳಕೆ ಪ್ರಕರಣ           | ದೊಡ್ಡ ಫೈಲ್‌ಗಳು, AI ಟೋಕನ್ ಸ್ಟ್ರೀಮ್‌ಗಳು | ಪ್ರಗತಿ, ಲಾಗ್‌ಗಳು, ರಿಯಲ್-ಟೈಮ್ ಪ್ರತಿಕ್ರಿಯೆ |

### ಗಮನಿಸಿದ ಪ್ರಮುಖ ವ್ಯತ್ಯಾಸಗಳು

ಇನ್ನೂ ಕೆಲವು ಪ್ರಮುಖ ವ್ಯತ್ಯಾಸಗಳು:

- **ಸಂವಹನ ಮಾದರಿ:**
  - ಕ್ಲಾಸಿಕ್ HTTP ಸ್ಟ್ರೀಮಿಂಗ್: ಸರಳ ತುಂಡುಗಳ ವರ್ಗಾವಣೆ ಎನ್‌ಕೋಡಿಂಗ್ ಬಳಕೆ
  - MCP ಸ್ಟ್ರೀಮಿಂಗ್: JSON-RPC ಪ್ರೋಟೋಕಾಲ್ ಬಳಸಿ ರಚನಾತ್ಮಕ ಸೂಚನೆ ವ್ಯವಸ್ಥೆ

- **ಸಂದೇಶ ಸ್ವರೂಪ:**
  - ಕ್ಲಾಸಿಕ್ HTTP: ಹೊಸ ಸಾಲುಗಳೊಂದಿಗೆ ಸರಳ ಪಠ್ಯ ತುಂಡುಗಳು
  - MCP: ಮೆಟಾಡೇಟಾ ಹೊಂದಿರುವ ರಚನಾತ್ಮಕ LoggingMessageNotification ವಸ್ತುಗಳು

- **ಗ್ರಾಹಕ ಅನುಷ್ಠಾನ:**
  - ಕ್ಲಾಸಿಕ್ HTTP: ಸ್ಟ್ರೀಮಿಂಗ್ ಪ್ರತಿಕ್ರಿಯೆಗಳನ್ನು ಪ್ರಕ್ರಿಯೆ ಮಾಡುವ ಸರಳ ಗ್ರಾಹಕ
  - MCP: ವಿಭಿನ್ನ ಸಂದೇಶ ಪ್ರಕಾರಗಳನ್ನು ಪ್ರಕ್ರಿಯೆ ಮಾಡುವ ಸಂದೇಶ ನಿರ್ವಹಣೆಯೊಂದಿಗೆ ಹೆಚ್ಚು ಸುಧಾರಿತ ಗ್ರಾಹಕ

- **ಪ್ರಗತಿ ನವೀಕರಣಗಳು:**
  - ಕ್ಲಾಸಿಕ್ HTTP: ಪ್ರಗತಿ ಮುಖ್ಯ ಪ್ರತಿಕ್ರಿಯೆ ಸ್ಟ್ರೀಮ್‌ನ ಭಾಗ
  - MCP: ಪ್ರಗತಿ ಪ್ರತ್ಯೇಕ ಸೂಚನೆ ಸಂದೇಶಗಳ ಮೂಲಕ ಕಳುಹಿಸಲಾಗುತ್ತದೆ, ಮುಖ್ಯ ಪ್ರತಿಕ್ರಿಯೆ ಕೊನೆಯಲ್ಲಿ ಬರುತ್ತದೆ

### ಶಿಫಾರಸುಗಳು

ಕ್ಲಾಸಿಕ್ ಸ್ಟ್ರೀಮಿಂಗ್ (ಮೇಲಿನ `/stream` ಎಂಡ್‌ಪಾಯಿಂಟ್ ಬಳಸಿ ತೋರಿಸಿದಂತೆ) ಮತ್ತು MCP ಮೂಲಕ ಸ್ಟ್ರೀಮಿಂಗ್ ಆಯ್ಕೆ ಮಾಡುವಾಗ ಕೆಲವು ಶಿಫಾರಸುಗಳು:

- **ಸರಳ ಸ್ಟ್ರೀಮಿಂಗ್ ಅಗತ್ಯಗಳಿಗೆ:** ಕ್ಲಾಸಿಕ್ HTTP ಸ್ಟ್ರೀಮಿಂಗ್ ಅನುಷ್ಠಾನಗೊಳಿಸಲು ಸರಳ ಮತ್ತು ಮೂಲಭೂತ ಸ್ಟ್ರೀಮಿಂಗ್ ಅಗತ್ಯಗಳಿಗೆ ಸಾಕು.

- **ಸಂಕೀರ್ಣ, ಪರಸ್ಪರ ಕ್ರಿಯಾಶೀಲ ಅಪ್ಲಿಕೇಶನ್‌ಗಳಿಗೆ:** MCP ಸ್ಟ್ರೀಮಿಂಗ್ ಹೆಚ್ಚು ರಚನಾತ್ಮಕ ವಿಧಾನವನ್ನು ಒದಗಿಸುತ್ತದೆ, ಹೆಚ್ಚಿನ ಮೆಟಾಡೇಟಾ ಮತ್ತು ಸೂಚನೆಗಳು ಮತ್ತು ಅಂತಿಮ ಫಲಿತಾಂಶಗಳ ವಿಭಜನೆ.

- **AI ಅಪ್ಲಿಕೇಶನ್‌ಗಳಿಗೆ:** MCP ಸೂಚನೆ ವ್ಯವಸ್ಥೆ ದೀರ್ಘಕಾಲದ AI ಕಾರ್ಯಗಳಿಗೆ ವಿಶೇಷವಾಗಿ ಉಪಯುಕ್ತ, ಬಳಕೆದಾರರನ್ನು ಪ್ರಗತಿ ಬಗ್ಗೆ ಮಾಹಿತಿ ನೀಡಲು.

## MCP ನಲ್ಲಿ ಸ್ಟ್ರೀಮಿಂಗ್

ನೀವು ಈಗಾಗಲೇ ಕ್ಲಾಸಿಕ್ ಸ್ಟ್ರೀಮಿಂಗ್ ಮತ್ತು MCP ಸ್ಟ್ರೀಮಿಂಗ್ ನಡುವಿನ ವ್ಯತ್ಯಾಸಗಳ ಬಗ್ಗೆ ಕೆಲವು ಶಿಫಾರಸುಗಳು ಮತ್ತು ಹೋಲಿಕೆಗಳನ್ನು ನೋಡಿದ್ದೀರಿ. ಈಗ MCP ನಲ್ಲಿ ಸ್ಟ್ರೀಮಿಂಗ್ ಅನ್ನು ನೀವು ಹೇಗೆ ಬಳಸಬಹುದು ಎಂಬುದನ್ನು ವಿವರವಾಗಿ ನೋಡೋಣ.

MCP ಫ್ರೇಮ್ವರ್ಕ್ ಒಳಗೆ ಸ್ಟ್ರೀಮಿಂಗ್ ಹೇಗೆ ಕಾರ್ಯನಿರ್ವಹಿಸುತ್ತದೆ ಎಂಬುದನ್ನು ಅರ್ಥಮಾಡಿಕೊಳ್ಳುವುದು ದೀರ್ಘಕಾಲದ ಕಾರ್ಯಾಚರಣೆಗಳ ಸಮಯದಲ್ಲಿ ಬಳಕೆದಾರರಿಗೆ ರಿಯಲ್-ಟೈಮ್ ಪ್ರತಿಕ್ರಿಯೆ ನೀಡುವ ಪ್ರತಿಕ್ರಿಯಾಶೀಲ ಅಪ್ಲಿಕೇಶನ್‌ಗಳನ್ನು ನಿರ್ಮಿಸಲು ಅಗತ್ಯ.

MCP ನಲ್ಲಿ, ಮುಖ್ಯ ಪ್ರತಿಕ್ರಿಯೆಯನ್ನು ತುಂಡುಗಳಾಗಿ ಕಳುಹಿಸುವುದಲ್ಲ, ಆದರೆ ಟೂಲ್ ವಿನಂತಿಯನ್ನು ಪ್ರಕ್ರಿಯೆ ಮಾಡುತ್ತಿರುವಾಗ ಗ್ರಾಹಕಿಗೆ **ಸೂಚನೆಗಳು** ಕಳುಹಿಸುವುದಾಗಿದೆ. ಈ ಸೂಚನೆಗಳಲ್ಲಿ ಪ್ರಗತಿ ನವೀಕರಣಗಳು, ಲಾಗ್‌ಗಳು ಅಥವಾ ಇತರ ಘಟನೆಗಳು ಇರಬಹುದು.

### ಹೇಗೆ ಕಾರ್ಯನಿರ್ವಹಿಸುತ್ತದೆ

ಮುಖ್ಯ ಫಲಿತಾಂಶವನ್ನು ಇನ್ನೂ ಒಬ್ಬರಾಗಿ ಕಳುಹಿಸಲಾಗುತ್ತದೆ. ಆದರೆ, ಪ್ರಕ್ರಿಯೆ ಸಮಯದಲ್ಲಿ ಪ್ರತ್ಯೇಕ ಸಂದೇಶಗಳಾಗಿ ಸೂಚನೆಗಳನ್ನು ಕಳುಹಿಸಿ ಗ್ರಾಹಕನನ್ನು ರಿಯಲ್-ಟೈಮ್‌ನಲ್ಲಿ ನವೀಕರಿಸಲಾಗುತ್ತದೆ. ಗ್ರಾಹಕ ಈ ಸೂಚನೆಗಳನ್ನು ನಿರ್ವಹಿಸಿ ಪ್ರದರ್ಶಿಸಲು ಸಾಧ್ಯವಾಗಬೇಕು.

## ಸೂಚನೆ ಎಂದರೆ ಏನು?

ನಾವು "ಸೂಚನೆ" ಎಂದು ಹೇಳಿದ್ದೇವೆ, MCP ಸಾಂದರ್ಭಿಕದಲ್ಲಿ ಅದರಿಂದ ಅರ್ಥವೇನು?

ಸೂಚನೆ ಎಂದರೆ ದೀರ್ಘಕಾಲದ ಕಾರ್ಯಾಚರಣೆ ಸಮಯದಲ್ಲಿ ಪ್ರಗತಿ, ಸ್ಥಿತಿ ಅಥವಾ ಇತರ ಘಟನೆಗಳ ಬಗ್ಗೆ ಮಾಹಿತಿ ನೀಡಲು ಸರ್ವರ್‌ನಿಂದ ಗ್ರಾಹಕಿಗೆ ಕಳುಹಿಸುವ ಸಂದೇಶ. ಸೂಚನೆಗಳು ಪಾರದರ್ಶಕತೆ ಮತ್ತು ಬಳಕೆದಾರ ಅನುಭವವನ್ನು ಸುಧಾರಿಸುತ್ತವೆ.

ಉದಾಹರಣೆಗೆ, ಗ್ರಾಹಕ ಸರ್ವರ್ ಜೊತೆಗೆ ಪ್ರಾಥಮಿಕ ಹ್ಯಾಂಡ್‌ಶೇಕ್ ಮಾಡಿದ ನಂತರ ಒಂದು ಸೂಚನೆ ಕಳುಹಿಸಬೇಕು.

ಸೂಚನೆ JSON ಸಂದೇಶದಂತೆ ಕಾಣುತ್ತದೆ:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

ಸೂಚನೆಗಳು MCP ನಲ್ಲಿ ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) ಎಂಬ ವಿಷಯಕ್ಕೆ ಸೇರಿವೆ.

ಲಾಗಿಂಗ್ ಕಾರ್ಯನಿರ್ವಹಿಸಲು, ಸರ್ವರ್ ಇದನ್ನು ವೈಶಿಷ್ಟ್ಯ/ಸಾಮರ್ಥ್ಯವಾಗಿ ಸಕ್ರಿಯಗೊಳಿಸಬೇಕು:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> ಬಳಸುವ SDK ಮೇಲೆ ಅವಲಂಬಿಸಿ, ಲಾಗಿಂಗ್ ಡೀಫಾಲ್ಟ್ ಆಗಿ ಸಕ್ರಿಯವಾಗಿರಬಹುದು ಅಥವಾ ನೀವು ಸರ್ವರ್ ಸಂರಚನೆಯಲ್ಲಿ ಅದನ್ನು ಸ್ಪಷ್ಟವಾಗಿ ಸಕ್ರಿಯಗೊಳಿಸಬೇಕಾಗಬಹುದು.

ವಿವಿಧ ರೀತಿಯ ಸೂಚನೆಗಳಿವೆ:

| ಮಟ್ಟ       | ವಿವರಣೆ                      | ಉದಾಹರಣೆ ಬಳಕೆ ಪ್ರಕರಣ          |
|-----------|-----------------------------|-------------------------------|
| debug     | ವಿವರವಾದ ಡಿಬಗಿಂಗ್ ಮಾಹಿತಿ    | ಫಂಕ್ಷನ್ ಪ್ರವೇಶ/ನಿರ್ಗಮನ ಬಿಂದುಗಳು |
| info      | ಸಾಮಾನ್ಯ ಮಾಹಿತಿ ಸಂದೇಶಗಳು    | ಕಾರ್ಯಾಚರಣೆ ಪ್ರಗತಿ ನವೀಕರಣಗಳು  |
| notice    | ಸಾಮಾನ್ಯ ಆದರೆ ಪ್ರಮುಖ ಘಟನೆಗಳು | ಸಂರಚನಾ ಬದಲಾವಣೆಗಳು           |
| warning   | ಎಚ್ಚರಿಕೆ ಪರಿಸ್ಥಿತಿಗಳು       | ಹಳೆಯ ವೈಶಿಷ್ಟ್ಯ ಬಳಕೆ          |
| error     | ದೋಷ ಪರಿಸ್ಥಿತಿಗಳು           | ಕಾರ್ಯಾಚರಣೆ ವಿಫಲತೆಗಳು        |
| critical  | ಗಂಭೀರ ಪರಿಸ್ಥಿತಿಗಳು         | ವ್ಯವಸ್ಥೆ ಘಟಕ ವಿಫಲತೆಗಳು       |
| alert     | ತಕ್ಷಣ ಕ್ರಮ ಕೈಗೊಳ್ಳಬೇಕು      | ಡೇಟಾ ಹಾನಿ ಪತ್ತೆ               |
| emergency | ವ್ಯವಸ್ಥೆ ಬಳಕೆಗೆ ಅಸಾಧ್ಯ       | ಸಂಪೂರ್ಣ ವ್ಯವಸ್ಥೆ ವಿಫಲತೆ       |

## MCP ನಲ್ಲಿ ಸೂಚನೆಗಳನ್ನು ಅನುಷ್ಠಾನಗೊಳಿಸುವುದು

MCP ನಲ್ಲಿ ಸೂಚನೆಗಳನ್ನು ಅನುಷ್ಠಾನಗೊಳಿಸಲು, ನೀವು ಸರ್ವರ್ ಮತ್ತು ಗ್ರಾಹಕ ಎರಡೂ ಬದಿಗಳನ್ನು ರಿಯಲ್-ಟೈಮ್ ನವೀಕರಣಗಳನ್ನು ನಿರ್ವಹಿಸಲು ಸಿದ್ಧಪಡಿಸಬೇಕು. ಇದು ದೀರ್ಘಕಾಲದ ಕಾರ್ಯಾಚರಣೆಗಳ ಸಮಯದಲ್ಲಿ ಬಳಕೆದಾರರಿಗೆ ತಕ್ಷಣ ಪ್ರತಿಕ್ರಿಯೆ ನೀಡಲು ನಿಮ್ಮ ಅಪ್ಲಿಕೇಶನ್‌ಗೆ ಅವಕಾಶ ನೀಡುತ್ತದೆ.

### ಸರ್ವರ್-ಬದಿ: ಸೂಚನೆಗಳನ್ನು ಕಳುಹಿಸುವುದು

ಸರ್ವರ್ ಬದಿಯಿಂದ ಪ್ರಾರಂಭಿಸೋಣ. MCP ನಲ್ಲಿ, ನೀವು ವಿನಂತಿಗಳನ್ನು ಪ್ರಕ್ರಿಯೆ ಮಾಡುವಾಗ ಸೂಚನೆಗಳನ್ನು ಕಳುಹಿಸಬಹುದಾದ ಟೂಲ್‌ಗಳನ್ನು ವ್ಯಾಖ್ಯಾನಿಸುತ್ತೀರಿ. ಸರ್ವರ್ ಗ್ರಾಹಕಿಗೆ ಸಂದೇಶಗಳನ್ನು ಕಳುಹಿಸಲು ಸಾಮಾನ್ಯವಾಗಿ `ctx` ಎಂಬ ಸಾಂದರ್ಭಿಕ ವಸ್ತುವನ್ನು ಬಳಸುತ್ತದೆ.

#### ಪೈಥಾನ್

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

ಮೇಲಿನ ಉದಾಹರಣೆಯಲ್ಲಿ, `process_files` ಟೂಲ್ ಪ್ರತಿ ಫೈಲ್ ಪ್ರಕ್ರಿಯೆ ಮಾಡುವಾಗ ಗ್ರಾಹಕಿಗೆ ಮೂರು ಸೂಚನೆಗಳನ್ನು ಕಳುಹಿಸುತ್ತದೆ. `ctx.info()` ವಿಧಾನವು ಮಾಹಿತಿ ಸಂದೇಶಗಳನ್ನು ಕಳುಹಿಸಲು ಬಳಸಲಾಗುತ್ತದೆ.

ಇನ್ನೂ, ಸೂಚನೆಗಳನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಲು, ನಿಮ್ಮ ಸರ್ವರ್ ಸ್ಟ್ರೀಮಿಂಗ್ ಸಾರಿಗೆ (ಉದಾ: `streamable-http`) ಬಳಸಬೇಕು ಮತ್ತು ನಿಮ್ಮ ಗ್ರಾಹಕ ಸೂಚನೆಗಳನ್ನು ಪ್ರಕ್ರಿಯೆ ಮಾಡಲು ಸಂದೇಶ ನಿರ್ವಹಣೆಯನ್ನು ಅನುಷ್ಠಾನಗೊಳಿಸಬೇಕು. ಸರ್ವರ್ ಅನ್ನು `streamable-http` ಸಾರಿಗೆ ಬಳಸಲು ಹೇಗೆ ಸಿದ್ಧಪಡಿಸಬಹುದು ಎಂಬುದನ್ನು ಇಲ್ಲಿ ನೋಡಿ:

```python
mcp.run(transport="streamable-http")
```

#### .NET

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

ಈ .NET ಉದಾಹರಣೆಯಲ್ಲಿ, `ProcessFiles` ಟೂಲ್ `Tool` ಅಟ್ರಿಬ್ಯೂಟ್‌ನೊಂದಿಗೆ ಅಲಂಕರಿಸಲಾಗಿದೆ ಮತ್ತು ಪ್ರತಿ ಫೈಲ್ ಪ್ರಕ್ರಿಯೆ ಮಾಡುವಾಗ ಗ್ರಾಹಕಿಗೆ ಮೂರು ಸೂಚನೆಗಳನ್ನು ಕಳುಹಿಸುತ್ತದೆ. `ctx.Info()` ವಿಧಾನವು ಮಾಹಿತಿ ಸಂದೇಶಗಳನ್ನು ಕಳುಹಿಸಲು ಬಳಸಲಾಗುತ್ತದೆ.

ನಿಮ್ಮ .NET MCP ಸರ್ವರ್‌ನಲ್ಲಿ ಸೂಚನೆಗಳನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಲು, ಸ್ಟ್ರೀಮಿಂಗ್ ಸಾರಿಗೆ ಬಳಸುತ್ತಿರುವುದನ್ನು ಖಚಿತಪಡಿಸಿಕೊಳ್ಳಿ:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

### ಗ್ರಾಹಕ-ಬದಿ: ಸೂಚನೆಗಳನ್ನು ಸ್ವೀಕರಿಸುವುದು

ಗ್ರಾಹಕ ಸೂಚನೆಗಳನ್ನು ಬಂದಂತೆ ಪ್ರಕ್ರಿಯೆ ಮಾಡಿ ಪ್ರದರ್ಶಿಸಲು ಸಂದೇಶ ನಿರ್ವಹಣೆಯನ್ನು ಅನುಷ್ಠಾನಗೊಳಿಸಬೇಕು.

#### ಪೈಥಾನ್

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

ಮೇಲಿನ ಕೋಡ್‌ನಲ್ಲಿ, `message_handler` ಫಂಕ್ಷನ್ ಬಂದಿರುವ ಸಂದೇಶವು ಸೂಚನೆ ಆಗಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸುತ್ತದೆ. ಆಗಿದ್ದರೆ, ಅದು ಸೂಚನೆಯನ್ನು ಮುದ್ರಿಸುತ್ತದೆ; ಇಲ್ಲದಿದ್ದರೆ, ಸಾಮಾನ್ಯ ಸರ್ವರ್ ಸಂದೇಶವಾಗಿ ಪ್ರಕ್ರಿಯೆ ಮಾಡುತ್ತದೆ. ಜೊತೆಗೆ, `ClientSession` ಅನ್ನು `message_handler` ಜೊತೆಗೆ ಪ್ರಾರಂಭಿಸಲಾಗುತ್ತದೆ, ಇದು ಬಂದಿರುವ ಸೂಚನೆಗಳನ್ನು ನಿರ್ವಹಿಸಲು.

#### .NET

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

ಈ .NET ಉದಾಹರಣೆಯಲ್ಲಿ, `MessageHandler` ಫಂಕ್ಷನ್ ಬಂದಿರುವ ಸಂದೇಶವು ಸೂಚನೆ ಆಗಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸುತ್ತದೆ. ಆಗಿದ್ದರೆ, ಅದು ಸೂಚನೆಯನ್ನು ಮುದ್ರಿಸುತ್ತದೆ; ಇಲ್ಲದಿದ್ದರೆ, ಸಾಮಾನ್ಯ ಸರ್ವರ್ ಸಂದೇಶವಾಗಿ ಪ್ರಕ್ರಿಯೆ ಮಾಡುತ್ತದೆ. `ClientSession` ಅನ್ನು `ClientSessionOptions` ಮೂಲಕ ಸಂದೇಶ ನಿರ್ವಹಣೆಯೊಂದಿಗೆ ಪ್ರಾರಂಭಿಸಲಾಗುತ್ತದೆ.

ಸೂಚನೆಗಳನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಲು, ನಿಮ್ಮ ಸರ್ವರ್ ಸ್ಟ್ರೀಮಿಂಗ್ ಸಾರಿಗೆ (ಉದಾ: `streamable-http`) ಬಳಸುತ್ತಿರುವುದು ಮತ್ತು ನಿಮ್ಮ ಗ್ರಾಹಕ ಸೂಚನೆಗಳನ್ನು ಪ್ರಕ್ರಿಯೆ ಮಾಡಲು ಸಂದೇಶ ನಿರ್ವಹಣೆಯನ್ನು ಅನುಷ್ಠಾನಗೊಳಿಸಿರುವುದು ಖಚಿತಪಡಿಸಿಕೊಳ್ಳಿ.

## ಪ್ರಗತಿ ಸೂಚನೆಗಳು ಮತ್ತು ಸಂದರ್ಭಗಳು

ಈ ವಿಭಾಗವು MCP ನಲ್ಲಿ ಪ್ರಗತಿ ಸೂಚನೆಗಳ ತತ್ವ, ಅವುಗಳ ಮಹತ್ವ ಮತ್ತು Streamable HTTP ಬಳಸಿ ಅವುಗಳನ್ನು ಹೇಗೆ ಅನುಷ್ಠಾನಗೊಳ
## SSE ನಿಂದ Streamable HTTP ಗೆ ಅಪ್‌ಗ್ರೇಡ್ ಮಾಡುವುದು

ಪ್ರಸ್ತುತ Server-Sent Events (SSE) ಬಳಸುತ್ತಿರುವ ಅಪ್ಲಿಕೇಶನ್‌ಗಳಿಗೆ, Streamable HTTP ಗೆ ಮೈಸಿಗ್ರೇಟ್ ಮಾಡುವುದು ನಿಮ್ಮ MCP ಅನುಷ್ಠಾನಗಳಿಗೆ ಸುಧಾರಿತ ಸಾಮರ್ಥ್ಯಗಳು ಮತ್ತು ಉತ್ತಮ ದೀರ್ಘಕಾಲಿಕ ಸ್ಥಿರತೆಯನ್ನು ಒದಗಿಸುತ್ತದೆ.

### ಏಕೆ ಅಪ್‌ಗ್ರೇಡ್ ಮಾಡಬೇಕು?

SSE ನಿಂದ Streamable HTTP ಗೆ ಅಪ್‌ಗ್ರೇಡ್ ಮಾಡಲು ಎರಡು ಪ್ರಮುಖ ಕಾರಣಗಳಿವೆ:

- Streamable HTTP SSE ಗಿಂತ ಉತ್ತಮ ಸ್ಕೇಲಬಿಲಿಟಿ, ಹೊಂದಾಣಿಕೆ ಮತ್ತು ಸಮೃದ್ಧ ನೋಟಿಫಿಕೇಶನ್ ಬೆಂಬಲವನ್ನು ನೀಡುತ್ತದೆ.
- ಇದು ಹೊಸ MCP ಅಪ್ಲಿಕೇಶನ್‌ಗಳಿಗೆ ಶಿಫಾರಸು ಮಾಡಲಾದ ಸಾರಿಗೆ ವಿಧಾನವಾಗಿದೆ.

### ಮೈಸಿಗ್ರೇಶನ್ ಹಂತಗಳು

ನಿಮ್ಮ MCP ಅಪ್ಲಿಕೇಶನ್‌ಗಳಲ್ಲಿ SSE ನಿಂದ Streamable HTTP ಗೆ ಮೈಸಿಗ್ರೇಟ್ ಮಾಡುವ ವಿಧಾನ ಇಲ್ಲಿದೆ:

- **ಸರ್ವರ್ ಕೋಡ್ ಅನ್ನು ನವೀಕರಿಸಿ** `mcp.run()` ನಲ್ಲಿ `transport="streamable-http"` ಬಳಸಲು.
- **ಕ್ಲೈಂಟ್ ಕೋಡ್ ಅನ್ನು ನವೀಕರಿಸಿ** SSE ಕ್ಲೈಂಟ್ ಬದಲು `streamablehttp_client` ಬಳಸಲು.
- **ಕ್ಲೈಂಟ್‌ನಲ್ಲಿ ಸಂದೇಶ ಹ್ಯಾಂಡ್ಲರ್ ಅನ್ನು ಜಾರಿಗೆ ತರುವಿರಿ** ನೋಟಿಫಿಕೇಶನ್‌ಗಳನ್ನು ಪ್ರಕ್ರಿಯೆಗೊಳಿಸಲು.
- **ಹೊಂದಾಣಿಕೆಗೆ ಪರೀಕ್ಷೆ ಮಾಡಿ** ಇತ್ತೀಚಿನ ಉಪಕರಣಗಳು ಮತ್ತು ಕಾರ್ಯಪ್ರವಾಹಗಳೊಂದಿಗೆ.

### ಹೊಂದಾಣಿಕೆ ಕಾಪಾಡುವುದು

ಮೈಸಿಗ್ರೇಶನ್ ಪ್ರಕ್ರಿಯೆಯಲ್ಲಿ ಇತ್ತೀಚಿನ SSE ಕ್ಲೈಂಟ್‌ಗಳೊಂದಿಗೆ ಹೊಂದಾಣಿಕೆಯನ್ನು ಕಾಪಾಡುವುದು ಶಿಫಾರಸು ಮಾಡಲಾಗಿದೆ. ಕೆಲವು ತಂತ್ರಗಳು ಇಲ್ಲಿವೆ:

- ನೀವು SSE ಮತ್ತು Streamable HTTP ಎರಡನ್ನೂ ಬೆಂಬಲಿಸಲು ವಿಭಿನ್ನ ಎಂಡ್‌ಪಾಯಿಂಟ್‌ಗಳಲ್ಲಿ ಎರಡೂ ಸಾರಿಗೆಗಳನ್ನು ಓಡಿಸಬಹುದು.
- ಗ್ರಾಜುಯಲಿ ಕ್ಲೈಂಟ್‌ಗಳನ್ನು ಹೊಸ ಸಾರಿಗೆಗೆ ಮೈಸಿಗ್ರೇಟ್ ಮಾಡಬಹುದು.

### ಸವಾಲುಗಳು

ಮೈಸಿಗ್ರೇಶನ್ ವೇಳೆ ಈ ಕೆಳಗಿನ ಸವಾಲುಗಳನ್ನು ಪರಿಹರಿಸಬೇಕು:

- ಎಲ್ಲಾ ಕ್ಲೈಂಟ್‌ಗಳು ನವೀಕರಿಸಲ್ಪಟ್ಟಿರುವುದನ್ನು ಖಚಿತಪಡಿಸುವುದು
- ನೋಟಿಫಿಕೇಶನ್ ವಿತರಣೆಯಲ್ಲಿ ವ್ಯತ್ಯಾಸಗಳನ್ನು ನಿರ್ವಹಿಸುವುದು

## ಭದ್ರತಾ ಪರಿಗಣನೆಗಳು

ಯಾವುದೇ ಸರ್ವರ್ ಅನ್ನು ಜಾರಿಗೆ ತರುವಾಗ, ವಿಶೇಷವಾಗಿ MCP ನಲ್ಲಿ Streamable HTTP ಮುಂತಾದ HTTP ಆಧಾರಿತ ಸಾರಿಗೆಗಳನ್ನು ಬಳಸುವಾಗ ಭದ್ರತೆ ಅತ್ಯಂತ ಮುಖ್ಯವಾಗಿದೆ.

HTTP ಆಧಾರಿತ ಸಾರಿಗೆಗಳೊಂದಿಗೆ MCP ಸರ್ವರ್‌ಗಳನ್ನು ಜಾರಿಗೆ ತರುವಾಗ, ಭದ್ರತೆ ಬಹುಮುಖ ದಾಳಿಗಳಿಂದ ಮತ್ತು ರಕ್ಷಣಾ ಯಂತ್ರಾಂಗಗಳಿಂದ ಜಾಗರೂಕತೆಯನ್ನು ಅಗತ್ಯವಿದೆ.

### ಅವಲೋಕನ

MCP ಸರ್ವರ್‌ಗಳನ್ನು HTTP ಮೂಲಕ ಬಹಿರಂಗಪಡಿಸುವಾಗ ಭದ್ರತೆ ಅತ್ಯಂತ ಮುಖ್ಯ. Streamable HTTP ಹೊಸ ದಾಳಿ ಮೇಲ್ಮೈಗಳನ್ನು ಪರಿಚಯಿಸುತ್ತದೆ ಮತ್ತು ಜಾಗರೂಕ ಸಂರಚನೆಯನ್ನು ಅಗತ್ಯವಿದೆ.

ಮುಖ್ಯ ಭದ್ರತಾ ಪರಿಗಣನೆಗಳು:

- **Origin Header ಮಾನ್ಯತೆ**: DNS ರಿಬೈಂಡಿಂಗ್ ದಾಳಿಗಳನ್ನು ತಡೆಯಲು `Origin` ಹೆಡರ್ ಅನ್ನು ಸದಾ ಪರಿಶೀಲಿಸಿ.
- **Localhost ಬಾಂಧವ್ಯ**: ಸ್ಥಳೀಯ ಅಭಿವೃದ್ಧಿಗಾಗಿ ಸರ್ವರ್‌ಗಳನ್ನು `localhost` ಗೆ ಬಾಂಧಿಸಿ, ಸಾರ್ವಜನಿಕ ಇಂಟರ್ನೆಟ್‌ಗೆ ಬಹಿರಂಗಪಡಿಸುವುದನ್ನು ತಪ್ಪಿಸಿ.
- **ಪ್ರಮಾಣೀಕರಣ**: ಉತ್ಪಾದನಾ ನಿಯೋಜನೆಗಳಿಗೆ ಪ್ರಮಾಣೀಕರಣ (ಉದಾ: API ಕೀಗಳು, OAuth) ಜಾರಿಗೆ ತರುವಿರಿ.
- **CORS**: ಪ್ರವೇಶವನ್ನು ನಿಯಂತ್ರಿಸಲು ಕ್ರಾಸ್-ಓರಿಜಿನ್ ರಿಸೋರ್ಸ್ ಶೇರ್ (CORS) ನೀತಿಗಳನ್ನು ಸಂರಚಿಸಿ.
- **HTTPS**: ಟ್ರಾಫಿಕ್ ಎನ್‌ಕ್ರಿಪ್ಟ್ ಮಾಡಲು ಉತ್ಪಾದನೆಯಲ್ಲಿ HTTPS ಬಳಸಿ.

### ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

ನಿಮ್ಮ MCP ಸ್ಟ್ರೀಮಿಂಗ್ ಸರ್ವರ್‌ನಲ್ಲಿ ಭದ್ರತೆಯನ್ನು ಜಾರಿಗೆ ತರುವಾಗ ಈ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳನ್ನು ಅನುಸರಿಸಿ:

- ಮಾನ್ಯತೆ ಇಲ್ಲದೆ ಬರುವ ವಿನಂತಿಗಳನ್ನು ಎಂದಿಗೂ ನಂಬಬೇಡಿ.
- ಎಲ್ಲಾ ಪ್ರವೇಶ ಮತ್ತು ದೋಷಗಳನ್ನು ಲಾಗ್ ಮಾಡಿ ಮತ್ತು ಮೇಲ್ವಿಚಾರಣೆ ಮಾಡಿ.
- ಭದ್ರತಾ ದುರ್ಬಲತೆಗಳನ್ನು ಪ್ಯಾಚ್ ಮಾಡಲು ನಿಯಮಿತವಾಗಿ ಅವಲಂಬನೆಗಳನ್ನು ನವೀಕರಿಸಿ.

### ಸವಾಲುಗಳು

MCP ಸ್ಟ್ರೀಮಿಂಗ್ ಸರ್ವರ್‌ಗಳಲ್ಲಿ ಭದ್ರತೆಯನ್ನು ಜಾರಿಗೆ ತರುವಾಗ ನೀವು ಎದುರಿಸುವ ಕೆಲವು ಸವಾಲುಗಳು:

- ಅಭಿವೃದ್ಧಿಯ ಸುಲಭತೆಯೊಂದಿಗೆ ಭದ್ರತೆಯನ್ನು ಸಮತೋಲಗೊಳಿಸುವುದು
- ವಿವಿಧ ಕ್ಲೈಂಟ್ ಪರಿಸರಗಳೊಂದಿಗೆ ಹೊಂದಾಣಿಕೆಯನ್ನು ಖಚಿತಪಡಿಸುವುದು

### ಕಾರ್ಯ: ನಿಮ್ಮದೇ ಸ್ಟ್ರೀಮಿಂಗ್ MCP ಅಪ್ಲಿಕೇಶನ್ ನಿರ್ಮಿಸಿ

**ದೃಶ್ಯಾವಳಿ:**
ಸರ್ವರ್ ಒಂದು ಐಟಂಗಳ ಪಟ್ಟಿಯನ್ನು (ಉದಾ: ಫೈಲ್‌ಗಳು ಅಥವಾ ಡಾಕ್ಯುಮೆಂಟ್‌ಗಳು) ಪ್ರಕ್ರಿಯೆಗೊಳಿಸಿ ಪ್ರತಿ ಐಟಂಗೆ ನೋಟಿಫಿಕೇಶನ್ ಕಳುಹಿಸುವ MCP ಸರ್ವರ್ ಮತ್ತು ಕ್ಲೈಂಟ್ ಅನ್ನು ನಿರ್ಮಿಸಿ. ಕ್ಲೈಂಟ್ ಪ್ರತಿ ನೋಟಿಫಿಕೇಶನ್ ಬಂದಂತೆ ಪ್ರದರ್ಶಿಸಬೇಕು.

**ಹಂತಗಳು:**

1. ಐಟಂಗಳ ಪಟ್ಟಿಯನ್ನು ಪ್ರಕ್ರಿಯೆಗೊಳಿಸಿ ಪ್ರತಿ ಐಟಂಗೆ ನೋಟಿಫಿಕೇಶನ್ ಕಳುಹಿಸುವ ಸರ್ವರ್ ಉಪಕರಣವನ್ನು ಜಾರಿಗೆ ತರುವಿರಿ.
2. ನೋಟಿಫಿಕೇಶನ್‌ಗಳನ್ನು ರಿಯಲ್ ಟೈಮ್‌ನಲ್ಲಿ ಪ್ರದರ್ಶಿಸಲು ಸಂದೇಶ ಹ್ಯಾಂಡ್ಲರ್ ಹೊಂದಿರುವ ಕ್ಲೈಂಟ್ ಅನ್ನು ಜಾರಿಗೆ ತರುವಿರಿ.
3. ಸರ್ವರ್ ಮತ್ತು ಕ್ಲೈಂಟ್ ಎರಡನ್ನೂ ಓಡಿಸಿ ನಿಮ್ಮ ಜಾರಿಗೆ ಪರೀಕ್ಷೆ ಮಾಡಿ ಮತ್ತು ನೋಟಿಫಿಕೇಶನ್‌ಗಳನ್ನು ಗಮನಿಸಿ.

[Solution](./solution/README.md)

## ಮುಂದಿನ ಓದು ಮತ್ತು ಮುಂದೇನು?

MCP ಸ್ಟ್ರೀಮಿಂಗ್‌ನಲ್ಲಿ ನಿಮ್ಮ ಪ್ರಯಾಣವನ್ನು ಮುಂದುವರೆಸಲು ಮತ್ತು ನಿಮ್ಮ ಜ್ಞಾನವನ್ನು ವಿಸ್ತರಿಸಲು, ಈ ವಿಭಾಗವು ಹೆಚ್ಚುವರಿ ಸಂಪನ್ಮೂಲಗಳು ಮತ್ತು ಹೆಚ್ಚು ಪ್ರಗತಿಶೀಲ ಅಪ್ಲಿಕೇಶನ್‌ಗಳನ್ನು ನಿರ್ಮಿಸಲು ಶಿಫಾರಸು ಮಾಡಿದ ಮುಂದಿನ ಹಂತಗಳನ್ನು ಒದಗಿಸುತ್ತದೆ.

### ಮುಂದಿನ ಓದು

- [Microsoft: HTTP ಸ್ಟ್ರೀಮಿಂಗ್ ಪರಿಚಯ](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: ASP.NET Core ನಲ್ಲಿ CORS](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: ಸ್ಟ್ರೀಮಿಂಗ್ ವಿನಂತಿಗಳು](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### ಮುಂದೇನು?

- ರಿಯಲ್-ಟೈಮ್ ವಿಶ್ಲೇಷಣೆ, ಚಾಟ್ ಅಥವಾ ಸಹಕಾರ ಸಂಪಾದನೆಗಾಗಿ ಸ್ಟ್ರೀಮಿಂಗ್ ಬಳಸುವ ಹೆಚ್ಚು ಪ್ರಗತಿಶೀಲ MCP ಉಪಕರಣಗಳನ್ನು ನಿರ್ಮಿಸಲು ಪ್ರಯತ್ನಿಸಿ.
- ಲೈವ್ UI ನವೀಕರಣಗಳಿಗಾಗಿ MCP ಸ್ಟ್ರೀಮಿಂಗ್ ಅನ್ನು ಫ್ರಂಟ್‌ಎಂಡ್ ಫ್ರೇಮ್ವರ್ಕ್‌ಗಳೊಂದಿಗೆ (React, Vue, ಇತ್ಯಾದಿ) ಸಂಯೋಜಿಸುವುದನ್ನು ಅನ್ವೇಷಿಸಿ.
- ಮುಂದಿನ ಅಧ್ಯಾಯ: [VSCode ಗಾಗಿ AI ಟೂಲ್‌ಕಿಟ್ ಬಳಕೆ](../07-aitk/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**ಅಸ್ವೀಕರಣ**:  
ಈ ದಸ್ತಾವೇಜು AI ಅನುವಾದ ಸೇವೆ [Co-op Translator](https://github.com/Azure/co-op-translator) ಬಳಸಿ ಅನುವಾದಿಸಲಾಗಿದೆ. ನಾವು ನಿಖರತೆಯಿಗಾಗಿ ಪ್ರಯತ್ನಿಸುತ್ತಿದ್ದರೂ, ಸ್ವಯಂಚಾಲಿತ ಅನುವಾದಗಳಲ್ಲಿ ತಪ್ಪುಗಳು ಅಥವಾ ಅಸತ್ಯತೆಗಳು ಇರಬಹುದು ಎಂದು ದಯವಿಟ್ಟು ಗಮನಿಸಿ. ಮೂಲ ಭಾಷೆಯಲ್ಲಿರುವ ಮೂಲ ದಸ್ತಾವೇಜನ್ನು ಅಧಿಕೃತ ಮೂಲವೆಂದು ಪರಿಗಣಿಸಬೇಕು. ಪ್ರಮುಖ ಮಾಹಿತಿಗಾಗಿ, ವೃತ್ತಿಪರ ಮಾನವ ಅನುವಾದವನ್ನು ಶಿಫಾರಸು ಮಾಡಲಾಗುತ್ತದೆ. ಈ ಅನುವಾದ ಬಳಕೆಯಿಂದ ಉಂಟಾಗುವ ಯಾವುದೇ ತಪ್ಪು ಅರ್ಥಮಾಡಿಕೊಳ್ಳುವಿಕೆ ಅಥವಾ ತಪ್ಪು ವಿವರಣೆಗಳಿಗೆ ನಾವು ಹೊಣೆಗಾರರಾಗುವುದಿಲ್ಲ.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->