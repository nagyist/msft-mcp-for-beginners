<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "193889b580c86bbb1e4f577114a5ce4e",
  "translation_date": "2025-12-11T15:37:42+00:00",
  "source_file": "05-AdvancedTopics/mcp-sampling/README.md",
  "language_code": "kn"
}
-->
# ಮಾದರಿ ಸಂಧರ್ಭ ಪ್ರೋಟೋಕಾಲ್‌ನಲ್ಲಿ ಸ್ಯಾಂಪ್ಲಿಂಗ್

ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಒಂದು ಶಕ್ತಿಶಾಲಿ MCP ವೈಶಿಷ್ಟ್ಯವಾಗಿದ್ದು, ಸರ್ವರ್‌ಗಳಿಗೆ ಕ್ಲೈಂಟ್ ಮೂಲಕ LLM ಪೂರ್ಣಗೊಳಿಸುವಿಕೆಗಳನ್ನು ವಿನಂತಿಸಲು ಅನುಮತಿಸುತ್ತದೆ, ಇದು ಸುರಕ್ಷತೆ ಮತ್ತು ಗೌಪ್ಯತೆಯನ್ನು ಕಾಪಾಡಿಕೊಂಡು ಸುಕ್ಷ್ಮ ಏಜೆಂಟಿಕ್ ವರ್ತನೆಗಳನ್ನು ಸಾಧ್ಯಮಾಡುತ್ತದೆ. ಸರಿಯಾದ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಸಂರಚನೆ ಪ್ರತಿಕ್ರಿಯೆಯ ಗುಣಮಟ್ಟ ಮತ್ತು ಕಾರ್ಯಕ್ಷಮತೆಯನ್ನು ನಾಟಕವಾಗಿ ಸುಧಾರಿಸಬಹುದು. MCP ಮಾದರಿಗಳು ಪಠ್ಯವನ್ನು ರಚಿಸುವ ವಿಧಾನವನ್ನು ನಿಯಂತ್ರಿಸಲು ಮಾನದಂಡಿತ ಮಾರ್ಗವನ್ನು ಒದಗಿಸುತ್ತದೆ, ಇದು ಯಾದೃಚ್ಛಿಕತೆ, ಸೃಜನಶೀಲತೆ ಮತ್ತು ಸಮ್ಮಿಲನವನ್ನು ಪ್ರಭಾವಿತ ಮಾಡುವ ನಿರ್ದಿಷ್ಟ ಪರಿಮಾಣಗಳನ್ನು ಹೊಂದಿದೆ.

## ಪರಿಚಯ

ಈ ಪಾಠದಲ್ಲಿ, ನಾವು MCP ವಿನಂತಿಗಳಲ್ಲಿ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳನ್ನು ಹೇಗೆ ಸಂರಚಿಸುವುದು ಮತ್ತು ಸ್ಯಾಂಪ್ಲಿಂಗ್‌ನ ಅಡಿಗಲ್ಲು ಪ್ರೋಟೋಕಾಲ್ ಯಂತ್ರಶಾಸ್ತ್ರವನ್ನು ಅರ್ಥಮಾಡಿಕೊಳ್ಳುವುದನ್ನು ಅನ್ವೇಷಿಸುವೆವು.

## ಕಲಿಕೆಯ ಉದ್ದೇಶಗಳು

ಈ ಪಾಠದ ಅಂತ್ಯಕ್ಕೆ, ನೀವು ಸಾಧ್ಯವಾಗುವುದು:

- MCP ನಲ್ಲಿ ಲಭ್ಯವಿರುವ ಪ್ರಮುಖ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳನ್ನು ಅರ್ಥಮಾಡಿಕೊಳ್ಳುವುದು.
- ವಿಭಿನ್ನ ಬಳಕೆ ಪ್ರಕರಣಗಳಿಗೆ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳನ್ನು ಸಂರಚಿಸುವುದು.
- ಪುನರಾವರ್ತನೀಯ ಫಲಿತಾಂಶಗಳಿಗಾಗಿ ನಿರ್ಧಿಷ್ಟ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಅನ್ನು ಜಾರಿಗೆ ತರುವುದು.
- ಸಂಧರ್ಭ ಮತ್ತು ಬಳಕೆದಾರ ಪ್ರಾಧಾನ್ಯತೆಗಳ ಆಧಾರದ ಮೇಲೆ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳನ್ನು ಗತಿಶೀಲವಾಗಿ ಹೊಂದಿಸುವುದು.
- ವಿವಿಧ ಸಂದರ್ಭಗಳಲ್ಲಿ ಮಾದರಿ ಕಾರ್ಯಕ್ಷಮತೆಯನ್ನು ಸುಧಾರಿಸಲು ಸ್ಯಾಂಪ್ಲಿಂಗ್ ತಂತ್ರಗಳನ್ನು ಅನ್ವಯಿಸುವುದು.
- MCP ನ ಕ್ಲೈಂಟ್-ಸರ್ವರ್ ಹರಿವಿನಲ್ಲಿ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಹೇಗೆ ಕಾರ್ಯನಿರ್ವಹಿಸುತ್ತದೆ ಎಂಬುದನ್ನು ಅರ್ಥಮಾಡಿಕೊಳ್ಳುವುದು.

## MCP ನಲ್ಲಿ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಹೇಗೆ ಕಾರ್ಯನಿರ್ವಹಿಸುತ್ತದೆ

MCP ನಲ್ಲಿ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಹರಿವು ಈ ಹಂತಗಳನ್ನು ಅನುಸರಿಸುತ್ತದೆ:

1. ಸರ್ವರ್ `sampling/createMessage` ವಿನಂತಿಯನ್ನು ಕ್ಲೈಂಟ್‌ಗೆ ಕಳುಹಿಸುತ್ತದೆ  
2. ಕ್ಲೈಂಟ್ ವಿನಂತಿಯನ್ನು ಪರಿಶೀಲಿಸಿ ಅದನ್ನು ಬದಲಾಯಿಸಬಹುದು  
3. ಕ್ಲೈಂಟ್ LLM ನಿಂದ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಮಾಡುತ್ತದೆ  
4. ಕ್ಲೈಂಟ್ ಪೂರ್ಣಗೊಳಿಸುವಿಕೆಯನ್ನು ಪರಿಶೀಲಿಸುತ್ತದೆ  
5. ಕ್ಲೈಂಟ್ ಫಲಿತಾಂಶವನ್ನು ಸರ್ವರ್‌ಗೆ ಹಿಂತಿರುಗಿಸುತ್ತದೆ  

ಈ ಮಾನವ-ನಿರ್ವಹಿತ ವಿನ್ಯಾಸವು ಬಳಕೆದಾರರು LLM ನೋಡುತ್ತಿರುವ ಮತ್ತು ರಚಿಸುತ್ತಿರುವ ವಿಷಯದ ಮೇಲೆ ನಿಯಂತ್ರಣವನ್ನು ಕಾಪಾಡಿಕೊಳ್ಳಲು ಖಚಿತಪಡಿಸುತ್ತದೆ.

## ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳ ಅವಲೋಕನ

MCP ಕೆಳಗಿನ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳನ್ನು ವ್ಯಾಖ್ಯಾನಿಸುತ್ತದೆ, ಅವುಗಳನ್ನು ಕ್ಲೈಂಟ್ ವಿನಂತಿಗಳಲ್ಲಿ ಸಂರಚಿಸಬಹುದು:

| ಪರಿಮಾಣ | ವಿವರಣೆ | ಸಾಮಾನ್ಯ ಶ್ರೇಣಿ |
|-----------|-------------|---------------|
| `temperature` | ಟೋಕನ್ ಆಯ್ಕೆ ಯಾದೃಚ್ಛಿಕತೆಯನ್ನು ನಿಯಂತ್ರಿಸುತ್ತದೆ | 0.0 - 1.0 |
| `maxTokens` | ರಚಿಸಲು ಗರಿಷ್ಠ ಟೋಕನ್‌ಗಳ ಸಂಖ್ಯೆ | ಪೂರ್ಣಾಂಕ ಮೌಲ್ಯ |
| `stopSequences` | ಕಂಡುಬಂದಾಗ ರಚನೆಯನ್ನು ನಿಲ್ಲಿಸುವ ಕಸ್ಟಮ್ ಸರಣಿಗಳು | ಸ್ಟ್ರಿಂಗ್‌ಗಳ ಸರಣಿ |
| `metadata` | ಹೆಚ್ಚುವರಿ ಪೂರೈಕೆದಾರ-ನಿರ್ದಿಷ್ಟ ಪರಿಮಾಣಗಳು | JSON ವಸ್ತು |

ಬಹು LLM ಪೂರೈಕೆದಾರರು `metadata` ಕ್ಷೇತ್ರದ ಮೂಲಕ ಹೆಚ್ಚುವರಿ ಪರಿಮಾಣಗಳನ್ನು ಬೆಂಬಲಿಸುತ್ತಾರೆ, ಅವುಗಳಲ್ಲಿ ಇರಬಹುದು:

| ಸಾಮಾನ್ಯ ವಿಸ್ತರಣೆ ಪರಿಮಾಣ | ವಿವರಣೆ | ಸಾಮಾನ್ಯ ಶ್ರೇಣಿ |
|-----------|-------------|---------------|
| `top_p` | ನ್ಯೂಕ್ಲಿಯಸ್ ಸ್ಯಾಂಪ್ಲಿಂಗ್ - ಟೋಕನ್‌ಗಳನ್ನು ಶ್ರೇಷ್ಠ ಸಂಯುಕ್ತ ಸಾಧ್ಯತೆಗೆ ಮಿತಿಗೊಳಿಸುತ್ತದೆ | 0.0 - 1.0 |
| `top_k` | ಟೋಕನ್ ಆಯ್ಕೆಗಳನ್ನು ಶ್ರೇಷ್ಠ K ಆಯ್ಕೆಗಳಿಗೆ ಮಿತಿಗೊಳಿಸುತ್ತದೆ | 1 - 100 |
| `presence_penalty` | ಈಗಾಗಲೇ ಪಠ್ಯದಲ್ಲಿ ಇರುವ ಟೋಕನ್‌ಗಳ ಆಧಾರದ ಮೇಲೆ ದಂಡನೆಯನ್ನು ನೀಡುತ್ತದೆ | -2.0 - 2.0 |
| `frequency_penalty` | ಈಗಾಗಲೇ ಪಠ್ಯದಲ್ಲಿ ಟೋಕನ್‌ಗಳ ಆವರ್ತನೆಯ ಆಧಾರದ ಮೇಲೆ ದಂಡನೆಯನ್ನು ನೀಡುತ್ತದೆ | -2.0 - 2.0 |
| `seed` | ಪುನರಾವರ್ತನೀಯ ಫಲಿತಾಂಶಗಳಿಗಾಗಿ ನಿರ್ದಿಷ್ಟ ಯಾದೃಚ್ಛಿಕ ಬೀಜ | ಪೂರ್ಣಾಂಕ ಮೌಲ್ಯ |

## ಉದಾಹರಣೆಯ ವಿನಂತಿ ಸ್ವರೂಪ

ಇದು MCP ನಲ್ಲಿ ಕ್ಲೈಂಟ್‌ನಿಂದ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ವಿನಂತಿಸುವ ಉದಾಹರಣೆ:

```json
{
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "What files are in the current directory?"
        }
      }
    ],
    "systemPrompt": "You are a helpful file system assistant.",
    "includeContext": "thisServer",
    "maxTokens": 100,
    "temperature": 0.7
  }
}
```

## ಪ್ರತಿಕ್ರಿಯೆ ಸ್ವರೂಪ

ಕ್ಲೈಂಟ್ ಪೂರ್ಣಗೊಳಿಸುವಿಕೆ ಫಲಿತಾಂಶವನ್ನು ಹಿಂತಿರುಗಿಸುತ್ತದೆ:

```json
{
  "model": "string",  // Name of the model used
  "stopReason": "endTurn" | "stopSequence" | "maxTokens" | "string",
  "role": "assistant",
  "content": {
    "type": "text",
    "text": "string"
  }
}
```

## ಮಾನವ ನಿಯಂತ್ರಣಗಳು

MCP ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಮಾನವ ಮೇಲ್ವಿಚಾರಣೆಯೊಂದಿಗೆ ವಿನ್ಯಾಸಗೊಳಿಸಲಾಗಿದೆ:

- **ಪ್ರಾಂಪ್ಟ್‌ಗಳಿಗೆ**:  
  - ಕ್ಲೈಂಟ್‌ಗಳು ಬಳಕೆದಾರರಿಗೆ ಪ್ರಸ್ತಾವಿತ ಪ್ರಾಂಪ್ಟ್ ಅನ್ನು ತೋರಿಸಬೇಕು  
  - ಬಳಕೆದಾರರು ಪ್ರಾಂಪ್ಟ್‌ಗಳನ್ನು ಬದಲಾಯಿಸಲು ಅಥವಾ ನಿರಾಕರಿಸಲು ಸಾಧ್ಯವಾಗಬೇಕು  
  - ಸಿಸ್ಟಮ್ ಪ್ರಾಂಪ್ಟ್‌ಗಳನ್ನು ಫಿಲ್ಟರ್ ಅಥವಾ ಬದಲಾಯಿಸಬಹುದು  
  - ಸಂಧರ್ಭ ಸೇರಿಸುವಿಕೆ ಕ್ಲೈಂಟ್ ಮೂಲಕ ನಿಯಂತ್ರಿಸಲಾಗುತ್ತದೆ  

- **ಪೂರ್ಣಗೊಳಿಸುವಿಕೆಗಳಿಗೆ**:  
  - ಕ್ಲೈಂಟ್‌ಗಳು ಬಳಕೆದಾರರಿಗೆ ಪೂರ್ಣಗೊಳಿಸುವಿಕೆಯನ್ನು ತೋರಿಸಬೇಕು  
  - ಬಳಕೆದಾರರು ಪೂರ್ಣಗೊಳಿಸುವಿಕೆಯನ್ನು ಬದಲಾಯಿಸಲು ಅಥವಾ ನಿರಾಕರಿಸಲು ಸಾಧ್ಯವಾಗಬೇಕು  
  - ಕ್ಲೈಂಟ್‌ಗಳು ಪೂರ್ಣಗೊಳಿಸುವಿಕೆಯನ್ನು ಫಿಲ್ಟರ್ ಅಥವಾ ಬದಲಾಯಿಸಬಹುದು  
  - ಬಳಕೆದಾರರು ಯಾವ ಮಾದರಿಯನ್ನು ಬಳಸಬೇಕೆಂದು ನಿಯಂತ್ರಿಸುತ್ತಾರೆ  

ಈ ತತ್ವಗಳನ್ನು ಗಮನದಲ್ಲಿಟ್ಟುಕೊಂಡು, LLM ಪೂರೈಕೆದಾರರ ನಡುವೆ ಸಾಮಾನ್ಯವಾಗಿ ಬೆಂಬಲಿಸಲ್ಪಡುವ ಪರಿಮಾಣಗಳ ಮೇಲೆ ಕೇಂದ್ರೀಕರಿಸಿ, ವಿಭಿನ್ನ ಪ್ರೋಗ್ರಾಮಿಂಗ್ ಭಾಷೆಗಳಲ್ಲಿ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಅನ್ನು ಹೇಗೆ ಜಾರಿಗೆ ತರುವುದನ್ನು ನೋಡೋಣ.

## ಭದ್ರತಾ ಪರಿಗಣನೆಗಳು

MCP ನಲ್ಲಿ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಜಾರಿಗೆ ತರುವಾಗ, ಈ ಭದ್ರತಾ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳನ್ನು ಪರಿಗಣಿಸಿ:

- **ಎಲ್ಲಾ ಸಂದೇಶ ವಿಷಯವನ್ನು ಪರಿಶೀಲಿಸಿ** ಅದನ್ನು ಕ್ಲೈಂಟ್‌ಗೆ ಕಳುಹಿಸುವ ಮೊದಲು  
- **ಪ್ರಾಂಪ್ಟ್‌ಗಳು ಮತ್ತು ಪೂರ್ಣಗೊಳಿಸುವಿಕೆಗಳಿಂದ ಸಂವೇದನಾಶೀಲ ಮಾಹಿತಿಯನ್ನು ಶುದ್ಧೀಕರಿಸಿ**  
- **ದುರupyೋಗ ತಡೆಯಲು ದರ ಮಿತಿಗಳನ್ನು ಜಾರಿಗೆ ತರುವುದು**  
- **ಅಸಾಮಾನ್ಯ ಮಾದರಿಗಳಿಗಾಗಿ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಬಳಕೆಯನ್ನು ಮೇಲ್ವಿಚಾರಣೆ ಮಾಡುವುದು**  
- **ಸುರಕ್ಷಿತ ಪ್ರೋಟೋಕಾಲ್‌ಗಳನ್ನು ಬಳಸಿ ಡೇಟಾವನ್ನು ಸಂಚಾರದಲ್ಲಿ ಎನ್‌ಕ್ರಿಪ್ಟ್ ಮಾಡುವುದು**  
- **ಸಂಬಂಧಿತ ನಿಯಮಾವಳಿಗಳ ಪ್ರಕಾರ ಬಳಕೆದಾರ ಡೇಟಾ ಗೌಪ್ಯತೆಯನ್ನು ನಿರ್ವಹಿಸುವುದು**  
- **ಅನುಕೂಲತೆ ಮತ್ತು ಭದ್ರತೆಗಾಗಿ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ವಿನಂತಿಗಳನ್ನು ಪರಿಶೀಲಿಸುವುದು**  
- **ತಕ್ಕಮಟ್ಟಿನ ಮಿತಿಗಳೊಂದಿಗೆ ವೆಚ್ಚ ಅನಾವರಣವನ್ನು ನಿಯಂತ್ರಿಸುವುದು**  
- **ಸ್ಯಾಂಪ್ಲಿಂಗ್ ವಿನಂತಿಗಳಿಗೆ ಸಮಯ ಮಿತಿಗಳನ್ನು ಜಾರಿಗೆ ತರುವುದು**  
- **ಮಾದರಿ ದೋಷಗಳನ್ನು ಸೂಕ್ತ ಬದಲಾವಣೆಗಳೊಂದಿಗೆ ಸೌಮ್ಯವಾಗಿ ನಿರ್ವಹಿಸುವುದು**  

ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳು ಭಾಷಾ ಮಾದರಿಗಳ ವರ್ತನೆಯನ್ನು ಸೂಕ್ಷ್ಮವಾಗಿ ಹೊಂದಿಸಲು ಅನುಮತಿಸುತ್ತವೆ, ನಿರ್ಧಿಷ್ಟ ಮತ್ತು ಸೃಜನಶೀಲ ಔಟ್‌ಪುಟ್‌ಗಳ ನಡುವೆ ಬಯಸಿದ ಸಮತೋಲನವನ್ನು ಸಾಧಿಸಲು.

ಈ ಪರಿಮಾಣಗಳನ್ನು ವಿಭಿನ್ನ ಪ್ರೋಗ್ರಾಮಿಂಗ್ ಭಾಷೆಗಳಲ್ಲಿ ಹೇಗೆ ಸಂರಚಿಸುವುದನ್ನು ನೋಡೋಣ.

# [.NET](../../../../05-AdvancedTopics/mcp-sampling)

```csharp
// .NET Example: Configuring sampling parameters in MCP
public class SamplingExample
{
    public async Task RunWithSamplingAsync()
    {
        // Create MCP client with sampling configuration
        var client = new McpClient("https://mcp-server-url.com");
        
        // Create request with specific sampling parameters
        var request = new McpRequest
        {
            Prompt = "Generate creative ideas for a mobile app",
            SamplingParameters = new SamplingParameters
            {
                Temperature = 0.8f,     // Higher temperature for more creative outputs
                TopP = 0.95f,           // Nucleus sampling parameter
                TopK = 40,              // Limit token selection to top K options
                FrequencyPenalty = 0.5f, // Reduce repetition
                PresencePenalty = 0.2f   // Encourage diversity
            },
            AllowedTools = new[] { "ideaGenerator", "marketAnalyzer" }
        };
        
        // Send request using specific sampling configuration
        var response = await client.SendRequestAsync(request);
        
        // Output results
        Console.WriteLine($"Generated with Temperature={request.SamplingParameters.Temperature}:");
        Console.WriteLine(response.GeneratedText);
    }
}
```

ಮುಂಬರುವ ಕೋಡ್‌ನಲ್ಲಿ ನಾವು:

- ನಿರ್ದಿಷ್ಟ ಸರ್ವರ್ URL ಹೊಂದಿರುವ MCP ಕ್ಲೈಂಟ್ ಅನ್ನು ರಚಿಸಿದ್ದೇವೆ.  
- `temperature`, `top_p`, ಮತ್ತು `top_k` ಮುಂತಾದ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳೊಂದಿಗೆ ವಿನಂತಿಯನ್ನು ಸಂರಚಿಸಿದ್ದೇವೆ.  
- ವಿನಂತಿಯನ್ನು ಕಳುಹಿಸಿ ರಚಿಸಲಾದ ಪಠ್ಯವನ್ನು ಮುದ್ರಿಸಿದ್ದೇವೆ.  
- ಬಳಸಿದ್ದೇವೆ:  
    - `allowedTools` ಮೂಲಕ ಮಾದರಿ ರಚನೆಯ ಸಮಯದಲ್ಲಿ ಯಾವ ಸಾಧನಗಳನ್ನು ಬಳಸಬಹುದು ಎಂದು ನಿರ್ದಿಷ್ಟಪಡಿಸಲಾಗಿದೆ. ಈ ಪ್ರಕರಣದಲ್ಲಿ, ಸೃಜನಶೀಲ ಅಪ್ಲಿಕೇಶನ್ ಐಡಿಯಾಗಳನ್ನು ರಚಿಸಲು `ideaGenerator` ಮತ್ತು `marketAnalyzer` ಸಾಧನಗಳನ್ನು ಅನುಮತಿಸಿದ್ದೇವೆ.  
    - `frequencyPenalty` ಮತ್ತು `presencePenalty` ಮೂಲಕ ಔಟ್‌ಪುಟ್‌ನಲ್ಲಿ ಪುನರಾವರ್ತನೆ ಮತ್ತು ವೈವಿಧ್ಯತೆಯನ್ನು ನಿಯಂತ್ರಿಸಲಾಗಿದೆ.  
    - `temperature` ಮೂಲಕ ಔಟ್‌ಪುಟ್‌ನ ಯಾದೃಚ್ಛಿಕತೆಯನ್ನು ನಿಯಂತ್ರಿಸಲಾಗಿದೆ, ಹೆಚ್ಚಿನ ಮೌಲ್ಯಗಳು ಹೆಚ್ಚು ಸೃಜನಶೀಲ ಪ್ರತಿಕ್ರಿಯೆಗಳಿಗೆ ಕಾರಣವಾಗುತ್ತವೆ.  
    - `top_p` ಮೂಲಕ ಟೋಕನ್ ಆಯ್ಕೆಗಳನ್ನು ಶ್ರೇಷ್ಠ ಸಂಯುಕ್ತ ಸಾಧ್ಯತೆ ಮಾಸಿಗೆ ಮಿತಿಗೊಳಿಸಲಾಗಿದೆ, ರಚಿಸಲಾದ ಪಠ್ಯದ ಗುಣಮಟ್ಟವನ್ನು ಸುಧಾರಿಸುತ್ತದೆ.  
    - `top_k` ಮೂಲಕ ಮಾದರಿಯನ್ನು ಶ್ರೇಷ್ಠ K ಅತ್ಯಂತ ಸಾಧ್ಯ ಟೋಕನ್‌ಗಳಿಗೆ ಮಿತಿಗೊಳಿಸಲಾಗಿದೆ, ಇದು ಹೆಚ್ಚು ಸಮ್ಮಿಲಿತ ಪ್ರತಿಕ್ರಿಯೆಗಳಿಗೆ ಸಹಾಯ ಮಾಡುತ್ತದೆ.  
    - `frequencyPenalty` ಮತ್ತು `presencePenalty` ಮೂಲಕ ಪುನರಾವರ್ತನೆ ಕಡಿಮೆಮಾಡಿ ವೈವಿಧ್ಯತೆಯನ್ನು ಉತ್ತೇಜಿಸಲಾಗಿದೆ.  

# [JavaScript](../../../../05-AdvancedTopics/mcp-sampling)

```javascript
// ಜಾವಾಸ್ಕ್ರಿಪ್ಟ್ ಉದಾಹರಣೆ: ತಾಪಮಾನ ಮತ್ತು ಟಾಪ್-ಪಿ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಸಂರಚನೆ
const { McpClient } = require('@mcp/client');

async function demonstrateSampling() {
  // MCP ಕ್ಲೈಂಟ್ ಅನ್ನು ಪ್ರಾರಂಭಿಸಿ
  const client = new McpClient({
    serverUrl: 'https://mcp-server-example.com',
    apiKey: process.env.MCP_API_KEY
  });
  
  // ವಿಭಿನ್ನ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳೊಂದಿಗೆ ವಿನಂತಿಯನ್ನು ಸಂರಚಿಸಿ
  const creativeSampling = {
    temperature: 0.9,    // ಹೆಚ್ಚಿನ ತಾಪಮಾನ = ಹೆಚ್ಚು ಯಾದೃಚ್ಛಿಕತೆ/ಸೃಜನಶೀಲತೆ
    topP: 0.92,          // ಟಾಪ್ 92% ಸಾಧ್ಯತೆ ಮಾಸ್ ಹೊಂದಿರುವ ಟೋಕನ್‌ಗಳನ್ನು ಪರಿಗಣಿಸಿ
    frequencyPenalty: 0.6, // ಟೋಕನ್ ಸರಣಿಗಳ ಪುನರಾವೃತ್ತಿಯನ್ನು ಕಡಿಮೆ ಮಾಡಿ
    presencePenalty: 0.4   // ಈಗಾಗಲೇ ಪಠ್ಯದಲ್ಲಿ ಕಾಣಿಸಿಕೊಂಡ ಟೋಕನ್‌ಗಳನ್ನು ದಂಡಿಸಿ
  };
  
  const factualSampling = {
    temperature: 0.2,    // ಕಡಿಮೆ ತಾಪಮಾನ = ಹೆಚ್ಚು ನಿರ್ಧಾರಾತ್ಮಕ/ವಾಸ್ತವಿಕ
    topP: 0.85,          // ಸ್ವಲ್ಪ ಹೆಚ್ಚು ಕೇಂದ್ರೀಕೃತ ಟೋಕನ್ ಆಯ್ಕೆ
    frequencyPenalty: 0.2, // ಕನಿಷ್ಠ ಪುನರಾವೃತ್ತಿ ದಂಡನೆ
    presencePenalty: 0.1   // ಕನಿಷ್ಠ ಹಾಜರಿ ದಂಡನೆ
  };
  
  try {
    // ವಿಭಿನ್ನ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಸಂರಚನೆಗಳೊಂದಿಗೆ ಎರಡು ವಿನಂತಿಗಳನ್ನು ಕಳುಹಿಸಿ
    const creativeResponse = await client.sendPrompt(
      "Generate innovative ideas for sustainable urban transportation",
      {
        allowedTools: ['ideaGenerator', 'environmentalImpactTool'],
        ...creativeSampling
      }
    );
    
    const factualResponse = await client.sendPrompt(
      "Explain how electric vehicles impact carbon emissions",
      {
        allowedTools: ['factChecker', 'dataAnalysisTool'],
        ...factualSampling
      }
    );
    
    console.log('Creative Response (temperature=0.9):');
    console.log(creativeResponse.generatedText);
    
    console.log('\nFactual Response (temperature=0.2):');
    console.log(factualResponse.generatedText);
    
  } catch (error) {
    console.error('Error demonstrating sampling:', error);
  }
}

demonstrateSampling();
```

ಮುಂಬರುವ ಕೋಡ್‌ನಲ್ಲಿ ನಾವು:

- ಸರ್ವರ್ URL ಮತ್ತು API ಕೀ ಹೊಂದಿರುವ MCP ಕ್ಲೈಂಟ್ ಅನ್ನು ಪ್ರಾರಂಭಿಸಿದ್ದೇವೆ.  
- ಸೃಜನಶೀಲ ಕಾರ್ಯಗಳಿಗೆ ಮತ್ತು ವಾಸ್ತವಿಕ ಕಾರ್ಯಗಳಿಗೆ ಎರಡು ಸೆಟ್ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳನ್ನು ಸಂರಚಿಸಿದ್ದೇವೆ.  
- ಈ ಸಂರಚನೆಗಳೊಂದಿಗೆ ವಿನಂತಿಗಳನ್ನು ಕಳುಹಿಸಿ, ಪ್ರತಿ ಕಾರ್ಯಕ್ಕೆ ಮಾದರಿ ನಿರ್ದಿಷ್ಟ ಸಾಧನಗಳನ್ನು ಬಳಸಲು ಅನುಮತಿಸಿದ್ದೇವೆ.  
- ವಿಭಿನ್ನ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳ ಪರಿಣಾಮಗಳನ್ನು ತೋರಿಸಲು ರಚಿಸಲಾದ ಪ್ರತಿಕ್ರಿಯೆಗಳನ್ನು ಮುದ್ರಿಸಿದ್ದೇವೆ.  
- `allowedTools` ಬಳಸಿ ಮಾದರಿ ರಚನೆಯ ಸಮಯದಲ್ಲಿ ಯಾವ ಸಾಧನಗಳನ್ನು ಬಳಸಬಹುದು ಎಂದು ನಿರ್ದಿಷ್ಟಪಡಿಸಿದ್ದೇವೆ. ಈ ಪ್ರಕರಣದಲ್ಲಿ, ಸೃಜನಶೀಲ ಕಾರ್ಯಗಳಿಗೆ `ideaGenerator` ಮತ್ತು `environmentalImpactTool` ಅನ್ನು, ವಾಸ್ತವಿಕ ಕಾರ್ಯಗಳಿಗೆ `factChecker` ಮತ್ತು `dataAnalysisTool` ಅನ್ನು ಅನುಮತಿಸಿದ್ದೇವೆ.  
- `temperature` ಮೂಲಕ ಔಟ್‌ಪುಟ್‌ನ ಯಾದೃಚ್ಛಿಕತೆಯನ್ನು ನಿಯಂತ್ರಿಸಿದ್ದೇವೆ, ಹೆಚ್ಚಿನ ಮೌಲ್ಯಗಳು ಹೆಚ್ಚು ಸೃಜನಶೀಲ ಪ್ರತಿಕ್ರಿಯೆಗಳಿಗೆ ಕಾರಣವಾಗುತ್ತವೆ.  
- `top_p` ಮೂಲಕ ಟೋಕನ್ ಆಯ್ಕೆಗಳನ್ನು ಶ್ರೇಷ್ಠ ಸಂಯುಕ್ತ ಸಾಧ್ಯತೆ ಮಾಸಿಗೆ ಮಿತಿಗೊಳಿಸಿದ್ದೇವೆ, ರಚಿಸಲಾದ ಪಠ್ಯದ ಗುಣಮಟ್ಟವನ್ನು ಸುಧಾರಿಸುತ್ತದೆ.  
- `frequencyPenalty` ಮತ್ತು `presencePenalty` ಮೂಲಕ ಪುನರಾವರ್ತನೆ ಕಡಿಮೆಮಾಡಿ ವೈವಿಧ್ಯತೆಯನ್ನು ಉತ್ತೇಜಿಸಿದ್ದೇವೆ.  
- `top_k` ಮೂಲಕ ಮಾದರಿಯನ್ನು ಶ್ರೇಷ್ಠ K ಅತ್ಯಂತ ಸಾಧ್ಯ ಟೋಕನ್‌ಗಳಿಗೆ ಮಿತಿಗೊಳಿಸಿದ್ದೇವೆ, ಇದು ಹೆಚ್ಚು ಸಮ್ಮಿಲಿತ ಪ್ರತಿಕ್ರಿಯೆಗಳಿಗೆ ಸಹಾಯ ಮಾಡುತ್ತದೆ.  

---

## ನಿರ್ಧಿಷ್ಟ ಸ್ಯಾಂಪ್ಲಿಂಗ್

ಸ್ಥಿರ ಔಟ್‌ಪುಟ್‌ಗಳನ್ನು ಅಗತ್ಯವಿರುವ ಅಪ್ಲಿಕೇಶನ್‌ಗಳಿಗೆ, ನಿರ್ಧಿಷ್ಟ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪುನರಾವರ್ತನೀಯ ಫಲಿತಾಂಶಗಳನ್ನು ಖಚಿತಪಡಿಸುತ್ತದೆ. ಇದು ಸ್ಥಿರ ಯಾದೃಚ್ಛಿಕ ಬೀಜವನ್ನು ಬಳಸುವುದರ ಮೂಲಕ ಮತ್ತು ತಾಪಮಾನವನ್ನು ಶೂನ್ಯಕ್ಕೆ ಹೊಂದಿಸುವ ಮೂಲಕ ಸಾಧ್ಯವಾಗುತ್ತದೆ.

ವಿಭಿನ್ನ ಪ್ರೋಗ್ರಾಮಿಂಗ್ ಭಾಷೆಗಳಲ್ಲಿ ನಿರ್ಧಿಷ್ಟ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಅನ್ನು ಪ್ರದರ್ಶಿಸಲು ಕೆಳಗಿನ ಉದಾಹರಣೆಯನ್ನು ನೋಡೋಣ.

# [Java](../../../../05-AdvancedTopics/mcp-sampling)

```java
// ಜಾವಾ ಉದಾಹರಣೆ: ನಿಶ್ಚಿತ ಪ್ರತಿಕ್ರಿಯೆಗಳು ಸ್ಥಿರ ಬೀಜದೊಂದಿಗೆ
public class DeterministicSamplingExample {
    public void demonstrateDeterministicResponses() {
        McpClient client = new McpClient.Builder()
            .setServerUrl("https://mcp-server-example.com")
            .build();
            
        long fixedSeed = 12345; // ನಿಶ್ಚಿತ ಫಲಿತಾಂಶಗಳಿಗಾಗಿ ಸ್ಥಿರ ಬೀಜವನ್ನು ಬಳಸುವುದು
        
        // ಸ್ಥಿರ ಬೀಜದೊಂದಿಗೆ ಮೊದಲ ವಿನಂತಿ
        McpRequest request1 = new McpRequest.Builder()
            .setPrompt("Generate a random number between 1 and 100")
            .setSeed(fixedSeed)
            .setTemperature(0.0) // ಗರಿಷ್ಠ ನಿಶ್ಚಿತತೆಗಾಗಿ ಶೂನ್ಯ ತಾಪಮಾನ
            .build();
            
        // ಅದೇ ಬೀಜದೊಂದಿಗೆ ಎರಡನೇ ವಿನಂತಿ
        McpRequest request2 = new McpRequest.Builder()
            .setPrompt("Generate a random number between 1 and 100")
            .setSeed(fixedSeed)
            .setTemperature(0.0)
            .build();
        
        // ಎರಡೂ ವಿನಂತಿಗಳನ್ನು ಕಾರ್ಯಗತಗೊಳಿಸಿ
        McpResponse response1 = client.sendRequest(request1);
        McpResponse response2 = client.sendRequest(request2);
        
        // ಅದೇ ಬೀಜ ಮತ್ತು ತಾಪಮಾನ=0 ಕಾರಣ ಪ್ರತಿಕ್ರಿಯೆಗಳು ಒಂದೇ ಆಗಿರಬೇಕು
        System.out.println("Response 1: " + response1.getGeneratedText());
        System.out.println("Response 2: " + response2.getGeneratedText());
        System.out.println("Are responses identical: " + 
            response1.getGeneratedText().equals(response2.getGeneratedText()));
    }
}
```

ಮುಂಬರುವ ಕೋಡ್‌ನಲ್ಲಿ ನಾವು:

- ನಿರ್ದಿಷ್ಟ ಸರ್ವರ್ URL ಹೊಂದಿರುವ MCP ಕ್ಲೈಂಟ್ ಅನ್ನು ರಚಿಸಿದ್ದೇವೆ.  
- ಒಂದೇ ಪ್ರಾಂಪ್ಟ್, ಸ್ಥಿರ ಬೀಜ ಮತ್ತು ಶೂನ್ಯ ತಾಪಮಾನ ಹೊಂದಿರುವ ಎರಡು ವಿನಂತಿಗಳನ್ನು ಸಂರಚಿಸಿದ್ದೇವೆ.  
- ಎರಡೂ ವಿನಂತಿಗಳನ್ನು ಕಳುಹಿಸಿ ರಚಿಸಲಾದ ಪಠ್ಯವನ್ನು ಮುದ್ರಿಸಿದ್ದೇವೆ.  
- ಪ್ರತಿಕ್ರಿಯೆಗಳು ನಿರ್ಧಿಷ್ಟ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಸಂರಚನೆಯ (ಒಂದೇ ಬೀಜ ಮತ್ತು ತಾಪಮಾನ) ಕಾರಣದಿಂದ ಒಂದೇ ರೀತಿಯವು ಎಂದು ತೋರಿಸಿದ್ದೇವೆ.  
- `setSeed` ಬಳಸಿ ಸ್ಥಿರ ಯಾದೃಚ್ಛಿಕ ಬೀಜವನ್ನು ನಿರ್ದಿಷ್ಟಪಡಿಸಿದ್ದೇವೆ, ಇದು ಮಾದರಿ ಪ್ರತಿಯೊಂದು ಬಾರಿ ಒಂದೇ ಇನ್ಪುಟ್‌ಗೆ ಒಂದೇ ಔಟ್‌ಪುಟ್ ಅನ್ನು ರಚಿಸುವಂತೆ ಖಚಿತಪಡಿಸುತ್ತದೆ.  
- `temperature` ಅನ್ನು ಶೂನ್ಯಕ್ಕೆ ಹೊಂದಿಸಿ ಗರಿಷ್ಠ ನಿರ್ಧಿಷ್ಟತೆಯನ್ನು ಖಚಿತಪಡಿಸಿದ್ದೇವೆ, ಅಂದರೆ ಮಾದರಿ ಯಾವಾಗಲೂ ಯಾದೃಚ್ಛಿಕತೆ ಇಲ್ಲದೆ ಅತ್ಯಂತ ಸಾಧ್ಯವಿರುವ ಮುಂದಿನ ಟೋಕನ್ ಅನ್ನು ಆಯ್ಕೆಮಾಡುತ್ತದೆ.  

# [JavaScript](../../../../05-AdvancedTopics/mcp-sampling)

```javascript
// ಜಾವಾಸ್ಕ್ರಿಪ್ಟ್ ಉದಾಹರಣೆ: ಬೀಜ ನಿಯಂತ್ರಣದೊಂದಿಗೆ ನಿರ್ಧಾರಾತ್ಮಕ ಪ್ರತಿಕ್ರಿಯೆಗಳು
const { McpClient } = require('@mcp/client');

async function deterministicSampling() {
  const client = new McpClient({
    serverUrl: 'https://mcp-server-example.com'
  });
  
  const fixedSeed = 12345;
  const prompt = "Generate a random password with 8 characters";
  
  try {
    // ಸ್ಥಿರ ಬೀಜದೊಂದಿಗೆ ಮೊದಲ ವಿನಂತಿ
    const response1 = await client.sendPrompt(prompt, {
      seed: fixedSeed,
      temperature: 0.0  // ಗರಿಷ್ಠ ನಿರ್ಧಾರಾತ್ಮಕತೆಯಿಗಾಗಿ ಶೂನ್ಯ ತಾಪಮಾನ
    });
    
    // ಅದೇ ಬೀಜ ಮತ್ತು ತಾಪಮಾನದೊಂದಿಗೆ ಎರಡನೇ ವಿನಂತಿ
    const response2 = await client.sendPrompt(prompt, {
      seed: fixedSeed,
      temperature: 0.0
    });
    
    // ವಿಭಿನ್ನ ಬೀಜ ಆದರೆ ಅದೇ ತಾಪಮಾನದೊಂದಿಗೆ ಮೂರನೇ ವಿನಂತಿ
    const response3 = await client.sendPrompt(prompt, {
      seed: 67890,
      temperature: 0.0
    });
    
    console.log('Response 1:', response1.generatedText);
    console.log('Response 2:', response2.generatedText);
    console.log('Response 3:', response3.generatedText);
    console.log('Responses 1 and 2 match:', response1.generatedText === response2.generatedText);
    console.log('Responses 1 and 3 match:', response1.generatedText === response3.generatedText);
    
  } catch (error) {
    console.error('Error in deterministic sampling demo:', error);
  }
}

deterministicSampling();
```

ಮುಂಬರುವ ಕೋಡ್‌ನಲ್ಲಿ ನಾವು:

- ಸರ್ವರ್ URL ಹೊಂದಿರುವ MCP ಕ್ಲೈಂಟ್ ಅನ್ನು ಪ್ರಾರಂಭಿಸಿದ್ದೇವೆ.  
- ಒಂದೇ ಪ್ರಾಂಪ್ಟ್, ಸ್ಥಿರ ಬೀಜ ಮತ್ತು ಶೂನ್ಯ ತಾಪಮಾನ ಹೊಂದಿರುವ ಎರಡು ವಿನಂತಿಗಳನ್ನು ಸಂರಚಿಸಿದ್ದೇವೆ.  
- ಎರಡೂ ವಿನಂತಿಗಳನ್ನು ಕಳುಹಿಸಿ ರಚಿಸಲಾದ ಪಠ್ಯವನ್ನು ಮುದ್ರಿಸಿದ್ದೇವೆ.  
- ಪ್ರತಿಕ್ರಿಯೆಗಳು ನಿರ್ಧಿಷ್ಟ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಸಂರಚನೆಯ (ಒಂದೇ ಬೀಜ ಮತ್ತು ತಾಪಮಾನ) ಕಾರಣದಿಂದ ಒಂದೇ ರೀತಿಯವು ಎಂದು ತೋರಿಸಿದ್ದೇವೆ.  
- `seed` ಬಳಸಿ ಸ್ಥಿರ ಯಾದೃಚ್ಛಿಕ ಬೀಜವನ್ನು ನಿರ್ದಿಷ್ಟಪಡಿಸಿದ್ದೇವೆ, ಇದು ಮಾದರಿ ಪ್ರತಿಯೊಂದು ಬಾರಿ ಒಂದೇ ಇನ್ಪುಟ್‌ಗೆ ಒಂದೇ ಔಟ್‌ಪುಟ್ ಅನ್ನು ರಚಿಸುವಂತೆ ಖಚಿತಪಡಿಸುತ್ತದೆ.  
- `temperature` ಅನ್ನು ಶೂನ್ಯಕ್ಕೆ ಹೊಂದಿಸಿ ಗರಿಷ್ಠ ನಿರ್ಧಿಷ್ಟತೆಯನ್ನು ಖಚಿತಪಡಿಸಿದ್ದೇವೆ, ಅಂದರೆ ಮಾದರಿ ಯಾವಾಗಲೂ ಯಾದೃಚ್ಛಿಕತೆ ಇಲ್ಲದೆ ಅತ್ಯಂತ ಸಾಧ್ಯವಿರುವ ಮುಂದಿನ ಟೋಕನ್ ಅನ್ನು ಆಯ್ಕೆಮಾಡುತ್ತದೆ.  
- ಮೂರನೇ ವಿನಂತಿಗೆ ವಿಭಿನ್ನ ಬೀಜವನ್ನು ಬಳಸಿದ್ದು, ಅದರಿಂದ ಪ್ರಾಂಪ್ಟ್ ಮತ್ತು ತಾಪಮಾನ ಒಂದೇ ಇದ್ದರೂ ವಿಭಿನ್ನ ಔಟ್‌ಪುಟ್‌ಗಳು ಬರುತ್ತವೆ ಎಂದು ತೋರಿಸಲಾಗಿದೆ.  

---

## ಗತಿಶೀಲ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಸಂರಚನೆ

ಬುದ್ಧಿವಂತ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪ್ರತಿ ವಿನಂತಿಯ ಸಂಧರ್ಭ ಮತ್ತು ಅಗತ್ಯಗಳ ಆಧಾರದ ಮೇಲೆ ಪರಿಮಾಣಗಳನ್ನು ಹೊಂದಿಕೊಳ್ಳುತ್ತದೆ. ಅಂದರೆ ಕಾರ್ಯದ ಪ್ರಕಾರ, ಬಳಕೆದಾರ ಪ್ರಾಧಾನ್ಯತೆಗಳು ಅಥವಾ ಇತಿಹಾಸದ ಕಾರ್ಯಕ್ಷಮತೆಯ ಆಧಾರದ ಮೇಲೆ ತಾಪಮಾನ, top_p ಮತ್ತು ದಂಡನೆಗಳನ್ನು ಗತಿಶೀಲವಾಗಿ ಹೊಂದಿಸುವುದು.

ವಿಭಿನ್ನ ಪ್ರೋಗ್ರಾಮಿಂಗ್ ಭಾಷೆಗಳಲ್ಲಿ ಗತಿಶೀಲ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಅನ್ನು ಹೇಗೆ ಜಾರಿಗೆ ತರುವುದನ್ನು ನೋಡೋಣ.

# [Python](../../../../05-AdvancedTopics/mcp-sampling)

```python
# ಪೈಥಾನ್ ಉದಾಹರಣೆ: ವಿನಂತಿ ಸಂದರ್ಭದ ಆಧಾರದ ಮೇಲೆ ಡೈನಾಮಿಕ್ ಸ್ಯಾಂಪ್ಲಿಂಗ್
class DynamicSamplingService:
    def __init__(self, mcp_client):
        self.client = mcp_client
        
    async def generate_with_adaptive_sampling(self, prompt, task_type, user_preferences=None):
        """Uses different sampling strategies based on task type and user preferences"""
        
        # ವಿಭಿನ್ನ ಕಾರ್ಯ ಪ್ರಕಾರಗಳಿಗೆ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪೂರ್ವನಿಯೋಜನೆಗಳನ್ನು ವ್ಯಾಖ್ಯಾನಿಸಿ
        sampling_presets = {
            "creative": {"temperature": 0.9, "top_p": 0.95, "frequency_penalty": 0.7},
            "factual": {"temperature": 0.2, "top_p": 0.85, "frequency_penalty": 0.2},
            "code": {"temperature": 0.3, "top_p": 0.9, "frequency_penalty": 0.5},
            "analytical": {"temperature": 0.4, "top_p": 0.92, "frequency_penalty": 0.3}
        }
        
        # ಮೂಲ ಪೂರ್ವನಿಯೋಜನೆಯನ್ನು ಆಯ್ಕೆಮಾಡಿ
        sampling_params = sampling_presets.get(task_type, sampling_presets["factual"])
        
        # ಬಳಕೆದಾರ ಪ್ರಾಧಾನ್ಯತೆಗಳ ಆಧಾರದ ಮೇಲೆ ಸರಿಹೊಂದಿಸಿ, ನೀಡಿದರೆ
        if user_preferences:
            if "creativity_level" in user_preferences:
                # ಸೃಜನಶೀಲತೆ ಪ್ರಾಧಾನ್ಯತೆ (1-10) ಆಧಾರದ ಮೇಲೆ ತಾಪಮಾನವನ್ನು ಪ್ರಮಾಣಿತಗೊಳಿಸಿ
                creativity = min(max(user_preferences["creativity_level"], 1), 10) / 10
                sampling_params["temperature"] = 0.1 + (0.9 * creativity)
            
            if "diversity" in user_preferences:
                # ಬಯಸಿದ ಪ್ರತಿಕ್ರಿಯೆಯ ವೈವಿಧ್ಯತೆಯ ಆಧಾರದ ಮೇಲೆ top_p ಅನ್ನು ಸರಿಹೊಂದಿಸಿ
                diversity = min(max(user_preferences["diversity"], 1), 10) / 10
                sampling_params["top_p"] = 0.6 + (0.39 * diversity)
        
        # ಕಸ್ಟಮ್ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳೊಂದಿಗೆ ವಿನಂತಿಯನ್ನು ರಚಿಸಿ ಮತ್ತು ಕಳುಹಿಸಿ
        response = await self.client.send_request(
            prompt=prompt,
            temperature=sampling_params["temperature"],
            top_p=sampling_params["top_p"],
            frequency_penalty=sampling_params["frequency_penalty"]
        )
        
        # ಪಾರದರ್ಶಕತೆಯಿಗಾಗಿ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಮೆಟಾಡೇಟಾ ಸಹಿತ ಪ್ರತಿಕ್ರಿಯೆಯನ್ನು ಹಿಂತಿರುಗಿಸಿ
        return {
            "text": response.generated_text,
            "applied_sampling": sampling_params,
            "task_type": task_type
        }
```

ಮುಂಬರುವ ಕೋಡ್‌ನಲ್ಲಿ ನಾವು:

- ಹೊಂದಿಕೊಳ್ಳುವ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಅನ್ನು ನಿರ್ವಹಿಸುವ `DynamicSamplingService` ವರ್ಗವನ್ನು ರಚಿಸಿದ್ದೇವೆ.  
- ವಿಭಿನ್ನ ಕಾರ್ಯ ಪ್ರಕಾರಗಳಿಗೆ (ಸೃಜನಶೀಲ, ವಾಸ್ತವಿಕ, ಕೋಡ್, ವಿಶ್ಲೇಷಣಾತ್ಮಕ) ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪೂರ್ವನಿಯೋಜನೆಗಳನ್ನು ವ್ಯಾಖ್ಯಾನಿಸಿದ್ದೇವೆ.  
- ಕಾರ್ಯ ಪ್ರಕಾರದ ಆಧಾರದ ಮೇಲೆ ಮೂಲ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪೂರ್ವನಿಯೋಜನೆಯನ್ನು ಆಯ್ಕೆಮಾಡಿದ್ದೇವೆ.  
- ಬಳಕೆದಾರ ಪ್ರಾಧಾನ್ಯತೆಗಳ ಆಧಾರದ ಮೇಲೆ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳನ್ನು ಹೊಂದಿಸಿದ್ದೇವೆ, ಉದಾಹರಣೆಗೆ ಸೃಜನಶೀಲತೆ ಮಟ್ಟ ಮತ್ತು ವೈವಿಧ್ಯತೆ.  
- ಗತಿಶೀಲವಾಗಿ ಸಂರಚಿಸಲಾದ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳೊಂದಿಗೆ ವಿನಂತಿಯನ್ನು ಕಳುಹಿಸಿದ್ದೇವೆ.  
- ಪಾರದರ್ಶಕತೆಯಿಗಾಗಿ ಅನ್ವಯಿಸಿದ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳು ಮತ್ತು ಕಾರ್ಯ ಪ್ರಕಾರದೊಂದಿಗೆ ರಚಿಸಲಾದ ಪಠ್ಯವನ್ನು ಹಿಂತಿರುಗಿಸಿದ್ದೇವೆ.  
- `temperature` ಮೂಲಕ ಔಟ್‌ಪುಟ್‌ನ ಯಾದೃಚ್ಛಿಕತೆಯನ್ನು ನಿಯಂತ್ರಿಸಿದ್ದೇವೆ, ಹೆಚ್ಚಿನ ಮೌಲ್ಯಗಳು ಹೆಚ್ಚು ಸೃಜನಶೀಲ ಪ್ರತಿಕ್ರಿಯೆಗಳಿಗೆ ಕಾರಣವಾಗುತ್ತವೆ.  
- `top_p` ಮೂಲಕ ಟೋಕನ್ ಆಯ್ಕೆಗಳನ್ನು ಶ್ರೇಷ್ಠ ಸಂಯುಕ್ತ ಸಾಧ್ಯತೆ ಮಾಸಿಗೆ ಮಿತಿಗೊಳಿಸಿದ್ದೇವೆ, ರಚಿಸಲಾದ ಪಠ್ಯದ ಗುಣಮಟ್ಟವನ್ನು ಸುಧಾರಿಸುತ್ತದೆ.  
- `frequency_penalty` ಮೂಲಕ ಪುನರಾವರ್ತನೆ ಕಡಿಮೆಮಾಡಿ ವೈವಿಧ್ಯತೆಯನ್ನು ಉತ್ತೇಜಿಸಿದ್ದೇವೆ.  
- ಬಳಕೆದಾರ-ನಿರ್ಧರಿತ ಸೃಜನಶೀಲತೆ ಮತ್ತು ವೈವಿಧ್ಯತೆ ಮಟ್ಟಗಳ ಆಧಾರದ ಮೇಲೆ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳ ಕಸ್ಟಮೈಜೇಶನ್‌ಗೆ `user_preferences` ಅನ್ನು ಬಳಸಿದ್ದೇವೆ.  
- ವಿನಂತಿಗೆ ಸೂಕ್ತ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ತಂತ್ರವನ್ನು ನಿರ್ಧರಿಸಲು `task_type` ಅನ್ನು ಬಳಸಿದ್ದೇವೆ, ಕಾರ್ಯ ಸ್ವಭಾವದ ಆಧಾರದ ಮೇಲೆ ಹೆಚ್ಚು ಹೊಂದಿಕೊಳ್ಳುವ ಪ್ರತಿಕ್ರಿಯೆಗಳಿಗೆ ಅನುಮತಿಸುವುದು.  
- ಸಂರಚಿಸಲಾದ ಸ್ಯಾಂಪ್ಲಿಂಗ್ ಪರಿಮಾಣಗಳೊಂದಿಗೆ ಪ್ರಾಂಪ್ಟ್ ಕಳುಹಿಸಲು `send_request` ವಿಧಾನವನ್ನು ಬಳಸಿದ್ದೇವೆ, ಮಾದರಿ ನಿರ್ದಿಷ್ಟ ಅಗತ್ಯಗಳ ಪ್ರಕಾರ ಪಠ್ಯವನ್ನು ರಚಿಸುತ್ತದೆ.  
- ಮಾದರಿಯ ಪ್ರತಿಕ್ರಿಯೆಯನ್ನು ಪಡೆಯಲು `generated_text` ಅನ್ನು ಬಳಸಿದ್ದ

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**ಅಸ್ವೀಕಾರ**:  
ಈ ದಸ್ತಾವೇಜು AI ಅನುವಾದ ಸೇವೆ [Co-op Translator](https://github.com/Azure/co-op-translator) ಬಳಸಿ ಅನುವಾದಿಸಲಾಗಿದೆ. ನಾವು ನಿಖರತೆಯಿಗಾಗಿ ಪ್ರಯತ್ನಿಸುತ್ತಿದ್ದರೂ, ಸ್ವಯಂಚಾಲಿತ ಅನುವಾದಗಳಲ್ಲಿ ದೋಷಗಳು ಅಥವಾ ಅಸತ್ಯತೆಗಳು ಇರಬಹುದು ಎಂದು ದಯವಿಟ್ಟು ಗಮನಿಸಿ. ಮೂಲ ಭಾಷೆಯಲ್ಲಿರುವ ಮೂಲ ದಸ್ತಾವೇಜನ್ನು ಅಧಿಕೃತ ಮೂಲವಾಗಿ ಪರಿಗಣಿಸಬೇಕು. ಮಹತ್ವದ ಮಾಹಿತಿಗಾಗಿ, ವೃತ್ತಿಪರ ಮಾನವ ಅನುವಾದವನ್ನು ಶಿಫಾರಸು ಮಾಡಲಾಗುತ್ತದೆ. ಈ ಅನುವಾದ ಬಳಕೆಯಿಂದ ಉಂಟಾಗುವ ಯಾವುದೇ ತಪ್ಪು ಅರ್ಥಮಾಡಿಕೊಳ್ಳುವಿಕೆ ಅಥವಾ ತಪ್ಪು ವಿವರಣೆಗಳಿಗೆ ನಾವು ಹೊಣೆಗಾರರಾಗುವುದಿಲ್ಲ.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->