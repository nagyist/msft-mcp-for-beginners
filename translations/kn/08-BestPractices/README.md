# MCP ಅಭಿವೃದ್ಧಿ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

[![MCP ಅಭಿವೃದ್ಧಿ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು](../../../translated_images/kn/09.d0f6d86c9d72134c.webp)](https://youtu.be/W56H9W7x-ao)

_(ಈ ಪಾಠದ ವಿಡಿಯೋವನ್ನು ನೋಡಲು ಮೇಲಿನ ಚಿತ್ರವನ್ನು ಕ್ಲಿಕ್ ಮಾಡಿ)_

## ಅವಲೋಕನ

ಈ ಪಾಠವು MCP ಸರ್ವರ್‌ಗಳು ಮತ್ತು ವೈಶಿಷ್ಟ್ಯಗಳನ್ನು ಉತ್ಪಾದನಾ ವಾತಾವರಣದಲ್ಲಿ ಅಭಿವೃದ್ಧಿ, ಪರೀಕ್ಷೆ ಮತ್ತು ನಿಯೋಜನೆಗಾಗಿ ಅಗ್ರಗણ್ಯ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳ ಮೇಲೆ ಕೇಂದ್ರೀಕರಿಸುತ್ತದೆ. MCP ಪರಿಸರಗಳು ಸಂಕೀರ್ಣತೆ ಮತ್ತು ಮಹತ್ವದಲ್ಲಿ ವೃದ್ಧಿಯಾಗುತ್ತಿರುವಂತೆ, ಸ್ಥಾಪಿತ ಮಾದರಿಗಳನ್ನು ಅನುಸರಿಸುವುದು ವಿಶ್ವಾಸಾರ್ಹತೆ, ನಿರ್ವಹಣೆಯ ಸುಲಭತೆ ಮತ್ತು ಅಂತರ್‌ಕ್ರಿಯಾಶೀಲತೆಯನ್ನು ಖಚಿತಪಡಿಸುತ್ತದೆ. ಈ ಪಾಠವು ನೈಜ ಜಗತ್ತಿನ MCP ಅನುಷ್ಠಾನಗಳಿಂದ ಪಡೆದ ವ್ಯಾಪಾರೀ ಜ್ಞಾನವನ್ನು ಸಮೂಹಗೊಳಿಸಿ ಪರಿಣಾಮಕಾರಿಯಾದ ಸಂಪನ್ಮೂಲಗಳು, ಪ್ರಾಂಪ್ಟ್‌ಗಳು ಮತ್ತು ಉಪಕರಣಗಳೊಂದಿಗೆ ದೃಢ, ಪರಿಣಾಮಕಾರಿ ಸರ್ವರ್‌ಗಳನ್ನು ರಚಿಸುವಲ್ಲಿ ನಿಮಗೆ ಮಾರ್ಗದರ್ಶನ ನೀಡುತ್ತದೆ.

## ಕಲಿಕೆ ಉದ್ದೇಶಗಳು

ಈ ಪಾಠದ ಕೊನೆಯಲ್ಲಿ, ನೀವು ಈ ಕೆಳಗಿನವರಿಗೆ ಸಾಮರ್ಥ್ಯ ಹೊಂದಿರುತ್ತೀರಿ:

- MCP ಸರ್ವರ್ ಮತ್ತು ವೈಶಿಷ್ಟ್ಯ ವಿನ್ಯಾಸದಲ್ಲಿ ಕೈಗಾರಿಕಾ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳನ್ನು ಅನ್ವಯಿಸುವುದು  
- MCP ಸರ್ವರ್‌ಗಳಿಗಾಗಿ ಸಮಗ್ರ ಪರೀಕ್ಷಾ ತಂತ್ರಗಳನ್ನು ರಚಿಸುವುದು  
- ಸಂಕೀರ್ಣ MCP ಅಪ್ಲಿಕೇಶನ್‌ಗಳಿಗೆ ಪರಿಣಾಮಕಾರಿ, ಮರುಬಳಕೆ ಮಾಡಬಹುದಾದ ವರ್ಕ್ಫ್ಲೋ ಮಾದರಿಗಳನ್ನು ವಿನ್ಯಾಸ ಮಾಡುವುದು  
- MCP ಸರ್ವರ್‌ಗಳಲ್ಲಿ ಸರியான ದೋಷ ನಿಭಾಯಣೆ, ಲಾಗಿಂಗ್ ಮತ್ತು ಅವಲೋಕನವನ್ನು ಜಾರಿಗೆ ತರುವುದು  
- ಕಾರ್ಯಕ್ಷಮತೆ, ಭದ್ರತೆ ಮತ್ತು ನಿರ್ವಹಣಾ ಸುಲಭತೆಯಿಗಾಗಿ MCP ಅನುಷ್ಠಾನಗಳನ್ನು ಅತ್ಯುತ್ತಮಗೊಳಿಸುವುದು  

## MCP ಮೂಲ ಸಿದ್ಧಾಂತಗಳು

ನಿರ್ದಿಷ್ಟ ಅನುಷ್ಠಾನ ಅಭ್ಯಾಸಗಳ ಕಡೆಗೆ ಆಳವಾಗಿ ಹೋಗುವ ಮೊದಲು, ಪರಿಣಾಮಕಾರಿ MCP ಅಭಿವೃದ್ಧಿಯನ್ನು ಮಾರ್ಗದರ್ಶಿಸುವ ಮೂಲ ಸಿದ್ಧಾಂತಗಳನ್ನು ತಿಳಿದುಕೊಳ್ಳುವುದು ಮುಖ್ಯ:

1. **ಮಾನಕೃತ ಸಂವಹನ**: MCP JSON-RPC 2.0 ಅನ್ನು ತನ್ನ ಆಧಾರವಾಗಿ ಬಳಸುತ್ತದೆ, ಇದು ಎಲ್ಲಾ ಅನುಷ್ಠಾನಗಳಲ್ಲಿ ವಿನಂತಿಗಳು, ಪ್ರತಿಕ್ರಿಯೆಗಳು ಮತ್ತು ದೋಷ ನಿರ್ವಹಣೆಗೆ ಸತತ ಮಾದರಿಯನ್ನು ಒದಗಿಸುತ್ತದೆ.

2. **ಬಳಕೆದಾರ ಕೇಂದ್ರಿತ ವಿನ್ಯಾಸ**: ನಿಮ್ಮ MCP ಅನುಷ್ಠಾನಗಳಲ್ಲಿ ಸದಾ ಬಳಕೆದಾರ ஒಕ್ಕೂ, ನಿಯಂತ್ರಣ ಮತ್ತು ಪಾರದರ್ಶಕತೆಯನ್ನು ಪ್ರಾಥಮ್ಯ ಮಿ೯ಡು.

3. **ಭದ್ರತೆ ಮೊದಲು**: ದೃಢ ಭದ್ರತಾ ಕ್ರಮಗಳನ್ನು ಜಾರಿಗೆ ತರಬೇಕು, ಅವುಗಳಲ್ಲಿ ಪರಿಶೀಲನೆ, ಪ್ರಾಧಿಕರಣ, ಮಾನ್ಯತೆ ಮತ್ತು ದರ ನಿಯಂತ್ರಣ ಸೇರಿವೆ.

4. **ಮಾಡ್ಯೂಲರ್ معمಾರ‌ಚೆ (ವಿನ್ಯಾಸ)**: ಪ್ರತಿಯೊಂದು ಉಪಕರಣ ಮತ್ತು ಸಂಪನ್ಮೂಲವು ಸ್ಪಷ್ಟ ಮತ್ತು ಕೇಂದ್ರೀಕೃತ ಉದ್ದೇಶ ಹೊಂದಿರುವಂತಿರಲಿ ಎಂದು ನಿಮ್ಮ MCP ಸರ್ವರ್‌ಗಳನ್ನು ಮಾಡ್ಯೂಲರ್ ಮೊದಲೋಗೆ ವಿನ್ಯಾಸಮಾಡಿ.

5. **ಸ್ಥಿತಿ ಹೊಂದಿದ ಸಂಪರ್ಕಗಳು**: ಚಿರಕಾಲಿಕ ಮತ್ತು ಸನಿಯೋಜಿತ ಸಂವಹನಕ್ಕಾಗಿ ಅನೇಕ ವಿನಂತಿಗಳ ನಡುವೆ ಸ್ಥಿತಿ ಉಳಿಸುವ MCP ಯಶಸ್ಸನ್ನು ಬಳಸಿ.

## ಅಧಿಕೃತ MCP ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

ಕೆಳಗಿನ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು ಅಧಿಕೃತ Model Context Protocol ದಾಖಲೆಗಳಿಂದ ಪಡೆದದ್ದಾಗಿದೆ:

### ಭದ್ರತೆ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

1. **ಬಳಕೆದಾರ ಒಕ್ಕೂಟ ಮತ್ತು ನಿಯಂತ್ರಣ**: ಡೇಟಾ ಪ್ರವೇಶಿಸುವ ಮೊದಲು ಅಥವಾ ಕಾರ್ಯಗಳನ್ನು ನಡೆದಿದೆ ಮುನ್ನ ಸ್ಪಷ್ಟ ಬಳಕೆದಾರ ಒಕ್ಕೂಟವನ್ನು ಸದಾ ಬೇಕಾಗುತ್ತದೆ. ಯಾವ ಡೇಟಾ ಹಂಚಿಕೊಳ್ಳಲಾಗುತ್ತದೆ ಮತ್ತು ಯಾವ ಕಾರ್ಯಗಳು ಅನುಮತಿಸಲ್ಪಡುತ್ತವೆ ಎಂಬುದರ ಮೇಲೆ ಸ್ಪಷ್ಟ ನಿಯಂತ್ರಣ ಒದಗಿಸಿ.

2. **ಡೇಟಾ ಗುಪ್ತತೆ**: ಬಳಕೆದಾರರ ಡೇಟಾವನ್ನು ಮಾತ್ರ ಸ್ಪಷ್ಟ ಒಕ್ಕೂಟದೊಂದಿಗೆ ಬಹಿರಂಗಪಡಿಸಿ ಮತ್ತು ಸೂಕ್ತ ಪ್ರವೇಶ ನಿಯಂತ್ರಣಗಳೊಂದಿಗೆ ರಕ್ಷಿಸಿ. ಅನುಮತಿಸದ ಡೇಟಾ ಪ್ರಸರಣವನ್ನು ತಡೆಹಿಡಿಯಿರಿ.

3. **ಉಪಕರಣ ಭದ್ರತೆ**: ಯಾವುದೇ ಉಪಕರಣವನ್ನು ಕರೆಸುವ ಮೊದಲು ಸ್ಪಷ್ಟ ಬಳಕೆದಾರ ಒಕ್ಕೂಟವನ್ನು ಬೇಕಾಗಿಸಿ. ಪ್ರತಿಯೊಂದು ಉಪಕರಣದ ಕಾರ್ಯತತೆಯನ್ನು ಬಳಕೆದಾರರು ಅರ್ಥಮಾಡಿಕೊಳ್ಳುವಂತೆ ಮಾಡಿ ಮತ್ತು ದೃಢ ಭದ್ರತಾ ಗಡಿಗಳನ್ನು ಜಾರಿಗೆ ಹರುಸಿ.

4. **ಉಪಕರಣ ಅನುಮತಿ ನಿಯಂತ್ರಣ**: ಸೆಷನ್ ಸಮಯದಲ್ಲಿ ಯಾವ ಉಪಕರಣಗಳು ಬಳಕೆಯಲ್ಲಿರಬೇಕು ಎಂಬುದನ್ನು ಸಂರಚಿಸಿ, ಭేదಬದ್ಧವಾಗಿದ್ದ ಉಪಕರಣಗಳನ್ನು ಮಾತ್ರ ಪ್ರವೇಶಿಸಿದ್ದರೆ.

5. **ಆಧಾರಪತ್ರಿಕರಣ**: ಉಪಕರಣಗಳು, ಸಂಪನ್ಮೂಲಗಳು ಅಥವಾ ಸಂವೇದನಾಶೀಲ ಕಾರ್ಯಗಳ ಪ್ರವೇಶಕ್ಕೆ ಸರಿಯಾದ ಪರಿಶೀಲನೆ ಮಾಡಬೇಕು, API ಕೀಗಳು, OAuth ಟೋಕನ್‌ಗಳು ಅಥವಾ ಇತರ ಭದ್ರತಾ ಪರಿಶೀಲನೆ ವಿಧಾನಗಳನ್ನು ಬಳಸಿಕೊಳ್ಲಿ.

6. **ಪರಿಮಾಣ ಪರಿಶೀಲನೆ**: ಎಲ್ಲಾ ಉಪಕರಣ ಕರೆಗಳಿಗೆ ಮಾನ್ಯತೆ ನೆರವೇರಿಸಿ, ಅಂತಹ ವಿಧಾನದಿಂದ ಕೆಟ್ಟದಾಗಿ ಅಥವಾ ಹಾನಿಕರವಾಗಿ ರೂಪುಗೊಂಡ ಇನ್ ಪುಟ್‌ಗಳು ಉಪಕರಣ ಅನುಷ್ಠಾನಗಳ ತಲುಪದೇ ಇರಲಿ.

7. **ದರ ನಿಯಂತ್ರಣ**: ದರ ನಿಯಂತ್ರಣ ಜಾರಿಗೆ ತರುವ ಮೂಲಕ ದುರ್ಬಳಕೆಯಿಂದ ತಪ್ಪಿಸಿ ಹಾಗೂ ಸರ್ವರ್ ಸಂಪನ್ಮೂಲಗಳ ಸಮತೋಲನ ಬಳಕೆಯನ್ನು ಖಚಿತಪಡಿಸಿ.

### ಅನುಷ್ಠಾನ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

1. **ಸಾಧ್ಯತೆ ನಿಗೋಳಿಕೆ**: ಸಂಪರ್ಕ ಸ್ಥಾಪನೆ ಸಮಯದಲ್ಲಿ ಬೆಂಬಳಿಸಿದ ವೈಶಿಷ್ಟ್ಯಗಳು, ಪ್ರೋಟೋಕಾಲ್ ಆವೃತ್ತಿಗಳು, ಲಭ್ಯವಿರುವ ಉಪಕರಣಗಳು ಮತ್ತು ಸಂಪನ್ಮೂಲಗಳ ಬಗ್ಗೆ ಮಾಹಿತಿ ಹಂಚಿಕೊಳ್ಳಿ.

2. **ಉಪಕರಣ ವಿನ್ಯಾಸ**: ಒಗ್ಗಟ್ಟಾದ ಹಲವು ವಿಷಯಗಳನ್ನು ಹತ್ತಿಕ್ಕುವ ಬದಲು ಒಬ್ಬೊಮ್ಮೆ ಉತ್ತಮವಾಗಿ ಕಾರ್ಯನಿರ್ವಹಿಸುವ ಕೇಂದ್ರೀಕೃತ ಉಪಕರಣಗಳನ್ನು ರಚಿಸಿ.

3. **ದೋಷ ನಿರ್ವಹಣೆ**: ಸಮಸ್ಯೆ ಗುರುತಿಸಲು, ವೈಫಲ್ಯಗಳನ್ನು ಶ್ರದ್ಧೆಯಿಂದ ನಿಭಾಯಿಸಲು ಮತ್ತು ಪ್ರಯೋುಕ್ತ ಆಧಾರಿತ ಪ್ರತಿಕ್ರಿಯೆಯನ್ನು ಒದಗಿಸಲು ಮಾನಕೃತ ದೋಷ ಸಂದೇಶಗಳು ಮತ್ತು ಕೋಡ್‌ಗಳನ್ನು ಜಾರಿಗೆ ತರಬೇಕು.

4. **ಲಾಗಿಂಗ್**: ಪ್ರೋಟೋಕಾಲ್ ಸಂವಹನಗಳಿಗಾಗಿ ಲಾಯಚತರ ಕಾರ್ಯಗಳ ಪಟ್ಟಿ, ಡಿಬಗ್ಗಿಂಗ್ ಮತ್ತು ಮೇಲ್ವಿಚಾರಣೆಗೆ ರಚಣೆಕೃತ ಲಾಗ್‌ಗಳನ್ನು ಸಂರಚಿಸಿ.

5. **ಪ್ರಗತಿ ಅನುಸರಣೆ**: ದೀರ್ಘಾವಧಿ ಕಾರ್ಯಗಳಿಗಾಗಿ ಪ್ರಗತಿ ನವೀಕರಣಗಳನ್ನು ವರದಿ ಮಾಡಿತುಂಬಿಕೆಯಂತಿರುವ ಬಳಕೆದಾರ ಇಂಟರ್‌ಫೇಸ್ಗಳನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಿ.

6. **ವಿನಂತಿ ರದ್ದುಪಡಿಸುವಿಕೆ**: ಅಗತ್ಯವಿಲ್ಲದೆ ಅಥವಾ ಹೆಚ್ಚು ಸಮಯ ತೆಗೆದುಕೊಳ್ಳುತ್ತಿರುವ ವಿಮಾನದಲ್ಲಿನ ವಿನಂತಿಗಳನ್ನು ಕ್ಲಯಿಂಟ್‌ಗಳಿಗೆ ರದ್ದುಪಡಿಸುವ ಅವಕಾಶ ನೀಡಿ.

## ಹೆಚ್ಚುವರಿ ಉಲ್ಲೇಖಗಳು

MCP ಉತ್ತಮ ಅಭ್ಯಾಸಗಳ ಗತಿಸ್ಥಿತಿಗೆ ಕುರಿತು ನೋಡಲು, ಈ ಕೆಳಗಿನನ್ನು ನೋಡಿ:

- [MCP ದಾಖಲೆ](https://modelcontextprotocol.io/)
- [MCP விவரம் (2025-11-25)](https://spec.modelcontextprotocol.io/specification/2025-11-25/)
- [GitHub ಸಂಗ್ರಹಾಲಯ](https://github.com/modelcontextprotocol)
- [ಭದ್ರತೆ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು](https://modelcontextprotocol.io/specification/draft/basic/security_best_practices)
- [OWASP MCP ಟಾಪ್ 10](https://microsoft.github.io/mcp-azure-security-guide/mcp/) - ಭದ್ರತಾ ಅಪಾಯಗಳು ಮತ್ತು ನಿವಾರಣೆಗಳು
- [MCP ಭದ್ರತಾ ಸಮ್ಮೇಳನ ವರ್ಕ್ಶಾಪ್ (ಶೆರ্প)](https://azure-samples.github.io/sherpa/) - ಕೈಗಳಿಂದ ಮಾಡಿದ ಭದ್ರತಾ ತರಬೆತಿ

## ವ್ಯವಹಾರಿಕ ಅನುಷ್ಠಾನ ಉದಾಹರಣೆಗಳು

### ಉಪಕರಣ ವಿನ್ಯಾಸ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

#### 1. ಏಕ ಜವಾಬ್ದಾರಿ ತತ್ವ

ಪ್ರತಿ MCP ಉಪಕರಣವು ಸ್ಪಷ್ಟ ಮತ್ತು ಕೇಂದ್ರೀಕೃತ ಉದ್ದೇಶ ಹೊಂದಿರಬೇಕು. ಬಹುಮುಖ ಸಮಸ್ಯೆಗಳನ್ನು ನಿಭಾಯಿಸುವ ಒಗ್ಗಟ್ಟಾದ ಉಪಕರಣಗಳನ್ನು ಸೃಷ್ಟಿಸುವ ಬದಲಿಗೆ, ನಿರ್ದಿಷ್ಟ ಕಾರ್ಯಗಳಲ್ಲಿ ಪರಿಣತ ಇರುವ ವಿಶೇಷ ಉಪಕರಣಗಳನ್ನು ಅಭಿವೃದ್ಧಿಪಡಿಸಿ.

```csharp
// A focused tool that does one thing well
public class WeatherForecastTool : ITool
{
    private readonly IWeatherService _weatherService;
    
    public WeatherForecastTool(IWeatherService weatherService)
    {
        _weatherService = weatherService;
    }
    
    public string Name => "weatherForecast";
    public string Description => "Gets weather forecast for a specific location";
    
    public ToolDefinition GetDefinition()
    {
        return new ToolDefinition
        {
            Name = Name,
            Description = Description,
            Parameters = new Dictionary<string, ParameterDefinition>
            {
                ["location"] = new ParameterDefinition
                {
                    Type = ParameterType.String,
                    Description = "City or location name"
                },
                ["days"] = new ParameterDefinition
                {
                    Type = ParameterType.Integer,
                    Description = "Number of forecast days",
                    Default = 3
                }
            },
            Required = new[] { "location" }
        };
    }
    
    public async Task<ToolResponse> ExecuteAsync(IDictionary<string, object> parameters)
    {
        var location = parameters["location"].ToString();
        var days = parameters.ContainsKey("days") 
            ? Convert.ToInt32(parameters["days"]) 
            : 3;
            
        var forecast = await _weatherService.GetForecastAsync(location, days);
        
        return new ToolResponse
        {
            Content = new List<ContentItem>
            {
                new TextContent(JsonSerializer.Serialize(forecast))
            }
        };
    }
}
```

#### 2. ಸಮನ್ವಿತ ದೋಷ ನಿರ್ವಹಣೆ

ಸಮಗ್ರ ದೋಷ ನಿರ್ವಹಣೆಯನ್ನು ಪರಿಚಯಿಸಿ, ವಿವರವಾದ ದೋಷ ಸಂದೇಶಗಳು ಮತ್ತು ಸೂಕ್ತ ಮರುಹರಿವು ಯಂತ್ರಾಂಗಗಳನ್ನು ಹೊಂದಿರಲಿ.

```python
# ಸಮಗ್ರ ದೋಷ ಸಂಭಾಳನೆಯೊಂದಿಗೆ ಪೈಥಾನ್ ಉದಾಹರಣೆ
class DataQueryTool:
    def get_name(self):
        return "dataQuery"
        
    def get_description(self):
        return "Queries data from specified database tables"
    
    async def execute(self, parameters):
        try:
            # ಪ್ಯಾರಾಮೀಟರ್ ಮಾನ್ಯತೆ
            if "query" not in parameters:
                raise ToolParameterError("Missing required parameter: query")
                
            query = parameters["query"]
            
            # ಭದ್ರತಾ ಮಾನ್ಯತೆ
            if self._contains_unsafe_sql(query):
                raise ToolSecurityError("Query contains potentially unsafe SQL")
            
            try:
                # ಟೈಮೌಟ್‌తో ಡೇಟಾಬೇಸ್ ಕಾರ್ಯಾಚರಣೆ
                async with timeout(10):  # 10 ಸೆಕೆಂಡ್ ಟೈಮೌಟ್
                    result = await self._database.execute_query(query)
                    
                return ToolResponse(
                    content=[TextContent(json.dumps(result))]
                )
            except asyncio.TimeoutError:
                raise ToolExecutionError("Database query timed out after 10 seconds")
            except DatabaseConnectionError as e:
                # ಸಂಪರ್ಕ ದೋಷಗಳು ತಾತ್ಕಾಲಿಕವಾಗಿರಬಹುದು
                self._log_error("Database connection error", e)
                raise ToolExecutionError(f"Database connection error: {str(e)}")
            except DatabaseQueryError as e:
                # ಪ್ರಶ್ನೆ ದೋಷಗಳು ಸಾಮಾನ್ಯವಾಗಿ ಗ್ರಾಹಕರ ದೋಷಗಳಾಗಿರುತ್ತವೆ
                self._log_error("Database query error", e)
                raise ToolExecutionError(f"Invalid query: {str(e)}")
                
        except ToolError:
            # ಉಪಕರಣ-ನಿರ್ದಿಷ್ಟ ದೋಷಗಳನ್ನು ಹಾದುಹೋಗಲು ಬಿಡಿ
            raise
        except Exception as e:
            # ಅಪ್ರತೀಕ್ಷಿತ ದೋಷಗಳಿಗಾಗಿ ಸರ್ವಕ್ಷಣ ಹಿಡಿತ
            self._log_error("Unexpected error in DataQueryTool", e)
            raise ToolExecutionError(f"An unexpected error occurred: {str(e)}")
    
    def _contains_unsafe_sql(self, query):
        # SQL ಇಂಜೆಕ್ಷನ್ ಪತ್ತೆಹಚ್ಚುವಿಕೆಯ ಜಾರಿಗೊಳಿಸುವಿಕೆ
        pass
        
    def _log_error(self, message, error):
        # ದೋಷ ಲಾಗಿಂಗಿನ ಜಾರಿಗೊಳಿಸುವಿಕೆ
        pass
```

#### 3. ಪರಿಮಾಣ ಪರಿಶೀಲನೆ

ಎಂದೆಂದಿಗೂ ಪರಿಮಾಣಗಳನ್ನು ಸಂಪೂರ್ಣವಾಗಿ ಪರಿಶೀಲಿಸಿ, ಕೆಟ್ಟ ರೂಪುಗೊಂಡ ಅಥವಾ ಹಾನಿಕರ ಇನ್ ಪುಟ್‌ಗಳು ತಲುಪದಂತೆ ಮಾಡಿ.

```javascript
// JavaScript/TypeScript ಉದಾಹರಣೆ ವಿವರವಾದ ಪ್ಯಾರಾಮೀಟರ್ ಮಾನ್ಯತೆಗಳೊಂದಿಗೆ
class FileOperationTool {
  getName() {
    return "fileOperation";
  }
  
  getDescription() {
    return "Performs file operations like read, write, and delete";
  }
  
  getDefinition() {
    return {
      name: this.getName(),
      description: this.getDescription(),
      parameters: {
        operation: {
          type: "string",
          description: "Operation to perform",
          enum: ["read", "write", "delete"]
        },
        path: {
          type: "string",
          description: "File path (must be within allowed directories)"
        },
        content: {
          type: "string",
          description: "Content to write (only for write operation)",
          optional: true
        }
      },
      required: ["operation", "path"]
    };
  }
  
  async execute(parameters) {
    // 1. ಪ್ಯಾರಾಮೀಟರ್ ಇದ್ದಿರುವುದನ್ನು ಮಾನ್ಯಗೊಳಿಸಿ
    if (!parameters.operation) {
      throw new ToolError("Missing required parameter: operation");
    }
    
    if (!parameters.path) {
      throw new ToolError("Missing required parameter: path");
    }
    
    // 2. ಪ್ಯಾರಾಮೀಟರ್ ಪ್ರಕಾರಗಳನ್ನು ಮಾನ್ಯಗೊಳಿಸಿ
    if (typeof parameters.operation !== "string") {
      throw new ToolError("Parameter 'operation' must be a string");
    }
    
    if (typeof parameters.path !== "string") {
      throw new ToolError("Parameter 'path' must be a string");
    }
    
    // 3. ಪ್ಯಾರಾಮೀಟರ್ ಮೌಲ್ಯಗಳನ್ನು ಮಾನ್ಯಗೊಳಿಸಿ
    const validOperations = ["read", "write", "delete"];
    if (!validOperations.includes(parameters.operation)) {
      throw new ToolError(`Invalid operation. Must be one of: ${validOperations.join(", ")}`);
    }
    
    // 4. ಬರೆಯುವ ಕಾರ್ಯಕ್ಕಾಗಿ ವಿಷಯದ ಸಾನ್ನಿಧ್ಯವನ್ನು ಮಾನ್ಯಗೊಳಿಸಿ
    if (parameters.operation === "write" && !parameters.content) {
      throw new ToolError("Content parameter is required for write operation");
    }
    
    // 5. ಪಥ ಸುರಕ್ಷತೆಯ ಮಾನ್ಯತೆ
    if (!this.isPathWithinAllowedDirectories(parameters.path)) {
      throw new ToolError("Access denied: path is outside of allowed directories");
    }
    
    // ಮಾನ್ಯಗೊಂಡ ಪ್ಯಾರಾಮೀಟರ್ ಆಧಾರಿತ ಜಾರಿಗೊಳಿಸುವಿಕೆ
    // ...
  }
  
  isPathWithinAllowedDirectories(path) {
    // ಪಥ ಸುರಕ್ಷತಾ ಪರಿಶೋಧನೆಯ ಜಾರಿಗೊಳಿಸುವಿಕೆ
    // ...
  }
}
```

### ಭದ್ರತಾ ಅನುಷ್ಠಾನ ಉದಾಹರಣೆಗಳು

#### 1. ಪರಿಶೀಲನೆ ಮತ್ತು ಪ್ರಾಧಿಕರಣ

```java
// ಪ್ರಮಾಣೀಕರಣ ಮತ್ತು ಅನುಮೋದನೆ ಸಹಿತ ಜಾವಾ ಉದಾಹರಣೆ
public class SecureDataAccessTool implements Tool {
    private final AuthenticationService authService;
    private final AuthorizationService authzService;
    private final DataService dataService;
    
    // ಅವಲಂಬನೆerಾದಾಯ
    public SecureDataAccessTool(
            AuthenticationService authService,
            AuthorizationService authzService,
            DataService dataService) {
        this.authService = authService;
        this.authzService = authzService;
        this.dataService = dataService;
    }
    
    @Override
    public String getName() {
        return "secureDataAccess";
    }
    
    @Override
    public ToolResponse execute(ToolRequest request) {
        // 1. ಪ್ರಮಾಣೀಕರಣ ಪುಟಕೆಳೆಯಿರಿ
        String authToken = request.getContext().getAuthToken();
        
        // 2. ಬಳಕೆದಾರರನ್ನು ಪ್ರಮಾಣೀಕರಿಸಿ
        UserIdentity user;
        try {
            user = authService.validateToken(authToken);
        } catch (AuthenticationException e) {
            return ToolResponse.error("Authentication failed: " + e.getMessage());
        }
        
        // 3. ನಿರ್ದಿಷ್ಟ ಕಾರ್ಯಕ್ಕಾಗಿ ಅನುಮೋದನೆ ಪರಿಶೀಲಿಸಿ
        String dataId = request.getParameters().get("dataId").getAsString();
        String operation = request.getParameters().get("operation").getAsString();
        
        boolean isAuthorized = authzService.isAuthorized(user, "data:" + dataId, operation);
        if (!isAuthorized) {
            return ToolResponse.error("Access denied: Insufficient permissions for this operation");
        }
        
        // 4. ಅನುಮೋದಿತ ಕಾರ್ಯವನ್ನು ಮುಂದುವರಿಸಿ
        try {
            switch (operation) {
                case "read":
                    Object data = dataService.getData(dataId, user.getId());
                    return ToolResponse.success(data);
                case "update":
                    JsonNode newData = request.getParameters().get("newData");
                    dataService.updateData(dataId, newData, user.getId());
                    return ToolResponse.success("Data updated successfully");
                default:
                    return ToolResponse.error("Unsupported operation: " + operation);
            }
        } catch (Exception e) {
            return ToolResponse.error("Operation failed: " + e.getMessage());
        }
    }
}
```

#### 2. ದರ ನಿಯಂತ್ರಣ

```csharp
// C# rate limiting implementation
public class RateLimitingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IMemoryCache _cache;
    private readonly ILogger<RateLimitingMiddleware> _logger;
    
    // Configuration options
    private readonly int _maxRequestsPerMinute;
    
    public RateLimitingMiddleware(
        RequestDelegate next,
        IMemoryCache cache,
        ILogger<RateLimitingMiddleware> logger,
        IConfiguration config)
    {
        _next = next;
        _cache = cache;
        _logger = logger;
        _maxRequestsPerMinute = config.GetValue<int>("RateLimit:MaxRequestsPerMinute", 60);
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        // 1. Get client identifier (API key or user ID)
        string clientId = GetClientIdentifier(context);
        
        // 2. Get rate limiting key for this minute
        string cacheKey = $"rate_limit:{clientId}:{DateTime.UtcNow:yyyyMMddHHmm}";
        
        // 3. Check current request count
        if (!_cache.TryGetValue(cacheKey, out int requestCount))
        {
            requestCount = 0;
        }
        
        // 4. Enforce rate limit
        if (requestCount >= _maxRequestsPerMinute)
        {
            _logger.LogWarning("Rate limit exceeded for client {ClientId}", clientId);
            
            context.Response.StatusCode = StatusCodes.Status429TooManyRequests;
            context.Response.Headers.Add("Retry-After", "60");
            
            await context.Response.WriteAsJsonAsync(new
            {
                error = "Rate limit exceeded",
                message = "Too many requests. Please try again later.",
                retryAfterSeconds = 60
            });
            
            return;
        }
        
        // 5. Increment request count
        _cache.Set(cacheKey, requestCount + 1, TimeSpan.FromMinutes(2));
        
        // 6. Add rate limit headers
        context.Response.Headers.Add("X-RateLimit-Limit", _maxRequestsPerMinute.ToString());
        context.Response.Headers.Add("X-RateLimit-Remaining", (_maxRequestsPerMinute - requestCount - 1).ToString());
        
        // 7. Continue with the request
        await _next(context);
    }
    
    private string GetClientIdentifier(HttpContext context)
    {
        // Implementation to extract API key or user ID
        // ...
    }
}
```

## ಪರೀಕ್ಷಾ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

### 1. ಘಟಕ ಪರೀಕ್ಷೆ MCP ಉಪಕರಣಗಳು

ನಿಮ್ಮ ಉಪಕರಣಗಳನ್ನು ನಿರ್ದಿಷ್ಟವಾಗಿ ಪರೀಕ್ಷಿಸಿ, ಬಾಹ್ಯ ಅವಲಂಬನೆಗಳನ್ನು ಮಾಕ್ ಮಾಡಿ:

```typescript
// TypeScript ಉಪಕರಣ ಘಟಕ ಪರೀಕ್ಷೆಯ ಉದಾಹರಣೆ
describe('WeatherForecastTool', () => {
  let tool: WeatherForecastTool;
  let mockWeatherService: jest.Mocked<IWeatherService>;
  
  beforeEach(() => {
    // ನಕಲಿ ಹವಾಮಾನ ಸೇವೆಯನ್ನು ರಚಿಸಿ
    mockWeatherService = {
      getForecasts: jest.fn()
    } as any;
    
    // ನಕಲಿ ಅವಲಂಬನೆಯೊಂದಿಗೆ ಉಪಕರಣವನ್ನು ರಚಿಸಿ
    tool = new WeatherForecastTool(mockWeatherService);
  });
  
  it('should return weather forecast for a location', async () => {
    // ವ್ಯವಸ್ಥೆ ಮಾಡು
    const mockForecast = {
      location: 'Seattle',
      forecasts: [
        { date: '2025-07-16', temperature: 72, conditions: 'Sunny' },
        { date: '2025-07-17', temperature: 68, conditions: 'Partly Cloudy' },
        { date: '2025-07-18', temperature: 65, conditions: 'Rain' }
      ]
    };
    
    mockWeatherService.getForecasts.mockResolvedValue(mockForecast);
    
    // ಕಾರ್ಯ ನಿರ್ವಹಿಸು
    const response = await tool.execute({
      location: 'Seattle',
      days: 3
    });
    
    // ದೃಢೀಕರಿಸು
    expect(mockWeatherService.getForecasts).toHaveBeenCalledWith('Seattle', 3);
    expect(response.content[0].text).toContain('Seattle');
    expect(response.content[0].text).toContain('Sunny');
  });
  
  it('should handle errors from the weather service', async () => {
    // ವ್ಯವಸ್ಥೆ ಮಾಡು
    mockWeatherService.getForecasts.mockRejectedValue(new Error('Service unavailable'));
    
    // ಕಾರ್ಯ ನಿರ್ವಹಿಸಿ ಮತ್ತು ದೃಢೀಕರಿಸು
    await expect(tool.execute({
      location: 'Seattle',
      days: 3
    })).rejects.toThrow('Weather service error: Service unavailable');
  });
});
```

### 2. ಸಂಯೋಜನೆ ಪರೀಕ್ಷೆ

ಗ್ರಾಹಕ ವಿನಂತಿಗಳಿಂದ ಸರ್ವರ್ ಪ್ರತಿಕ್ರಿಯೆಗಳವರೆಗೆ ಸಂಪೂರ್ಣ ಪ್ರಕ್ರಿಯೆಯನ್ನು ಪರೀಕ್ಷಿಸಿ:

```python
# ಪೈಥಾನ್ ಇಂಟಿಗ್ರೇಶನ್ ಟೆಸ್ಟ್ ಉದಾಹರಣೆ
@pytest.mark.asyncio
async def test_mcp_server_integration():
    # ಟೆಸ್ಟ್ ಸರ್ವರನ್ನು ಪ್ರಾರಂಭಿಸಿ
    server = McpServer()
    server.register_tool(WeatherForecastTool(MockWeatherService()))
    await server.start(port=5000)
    
    try:
        # ಕ್ಲೈಂಟ್ ಅನ್ನು ರಚಿಸಿ
        client = McpClient("http://localhost:5000")
        
        # ಟೂಲ್ ಕಂಡುಹಿಡಿಯುವಿಕೆಯನ್ನು ಪರೀಕ್ಷಿಸಿ
        tools = await client.discover_tools()
        assert "weatherForecast" in [t.name for t in tools]
        
        # ಟೂಲ್ ನಿರ್ವಹಣೆಯನ್ನು ಪರೀಕ್ಷಿಸಿ
        response = await client.execute_tool("weatherForecast", {
            "location": "Seattle",
            "days": 3
        })
        
        # ಪ್ರತಿಕ್ರಿಯೆಯನ್ನು ಪರಿಶೀಲಿಸಿ
        assert response.status_code == 200
        assert "Seattle" in response.content[0].text
        assert len(json.loads(response.content[0].text)["forecasts"]) == 3
        
    finally:
        # ಸ್ವಚ್ಛಗೊಳಿಸಿ
        await server.stop()
```

## ಕಾರ್ಯಕ್ಷಮತೆ ಉತ್ತಮಗೊಳಿಸುವಿಕೆ

### 1. ಕ್ಯಾಚಿಂಗ್ ಯುಕ್ತಿಗಳು

ಕಡಿಮೆ ವಿಳಂಬ ಮತ್ತು ಸಂಪನ್ಮೂಲ ಬಳಕೆಯನ್ನುನುಮಿಸಲು ಸೂಕ್ತ ಕ್ಯಾಚಿಂಗ್ ನ್ನು ಜಾರಿಗೆ ತರಲು:

```csharp
// C# example with caching
public class CachedWeatherTool : ITool
{
    private readonly IWeatherService _weatherService;
    private readonly IDistributedCache _cache;
    private readonly ILogger<CachedWeatherTool> _logger;
    
    public CachedWeatherTool(
        IWeatherService weatherService,
        IDistributedCache cache,
        ILogger<CachedWeatherTool> logger)
    {
        _weatherService = weatherService;
        _cache = cache;
        _logger = logger;
    }
    
    public string Name => "weatherForecast";
    
    public async Task<ToolResponse> ExecuteAsync(IDictionary<string, object> parameters)
    {
        var location = parameters["location"].ToString();
        var days = Convert.ToInt32(parameters.GetValueOrDefault("days", 3));
        
        // Create cache key
        string cacheKey = $"weather:{location}:{days}";
        
        // Try to get from cache
        string cachedForecast = await _cache.GetStringAsync(cacheKey);
        if (!string.IsNullOrEmpty(cachedForecast))
        {
            _logger.LogInformation("Cache hit for weather forecast: {Location}", location);
            return new ToolResponse
            {
                Content = new List<ContentItem>
                {
                    new TextContent(cachedForecast)
                }
            };
        }
        
        // Cache miss - get from service
        _logger.LogInformation("Cache miss for weather forecast: {Location}", location);
        var forecast = await _weatherService.GetForecastAsync(location, days);
        string forecastJson = JsonSerializer.Serialize(forecast);
        
        // Store in cache (weather forecasts valid for 1 hour)
        await _cache.SetStringAsync(
            cacheKey,
            forecastJson,
            new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1)
            });
        
        return new ToolResponse
        {
            Content = new List<ContentItem>
            {
                new TextContent(forecastJson)
            }
        };
    }
}
```

#### 2. ಅವಲಂಬನೆ ಇಂಜೆಕ್ಷನ್ ಮತ್ತು ಪರೀಕ್ಷಾ ಸಾಮರ್ಥ್ಯ

ಕನ್ಸ್ಟ್ರಕ್ಟರ್ ಇಂಜೆಕ್ಷನ್ ಮೂಲಕ ಅವಲಂಬನೆಗಳನ್ನು ಪಡೆದು ಉಪಕರಣಗಳನ್ನು ಪರೀಕ್ಷಾಸಾಧ್ಯ ಮತ್ತು ಸಂರಚನೀಯಗೊಳಿಸಿ:

```java
// ಅಳತೆ ಸುತ್ತುಗುಂಡಿನೊಂದಿಗೆ ಜಾವಾ ಉದಾಹರಣೆ
public class CurrencyConversionTool implements Tool {
    private final ExchangeRateService exchangeService;
    private final CacheService cacheService;
    private final Logger logger;
    
    // ಸಂರಚನೆಯ ಮೂಲಕ ಒಳಸೇರಿಸಲಾದ ಅವಲಂಬನೆಗಳು
    public CurrencyConversionTool(
            ExchangeRateService exchangeService,
            CacheService cacheService,
            Logger logger) {
        this.exchangeService = exchangeService;
        this.cacheService = cacheService;
        this.logger = logger;
    }
    
    // ಸಾಧನ ಅನ್ವಯಿಕೆ
    // ...
}
```

#### 3. ಸಂಯೋಜನೀಯ ಉಪಕರಣಗಳು

ಬಹುಮುಖ ವರ್ಕ್ಫ್ಲೋಗಳನ್ನು ರಚಿಸಲು ಸಂಯೋಜಿಸಲು ಒಪ್ಪಿಗೆಯಾದ ಉಪಕರಣಗಳನ್ನು ವಿನ್ಯಾಸ ಮಾಡಿ:

```python
# ಸಂಯೋಜಿಸಲಾಗಬಹುದಾದ ಸಾಧನಗಳನ್ನು ತೋರಿಸುವ ಪೈಥಾನ್ ಉದಾಹರಣೆ
class DataFetchTool(Tool):
    def get_name(self):
        return "dataFetch"
    
    # ಕಾರ್ಯತರ್ಪಣೆ...

class DataAnalysisTool(Tool):
    def get_name(self):
        return "dataAnalysis"
    
    # ಈ ಸಾಧನವು dataFetch ಸಾಧನದಿಂದ ಫಲಿತಾಂಶಗಳನ್ನು ಬಳಸಬಹುದು
    async def execute_async(self, request):
        # ಕಾರ್ಯತರ್ಪಣೆ...
        pass

class DataVisualizationTool(Tool):
    def get_name(self):
        return "dataVisualize"
    
    # ಈ ಸಾಧನವು dataAnalysis ಸಾಧನದಿಂದ ಫಲಿತಾಂಶಗಳನ್ನು ಬಳಸಬಹುದು
    async def execute_async(self, request):
        # ಕಾರ್ಯತರ್ಪಣೆ...
        pass

# ಈ ಸಾಧನಗಳನ್ನು ಸ್ವತಂತ್ರವಾಗಿ ಅಥವಾ ಕೆಲಸದ ಪ್ರಕ್ರಿಯೆಯ ಭಾಗವಾಗಿ ಬಳಸಬಹುದು
```

### ಸ್ಕೀಮಾ ವಿನ್ಯಾಸ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

ಸ್ಕೀಮಾ ಮಾದರಿಯೊಂದಿಗೆ ನಿಮ್ಮ ಉಪಕರಣದ ಗುತ್ತಿಗೆ. ಚೆನ್ನಾಗಿ ವಿನ್ಯಾಸ ಮಾಡಿದ ಸ್ಕೀಮಾಗಳು ಉಪಕರಣದ ಬಳಕೆಯನ್ನು ಸುಗಮಗೊಳಿಸುತ್ತವೆ.

#### 1. ಸ್ಪಷ್ಟ ಪರಿಮಾಣ ವಿವರಣೆಗಳು

ಪ್ರತಿ ಪರಿಮಾಣಕ್ಕೂ ವಿವರಣಾತ್ಮಕ ಮಾಹಿತಿಯನ್ನು ಸೇರಿಸಿ:

```csharp
public object GetSchema()
{
    return new {
        type = "object",
        properties = new {
            query = new { 
                type = "string", 
                description = "Search query text. Use precise keywords for better results." 
            },
            filters = new {
                type = "object",
                description = "Optional filters to narrow down search results",
                properties = new {
                    dateRange = new { 
                        type = "string", 
                        description = "Date range in format YYYY-MM-DD:YYYY-MM-DD" 
                    },
                    category = new { 
                        type = "string", 
                        description = "Category name to filter by" 
                    }
                }
            },
            limit = new { 
                type = "integer", 
                description = "Maximum number of results to return (1-50)",
                default = 10
            }
        },
        required = new[] { "query" }
    };
}
```

#### 2. ಮಾನ್ಯತಾ ನಿಯಮಗಳು

ಅಮಾನ್ಯವಾದ ಇನ್ ಪುಟ್‌ಗಳನ್ನು ತಡೆಗಟ್ಟಲು ಮಾನ್ಯತಾ ನಿಯಮಗಳನ್ನು ಸೇರಿಸಿ:

```java
Map<String, Object> getSchema() {
    Map<String, Object> schema = new HashMap<>();
    schema.put("type", "object");
    
    Map<String, Object> properties = new HashMap<>();
    
    // ಇಮೇಲ್ ಗುಣಲಕ್ಷಣವು ಸ್ವರೂಪ ಮಾನ್ಯತೆ ಹೊಂದಿದೆ
    Map<String, Object> email = new HashMap<>();
    email.put("type", "string");
    email.put("format", "email");
    email.put("description", "User email address");
    
    // ಸಂಖ್ಯೆಯ ಮಿತಿ ಹೊಂದಿರುವ ವಯಸ್ಸು ಗುಣಲಕ್ಷಣ
    Map<String, Object> age = new HashMap<>();
    age.put("type", "integer");
    age.put("minimum", 13);
    age.put("maximum", 120);
    age.put("description", "User age in years");
    
    // ಎನ್ಯೂಮೆರೇಟೆಡ್ ಗುಣಲಕ್ಷಣ
    Map<String, Object> subscription = new HashMap<>();
    subscription.put("type", "string");
    subscription.put("enum", Arrays.asList("free", "basic", "premium"));
    subscription.put("default", "free");
    subscription.put("description", "Subscription tier");
    
    properties.put("email", email);
    properties.put("age", age);
    properties.put("subscription", subscription);
    
    schema.put("properties", properties);
    schema.put("required", Arrays.asList("email"));
    
    return schema;
}
```

#### 3. ಸಕಲ ಪ್ರತಿಕ್ರಿಯೆ ರಚನೆಗಳು

ಮಾದರಿಗಳಿಗೆ ಫಲಿತಾಂಶಗಳನ್ನು ಸುಲಭವಾಗಿ ಅರ್ಥಮಾಡಿಕೊಳ್ಳಲು ಪ್ರತಿಕ್ರಿಯೆಗಳು ಸತತವಾಗಿರಲಿ:

```python
async def execute_async(self, request):
    try:
        # ವಿನಂತಿಯನ್ನು ಪ್ರಕ್ರಿಯೆ ಮಾಡು
        results = await self._search_database(request.parameters["query"])
        
        # ಯಾವಾಗಲೂ ಸತತ ರೂಪರೇಖೆಯನ್ನು ಹಿಂತಿರುಗಿಸಿ
        return ToolResponse(
            result={
                "matches": [self._format_item(item) for item in results],
                "totalCount": len(results),
                "queryTime": calculation_time_ms,
                "status": "success"
            }
        )
    except Exception as e:
        return ToolResponse(
            result={
                "matches": [],
                "totalCount": 0,
                "queryTime": 0,
                "status": "error",
                "error": str(e)
            }
        )
    
def _format_item(self, item):
    """Ensures each item has a consistent structure"""
    return {
        "id": item.id,
        "title": item.title,
        "summary": item.summary[:100] + "..." if len(item.summary) > 100 else item.summary,
        "url": item.url,
        "relevance": item.score
    }
```

### ದೋಷ ನಿರ್ವಹಣೆ

ನಿರ್ವಹಣಾ ಸಾಮರ್ಥ್ಯವನ್ನು ಕಾಯ್ಕೊಳ್ಳಲು MCP ಉಪಕರಣಗಳಿಗೆ ಸಮಗ್ರ ದೋಷ ನಿರ್ವಹಣೆ ಅವಶ್ಯಕ.

#### 1. ಮೃದು ದೋಷ ನಿರ್ವಹಣೆ

ಸರಿಯಾದ ಮಟ್ಟಗಳಲ್ಲಿ ದೋಷಗಳನ್ನು ನಿಭಾಯಿಸಿ ಮತ್ತು ವಿವರವಾದ ಸಂದೇಶಗಳನ್ನು ಒದಗಿಸಿ:

```csharp
public async Task<ToolResponse> ExecuteAsync(ToolRequest request)
{
    try
    {
        string fileId = request.Parameters.GetProperty("fileId").GetString();
        
        try
        {
            var fileData = await _fileService.GetFileAsync(fileId);
            return new ToolResponse { 
                Result = JsonSerializer.SerializeToElement(fileData) 
            };
        }
        catch (FileNotFoundException)
        {
            throw new ToolExecutionException($"File not found: {fileId}");
        }
        catch (UnauthorizedAccessException)
        {
            throw new ToolExecutionException("You don't have permission to access this file");
        }
        catch (Exception ex) when (ex is IOException || ex is TimeoutException)
        {
            _logger.LogError(ex, "Error accessing file {FileId}", fileId);
            throw new ToolExecutionException("Error accessing file: The service is temporarily unavailable");
        }
    }
    catch (JsonException)
    {
        throw new ToolExecutionException("Invalid file ID format");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Unexpected error in FileAccessTool");
        throw new ToolExecutionException("An unexpected error occurred");
    }
}
```

#### 2. ರಚನಾತ್ಮಕ ದೋಷ ಪ್ರತಿಕ್ರಿಯೆಗಳು

ಯುಜರ್ ಸಾಧ್ಯವಾದಲ್ಲಿ ರಚನೆಗೊಂಡ ದೋಷ ಮಾಹಿತಿಯನ್ನು ಹಿಂತಿರುಗಿಸಿ:

```java
@Override
public ToolResponse execute(ToolRequest request) {
    try {
        // ಅನುಷ್ಠಾನ
    } catch (Exception ex) {
        Map<String, Object> errorResult = new HashMap<>();
        
        errorResult.put("success", false);
        
        if (ex instanceof ValidationException) {
            ValidationException validationEx = (ValidationException) ex;
            
            errorResult.put("errorType", "validation");
            errorResult.put("errorMessage", validationEx.getMessage());
            errorResult.put("validationErrors", validationEx.getErrors());
            
            return new ToolResponse.Builder()
                .setResult(errorResult)
                .build();
        }
        
        // ಇತರ исключಾದಗಳನ್ನು ToolExecutionException ಆಗಿ ಮರುಬಿತ್ತರಿಸಿ
        throw new ToolExecutionException("Tool execution failed: " + ex.getMessage(), ex);
    }
}
```

#### 3. ಮರುಪ್ರಯತ್ನ ತರ್ಕ

ತಾತ್ಕಾಲಿಕ ವೈಫಲ್ಯಗಳಿಗೆ ಸೂಕ್ತ ಮರುಪ್ರಯತ್ನ ತಂತ್ರಗಳನ್ನು ಜಾರಿಗೆ ತರು.

```python
async def execute_async(self, request):
    max_retries = 3
    retry_count = 0
    base_delay = 1  # ಸೆಕೆಂಡುಗಳು
    
    while retry_count < max_retries:
        try:
            # ಹೊರಗಿನ API ಅನ್ನು ಕರೆಮಾಡಿ
            return await self._call_api(request.parameters)
        except TransientError as e:
            retry_count += 1
            if retry_count >= max_retries:
                raise ToolExecutionException(f"Operation failed after {max_retries} attempts: {str(e)}")
                
            # ಘಾತಾಂಕ ಬ್ಯಾಕ್ಓಫ್
            delay = base_delay * (2 ** (retry_count - 1))
            logging.warning(f"Transient error, retrying in {delay}s: {str(e)}")
            await asyncio.sleep(delay)
        except Exception as e:
            # ಅস্থಾಯೀ ತಪ್ಪು ಅಲ್ಲ, ಮರುಪ್ರಯತ್ನಿಸಬೇಡಿ
            raise ToolExecutionException(f"Operation failed: {str(e)}")
```

### ಕಾರ್ಯಕ್ಷಮತೆ ಉತ್ತಮಗೊಳಿಸುವಿಕೆ

#### 1. ಕ್ಯಾಚಿಂಗ್

ಖರ್ಚು ದುಡ್ಡಾದ ಕಾರ್ಯಗಳಿಗೆ ಕ್ಯಾಚಿಂಗ್ ಜಾರಿಗೆ ತರ.

```csharp
public class CachedDataTool : IMcpTool
{
    private readonly IDatabase _database;
    private readonly IMemoryCache _cache;
    
    public CachedDataTool(IDatabase database, IMemoryCache cache)
    {
        _database = database;
        _cache = cache;
    }
    
    public async Task<ToolResponse> ExecuteAsync(ToolRequest request)
    {
        var query = request.Parameters.GetProperty("query").GetString();
        
        // Create cache key based on parameters
        var cacheKey = $"data_query_{ComputeHash(query)}";
        
        // Try to get from cache first
        if (_cache.TryGetValue(cacheKey, out var cachedResult))
        {
            return new ToolResponse { Result = cachedResult };
        }
        
        // Cache miss - perform actual query
        var result = await _database.QueryAsync(query);
        
        // Store in cache with expiration
        var cacheOptions = new MemoryCacheEntryOptions()
            .SetAbsoluteExpiration(TimeSpan.FromMinutes(15));
            
        _cache.Set(cacheKey, JsonSerializer.SerializeToElement(result), cacheOptions);
        
        return new ToolResponse { Result = JsonSerializer.SerializeToElement(result) };
    }
    
    private string ComputeHash(string input)
    {
        // Implementation to generate stable hash for cache key
    }
}
```

#### 2. ಅಸಿಂಕ್ರೋನಸ್ ಪ್ರೊಸೆಸಿಂಗ

I/O ಆಧಾರಿತ ಕಾರ್ಯಗಳಿಗೆ ಅಸಂಕೇತಿತ ಪ್ರೋಗ್ರಾಮಿಂಗ್ ಮಾದರಿಗಳನ್ನು ಬಳಸಿ:

```java
public class AsyncDocumentProcessingTool implements Tool {
    private final DocumentService documentService;
    private final ExecutorService executorService;
    
    @Override
    public ToolResponse execute(ToolRequest request) {
        String documentId = request.getParameters().get("documentId").asText();
        
        // ದೀರ್ಘಕಾಲ ನಡೆಯುವ ಕಾರ್ಯಗಳಿಗೆ, ತಕ್ಷಣವೇ ಪ್ರಕ್ರಿಯೆ ID ಅನ್ನು ಹಿಂತಿರುಗಿಸಿ
        String processId = UUID.randomUUID().toString();
        
        // ಅಸಿಂಕ್ರೋನಸ್ ಪ್ರಕ್ರಿಯೆಯನ್ನು ಪ್ರಾರಂಭಿಸಿ
        CompletableFuture.runAsync(() -> {
            try {
                // ದೀರ್ಘಕಾಲದ ಕಾರ್ಯಾಚರಣೆಯನ್ನು ಮಾಡು
                documentService.processDocument(documentId);
                
                // ಸ್ಥಿತಿಯನ್ನು ನವೀಕರಿಸಿ (ಸಾಮಾನ್ಯವಾಗಿ ಡೇಟಾಬೇಸಿನಲ್ಲಿ ಸಂಗ್ರಹಿಸಲಾಗುತ್ತದೆ)
                processStatusRepository.updateStatus(processId, "completed");
            } catch (Exception ex) {
                processStatusRepository.updateStatus(processId, "failed", ex.getMessage());
            }
        }, executorService);
        
        // ಪ್ರಕ್ರಿಯೆ ID ಸಹ ತಕ್ಷಣ ಪ್ರತಿಕ್ರಿಯೆಯನ್ನು ಹಿಂತಿರುಗಿಸಿ
        Map<String, Object> result = new HashMap<>();
        result.put("processId", processId);
        result.put("status", "processing");
        result.put("estimatedCompletionTime", ZonedDateTime.now().plusMinutes(5));
        
        return new ToolResponse.Builder().setResult(result).build();
    }
    
    // ಸಹಚರ ಸ್ಥಿತಿ ಪರಿಶೀಲನಾ ಉಪಕರಣ
    public class ProcessStatusTool implements Tool {
        @Override
        public ToolResponse execute(ToolRequest request) {
            String processId = request.getParameters().get("processId").asText();
            ProcessStatus status = processStatusRepository.getStatus(processId);
            
            return new ToolResponse.Builder().setResult(status).build();
        }
    }
}
```

#### 3. ಸಂಪನ್ಮೂಲ ಥ್ರಾಟಲಿಂಗ್

ಏರಿಳಿದಿರುವುದನ್ನು ತಡೆಯಲು ಸಂಪನ್ಮೂಲ ಥ್ರಾಟಲಿಂಗ್ ಜಾರಿಗೆ ತರ:

```python
class ThrottledApiTool(Tool):
    def __init__(self):
        self.rate_limiter = TokenBucketRateLimiter(
            tokens_per_second=5,  # ಪ್ರತಿ ಸೆಕೆಂಡ್‌ಗೆ 5 ವಿನಂತಿಗಳನ್ನು ಅನುಮತಿಸಿ
            bucket_size=10        # 10 ವಿನಂತಿಗಳವರೆಗೆ ಸ್ಫೋಟಗಳನ್ನು ಅನುಮತಿಸಿ
        )
    
    async def execute_async(self, request):
        # ನಾವು ಮುಂದುವರೆಯಬಹುದೇ ಅಥವಾ ಕಾಯಬೇಕಾಗಿದೆಯೇ ಎಂದು ಪರೀಕ್ಷಿಸಿ
        delay = self.rate_limiter.get_delay_time()
        
        if delay > 0:
            if delay > 2.0:  # ಕಾಯುವುದು ತುಂಬಾ ದೀರ್ಘವಾದರೆ
                raise ToolExecutionException(
                    f"Rate limit exceeded. Please try again in {delay:.1f} seconds."
                )
            else:
                # ಸೂಕ್ತ ವಿಳಂಬ ಸಮಯಕ್ಕೆ ಕಾಯಿರಿ
                await asyncio.sleep(delay)
        
        # ಒಂದು ಟೋಕನ್ ಸೇವಿಸಿ ಮತ್ತು ವಿನಂತಿಯನ್ನು ಮುಂದುವರಿಸಿ
        self.rate_limiter.consume()
        
        # API ಅನ್ನು ಕರೆದೊಯ್ಯಿ
        result = await self._call_api(request.parameters)
        return ToolResponse(result=result)

class TokenBucketRateLimiter:
    def __init__(self, tokens_per_second, bucket_size):
        self.tokens_per_second = tokens_per_second
        self.bucket_size = bucket_size
        self.tokens = bucket_size
        self.last_refill = time.time()
        self.lock = asyncio.Lock()
    
    async def get_delay_time(self):
        async with self.lock:
            self._refill()
            if self.tokens >= 1:
                return 0
            
            # ನಂತರದ ಟೋಕನ್ ಲಭ್ಯವಾಗುವವರೆಗಿನ ಸಮಯವನ್ನು ಲೆಕ್ಕಹಾಕಿ
            return (1 - self.tokens) / self.tokens_per_second
    
    async def consume(self):
        async with self.lock:
            self._refill()
            self.tokens -= 1
    
    def _refill(self):
        now = time.time()
        elapsed = now - self.last_refill
        
        # ಕಳೆದ ಸಮಯದ ಆಧಾರದ ಮೇಲೆ ಹೊಸ ಟೋಕನ್‌ಗಳನ್ನು ಸೇರಿಸಿ
        new_tokens = elapsed * self.tokens_per_second
        self.tokens = min(self.bucket_size, self.tokens + new_tokens)
        self.last_refill = now
```

### ಭದ್ರತೆ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

#### 1. ಇನ್ ಪುಟ್ ಪರಿಶೀಲನೆ

ಎಂದೆಸ್�ತೂ ಸುಧಾರಿತವಾಗಿ ಇನ್ ಪುಟ್ ಪರಿಮಾಣಗಳನ್ನು ಪರಿಶೀಲಿಸಿ:

```csharp
public async Task<ToolResponse> ExecuteAsync(ToolRequest request)
{
    // Validate parameters exist
    if (!request.Parameters.TryGetProperty("query", out var queryProp))
    {
        throw new ToolExecutionException("Missing required parameter: query");
    }
    
    // Validate correct type
    if (queryProp.ValueKind != JsonValueKind.String)
    {
        throw new ToolExecutionException("Query parameter must be a string");
    }
    
    var query = queryProp.GetString();
    
    // Validate string content
    if (string.IsNullOrWhiteSpace(query))
    {
        throw new ToolExecutionException("Query parameter cannot be empty");
    }
    
    if (query.Length > 500)
    {
        throw new ToolExecutionException("Query parameter exceeds maximum length of 500 characters");
    }
    
    // Check for SQL injection attacks if applicable
    if (ContainsSqlInjection(query))
    {
        throw new ToolExecutionException("Invalid query: contains potentially unsafe SQL");
    }
    
    // Proceed with execution
    // ...
}
```

#### 2. ಪ್ರಾಧಿಕರಣ ತಪಾಸಣೆಗಳು

ಸರಿಯಾದ ಪ್ರಾಧಿಕರಣ ಪರಿಶೀಲನೆಗಳನ್ನು ಜಾರಿಗೆ ತರ:

```java
@Override
public ToolResponse execute(ToolRequest request) {
    // ವಿನಂತಿಯಿಂದ ಬಳಕೆದಾರರ ಸಂದರ್ಭವನ್ನು ಪಡೆದುಕೊಳ್ಳಿ
    UserContext user = request.getContext().getUserContext();
    
    // ಬಳಕೆದಾರರಿಗೆ ಅಗತ್ಯ اجازتগুলি ಇದ್ದಾರೆವೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸಿ
    if (!authorizationService.hasPermission(user, "documents:read")) {
        throw new ToolExecutionException("User does not have permission to access documents");
    }
    
    // ವಿಶೇಷ ಸಂಪನ್ಮೂಲಗಳಿಗಾಗಿ, ಆ ಸಂಪನ್ಮೂಲಕ್ಕೆ ಪ್ರವೇಶವನ್ನು ಪರಿಶೀಲಿಸಿ
    String documentId = request.getParameters().get("documentId").asText();
    if (!documentService.canUserAccess(user.getId(), documentId)) {
        throw new ToolExecutionException("Access denied to the requested document");
    }
    
    // ಸಾಧನ ಕಾರ್ಯಗತಗೊಳಿಸುವಿಕೆಯನ್ನು ಮುಂದುವರೆಸಿರಿ
    // ...
}
```

#### 3. ಸಂವೇದನಾಶೀಲ ಡೇಟಾ ನಿರ್ವಹಣೆ

ಸಹಜ ವಿವೇಕದಿಂದ ಸಂವೇದನಾಶೀಲ ಡೇಟಾವನ್ನು ನಿರ್ವಹಿಸಿ:

```python
class SecureDataTool(Tool):
    def get_schema(self):
        return {
            "type": "object",
            "properties": {
                "userId": {"type": "string"},
                "includeSensitiveData": {"type": "boolean", "default": False}
            },
            "required": ["userId"]
        }
    
    async def execute_async(self, request):
        user_id = request.parameters["userId"]
        include_sensitive = request.parameters.get("includeSensitiveData", False)
        
        # ಬಳಕೆದಾರ ಡೇಟಾವನ್ನು ಪಡೆಯಿರಿ
        user_data = await self.user_service.get_user_data(user_id)
        
        # ಸ್ಪಷ್ಟವಾಗಿ ವಿನಂತಿ ಮಾಡಲಾಗದಷ್ಟು ಮತ್ತು ಅನುಮೋದಿಸಲ್ಪಡದಷ್ಟು ಸಂವೇದನಾಶೀಲ ಕ್ಷೇತ್ರಗಳನ್ನು ಫಿಲ್ಟರ್ ಮಾಡಿ
        if not include_sensitive or not self._is_authorized_for_sensitive_data(request):
            user_data = self._redact_sensitive_fields(user_data)
        
        return ToolResponse(result=user_data)
    
    def _is_authorized_for_sensitive_data(self, request):
        # ವಿನಂತಿ ಸಾಲಿನಲ್ಲಿ ಅನುಮತಿಯ ಮಟ್ಟವನ್ನು ಪರಿಶೀಲಿಸಿ
        auth_level = request.context.get("authorizationLevel")
        return auth_level == "admin"
    
    def _redact_sensitive_fields(self, user_data):
        # ಮೂಲವನ್ನು ಬದಲಾಯಿಸದಿರಲು ಒಂದು ನಕಲನ್ನು ರಚಿಸಿ
        redacted = user_data.copy()
        
        # ನಿರ್ದಿಷ್ಟ ಸಂವೇದನಾಶೀಲ ಕ್ಷೇತ್ರಗಳನ್ನು ರೆಡಾಕ್ಟ್ ಮಾಡಿ
        sensitive_fields = ["ssn", "creditCardNumber", "password"]
        for field in sensitive_fields:
            if field in redacted:
                redacted[field] = "REDACTED"
        
        # ಗೂಢಚರಿತಾದ ಸಂವೇದನಾಶೀಲ ಡೇಟಾವನ್ನು ರೆಡಾಕ್ಟ್ ಮಾಡಿ
        if "financialInfo" in redacted:
            redacted["financialInfo"] = {"available": True, "accessRestricted": True}
        
        return redacted
```

## MCP ಉಪಕರಣಗಳ ಪರೀಕ್ಷಾ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

ವಿಸ್ತೃತ ಪರೀಕ್ಷೆಯು MCP ಉಪಕರಣಗಳು ಸರಿಯಾಗಿ ಕಾರ್ಯನಿರ್ವಹಿಸುವುದನ್ನು, ಪಾರ್ಶ್ವ ಪ್ರಕರಣಗಳನ್ನು ಸಮರ್ಪಕವಾಗಿ ಹ್ಯಾಂಡಲ್ ಮಾಡುವುದನ್ನು ಮತ್ತು ಅವುಗಳ ಸಮಗ್ರ ವ್ಯವಸ್ಥೆಯೊಂದಿಗೆ ಒಗ್ಗೂಡುವುದನ್ನು ಖಚಿತಪಡಿಸುತ್ತದೆ.

### ಘಟಕ ಪರೀಕ್ಷೆ

#### 1. ಪ್ರತಿ ಉಪಕರಣವನ್ನು ಪ್ರತ್ಯೇಕವಾಗಿ ಪರೀಕ್ಷಿಸಿ

ಪ್ರತಿ ಉಪಕರಣದ ಕಾರ್ಯತತೆಯನ್ನು ಕೇಂದ್ರೀಕರಿಸಿದ ಪರೀಕ್ಷೆಗಳನ್ನು ರಚಿಸಿ:

```csharp
[Fact]
public async Task WeatherTool_ValidLocation_ReturnsCorrectForecast()
{
    // Arrange
    var mockWeatherService = new Mock<IWeatherService>();
    mockWeatherService
        .Setup(s => s.GetForecastAsync("Seattle", 3))
        .ReturnsAsync(new WeatherForecast(/* test data */));
    
    var tool = new WeatherForecastTool(mockWeatherService.Object);
    
    var request = new ToolRequest(
        toolName: "weatherForecast",
        parameters: JsonSerializer.SerializeToElement(new { 
            location = "Seattle", 
            days = 3 
        })
    );
    
    // Act
    var response = await tool.ExecuteAsync(request);
    
    // Assert
    Assert.NotNull(response);
    var result = JsonSerializer.Deserialize<WeatherForecast>(response.Result);
    Assert.Equal("Seattle", result.Location);
    Assert.Equal(3, result.DailyForecasts.Count);
}

[Fact]
public async Task WeatherTool_InvalidLocation_ThrowsToolExecutionException()
{
    // Arrange
    var mockWeatherService = new Mock<IWeatherService>();
    mockWeatherService
        .Setup(s => s.GetForecastAsync("InvalidLocation", It.IsAny<int>()))
        .ThrowsAsync(new LocationNotFoundException("Location not found"));
    
    var tool = new WeatherForecastTool(mockWeatherService.Object);
    
    var request = new ToolRequest(
        toolName: "weatherForecast",
        parameters: JsonSerializer.SerializeToElement(new { 
            location = "InvalidLocation", 
            days = 3 
        })
    );
    
    // Act & Assert
    var exception = await Assert.ThrowsAsync<ToolExecutionException>(
        () => tool.ExecuteAsync(request)
    );
    
    Assert.Contains("Location not found", exception.Message);
}
```

#### 2. ಸ್ಕೀಮಾ ಪರಿಶೀಲನೆ ಪರೀಕ್ಷೆ

ಸ್ಕೀಮಾಗಳನ್ನು ಮಾನ್ಯವಾಗಿರುವುದಾಗಿ ಪರೀಕ್ಷಿಸಿ ಮತ್ತು ನಿಯಮಗಳನ್ನು ಸರಿಯಾಗಿ ಜಾರಿಗೆ ತರಲಾಗಿದೆ ಎಂದು ಖಚಿತಪಡಿಸಿ:

```java
@Test
public void testSchemaValidation() {
    // ಸಾಧನ ಉದಾಹರಣೆಯನ್ನು ರಚಿಸಿ
    SearchTool searchTool = new SearchTool();
    
    // ಸ್ಕೀಮೆಯನ್ನು ಪಡೆಯಿರಿ
    Object schema = searchTool.getSchema();
    
    // ಪರಿಶೀಲನೆಗಾಗಿ ಸ್ಕೀಮೆಯನ್ನು JSON ಗೆ ಪರಿವರ್ತಿಸಿ
    String schemaJson = objectMapper.writeValueAsString(schema);
    
    // ಸ್ಕೀಮಾ ಮಾನ್ಯ JSONSchema ಆಗಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸಿ
    JsonSchemaFactory factory = JsonSchemaFactory.byDefault();
    JsonSchema jsonSchema = factory.getJsonSchema(schemaJson);
    
    // ಮಾನ್ಯ ಪರಿಮಾಣಗಳನ್ನು ಪರೀಕ್ಷಿಸಿ
    JsonNode validParams = objectMapper.createObjectNode()
        .put("query", "test query")
        .put("limit", 5);
        
    ProcessingReport validReport = jsonSchema.validate(validParams);
    assertTrue(validReport.isSuccess());
    
    // ಅಗತ್ಯ ಪರಿಮಾಣ ಇಲ್ಲದಿರುವನ್ನು ಪರೀಕ್ಷಿಸಿ
    JsonNode missingRequired = objectMapper.createObjectNode()
        .put("limit", 5);
        
    ProcessingReport missingReport = jsonSchema.validate(missingRequired);
    assertFalse(missingReport.isSuccess());
    
    // ಅಮಾನ್ಯ ಪರಿಮಾಣ ಬಗೆಯನ್ನು ಪರೀಕ್ಷಿಸಿ
    JsonNode invalidType = objectMapper.createObjectNode()
        .put("query", "test")
        .put("limit", "not-a-number");
        
    ProcessingReport invalidReport = jsonSchema.validate(invalidType);
    assertFalse(invalidReport.isSuccess());
}
```

#### 3. ದೋಷ ನಿರ್ವಹಣೆ ಪರೀಕ್ಷೆಗಳು

ದೋಷ ಪರಿಸ್ಥಿತಿಗಳಿಗಾಗಿ ನಿರ್ದಿಷ್ಟ ಪರೀಕ್ಷೆಗಳನ್ನು ರಚಿಸಿ:

```python
@pytest.mark.asyncio
async def test_api_tool_handles_timeout():
    # ಜೋಡಿಸಿ
    tool = ApiTool(timeout=0.1)  # ತುಂಬಾ ಚಿಕ್ಕ ಟೈಮ್ಔಟ್
    
    # ಸಮಯ ಸರಿದೂಗುವ ವಿನಂತಿಯನ್ನು ನಕಲಿಸಲು
    with aioresponses() as mocked:
        mocked.get(
            "https://api.example.com/data",
            callback=lambda *args, **kwargs: asyncio.sleep(0.5)  # ಟೈಮ್ಔಟ್ಕ್ಕಿಂತ ಹೆಚ್ಚು
        )
        
        request = ToolRequest(
            tool_name="apiTool",
            parameters={"url": "https://api.example.com/data"}
        )
        
        # ಕಾರ್ಯ ಮತ್ತು ದೃಢೀಕರಿಸಿ
        with pytest.raises(ToolExecutionException) as exc_info:
            await tool.execute_async(request)
        
        # अपವಾಹನೆ ಸಂದೇಶವನ್ನು ಪರಿಶೀಲಿಸಿ
        assert "timed out" in str(exc_info.value).lower()

@pytest.mark.asyncio
async def test_api_tool_handles_rate_limiting():
    # ಜೋಡಿಸಿ
    tool = ApiTool()
    
    # ದರ-ಮಿತಿಗೊಳಿಸಿದ ಪ್ರತಿಕ್ರಿಯೆಯನ್ನು ನಕಲಿಸಿ
    with aioresponses() as mocked:
        mocked.get(
            "https://api.example.com/data",
            status=429,
            headers={"Retry-After": "2"},
            body=json.dumps({"error": "Rate limit exceeded"})
        )
        
        request = ToolRequest(
            tool_name="apiTool",
            parameters={"url": "https://api.example.com/data"}
        )
        
        # ಕಾರ್ಯ ಮತ್ತು ದೃಢೀಕರಿಸಿ
        with pytest.raises(ToolExecutionException) as exc_info:
            await tool.execute_async(request)
        
        # ಅಪವಾಹನೆಯಲ್ಲಿ ದರ ಮಿತಿಯ ಮಾಹಿತಿ ಒಳಗೊಂಡಿದೆ ಎಂದು ಪರಿಶೀಲಿಸಿ
        error_msg = str(exc_info.value).lower()
        assert "rate limit" in error_msg
        assert "try again" in error_msg
```

### ಸಂಯೋಜನೆ ಪರೀಕ್ಷೆ

#### 1. ಉಪಕರಣ ಸರಪಳಿ ಪರೀಕ್ಷೆ

ನಿರೀಕ್ಷಿತ ಸಂಯೋಜನೆಗಳಲ್ಲಿ ಉಪಕರಣಗಳು ಜೊತೆ ಕೆಲಸಮಾಡುತ್ತಿರುವುದನ್ನು ಪರೀಕ್ಷಿಸಿ:

```csharp
[Fact]
public async Task DataProcessingWorkflow_CompletesSuccessfully()
{
    // Arrange
    var dataFetchTool = new DataFetchTool(mockDataService.Object);
    var analysisTools = new DataAnalysisTool(mockAnalysisService.Object);
    var visualizationTool = new DataVisualizationTool(mockVisualizationService.Object);
    
    var toolRegistry = new ToolRegistry();
    toolRegistry.RegisterTool(dataFetchTool);
    toolRegistry.RegisterTool(analysisTools);
    toolRegistry.RegisterTool(visualizationTool);
    
    var workflowExecutor = new WorkflowExecutor(toolRegistry);
    
    // Act
    var result = await workflowExecutor.ExecuteWorkflowAsync(new[] {
        new ToolCall("dataFetch", new { source = "sales2023" }),
        new ToolCall("dataAnalysis", ctx => new { 
            data = ctx.GetResult("dataFetch"),
            analysis = "trend" 
        }),
        new ToolCall("dataVisualize", ctx => new {
            analysisResult = ctx.GetResult("dataAnalysis"),
            type = "line-chart"
        })
    });
    
    // Assert
    Assert.NotNull(result);
    Assert.True(result.Success);
    Assert.NotNull(result.GetResult("dataVisualize"));
    Assert.Contains("chartUrl", result.GetResult("dataVisualize").ToString());
}
```

#### 2. MCP ಸರ್ವರ್ ಪರೀಕ್ಷೆ

ಸಂಪೂರ್ಣ ಉಪಕರಣ ನೋಂದಣೀಕರಣ ಮತ್ತು ಕಾರ್ಯಗತಗೊಳಿಸುವಿಕೆ ಮೂಲಕ MCP ಸರ್ವರ್ ಅನ್ನು ಪರೀಕ್ಷಿಸಿ:

```java
@SpringBootTest
@AutoConfigureMockMvc
public class McpServerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    public void testToolDiscovery() throws Exception {
        // ಡಿಸ್ಕವರಿ ಎಂಡ್ಪಾಯಿಂಟ್ ಅನ್ನು ಪರೀಕ್ಷಿಸಿ
        mockMvc.perform(get("/mcp/tools"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.tools").isArray())
            .andExpect(jsonPath("$.tools[*].name").value(hasItems(
                "weatherForecast", "calculator", "documentSearch"
            )));
    }
    
    @Test
    public void testToolExecution() throws Exception {
        // ಟೂಲ್ ವಿನಂತಿ ರಚಿಸಿ
        Map<String, Object> request = new HashMap<>();
        request.put("toolName", "calculator");
        
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("operation", "add");
        parameters.put("a", 5);
        parameters.put("b", 7);
        request.put("parameters", parameters);
        
        // ವಿನಂತಿಯನ್ನು ಕಳುಹಿಸಿ ಮತ್ತು ಉತ್ತರವನ್ನು ಪರಿಶೀಲಿಸಿ
        mockMvc.perform(post("/mcp/execute")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.result.value").value(12));
    }
    
    @Test
    public void testToolValidation() throws Exception {
        // ಅಮಾನ್ಯ ಟೂಲ್ ವಿನಂತಿ ರಚಿಸಿ
        Map<String, Object> request = new HashMap<>();
        request.put("toolName", "calculator");
        
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("operation", "divide");
        parameters.put("a", 10);
        // "b" ಪರಿಮಾಣ ಕಡತ ಇಲ್ಲ
        request.put("parameters", parameters);
        
        // ವಿನಂತಿಯನ್ನು ಕಳುಹಿಸಿ ಮತ್ತು ದೋಷ ಉತ್ತರವನ್ನು ಪರಿಶೀಲಿಸಿ
        mockMvc.perform(post("/mcp/execute")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.error").exists());
    }
}
```

#### 3. ತುದಿಗೆ ತುದಿ ಪರೀಕ್ಷೆ

ಮಾದರಿ ಪ್ರಾಂಪ್ಟ್‌ನಿಂದ ಉಪಕರಣ ಕಾರ್ಯಗತಗೊಳಿಸುವವರೆಗೆ ಸಂಪೂರ್ಣ ವರ್ಕ್ಫ್ಲೋಗಳನ್ನು ಪರೀಕ್ಷಿಸಿ:

```python
@pytest.mark.asyncio
async def test_model_interaction_with_tool():
    # ವ್ಯವಸ್ಥೆ - MCP ಕ್ಲೈಂಟ್ ಮತ್ತು ನಕಲಿ ಮಾದರಿಯನ್ನು ಸ್ಥಾಪಿಸಿ
    mcp_client = McpClient(server_url="http://localhost:5000")
    
    # ನಕಲಿ ಮಾದರಿ ಪ್ರತಿಕ್ರಿಯೆಗಳು
    mock_model = MockLanguageModel([
        MockResponse(
            "What's the weather in Seattle?",
            tool_calls=[{
                "tool_name": "weatherForecast",
                "parameters": {"location": "Seattle", "days": 3}
            }]
        ),
        MockResponse(
            "Here's the weather forecast for Seattle:\n- Today: 65°F, Partly Cloudy\n- Tomorrow: 68°F, Sunny\n- Day after: 62°F, Rain",
            tool_calls=[]
        )
    ])
    
    # ನಕಲಿ ಹವಾಮಾನ ಸಾಧನ ಪ್ರತಿಕ್ರಿಯೆ
    with aioresponses() as mocked:
        mocked.post(
            "http://localhost:5000/mcp/execute",
            payload={
                "result": {
                    "location": "Seattle",
                    "forecast": [
                        {"date": "2023-06-01", "temperature": 65, "conditions": "Partly Cloudy"},
                        {"date": "2023-06-02", "temperature": 68, "conditions": "Sunny"},
                        {"date": "2023-06-03", "temperature": 62, "conditions": "Rain"}
                    ]
                }
            }
        )
        
        # ಕ್ರಿಯಾತ್ಮಕ ಅಂಶ
        response = await mcp_client.send_prompt(
            "What's the weather in Seattle?",
            model=mock_model,
            allowed_tools=["weatherForecast"]
        )
        
        # ದೃಢೀಕರಿಸಿ
        assert "Seattle" in response.generated_text
        assert "65" in response.generated_text
        assert "Sunny" in response.generated_text
        assert "Rain" in response.generated_text
        assert len(response.tool_calls) == 1
        assert response.tool_calls[0].tool_name == "weatherForecast"
```

### ಕಾರ್ಯಕ್ಷಮತೆ ಪರೀಕ್ಷೆ

#### 1. ಲೋಡ್ ಪರೀಕ್ಷೆ

ನಿಮ್ಮ MCP ಸರ್ವರ್ ಎಷ್ಟು samtidನಿಕ ವಿನಂತಿಗಳನ್ನು ನಿರ್ವಹಿಸಬಹುದು ಎಂದು ಪರೀಕ್ಷಿಸಿ:

```csharp
[Fact]
public async Task McpServer_HandlesHighConcurrency()
{
    // Arrange
    var server = new McpServer(
        name: "TestServer",
        version: "1.0",
        maxConcurrentRequests: 100
    );
    
    server.RegisterTool(new FastExecutingTool());
    await server.StartAsync();
    
    var client = new McpClient("http://localhost:5000");
    
    // Act
    var tasks = new List<Task<McpResponse>>();
    for (int i = 0; i < 1000; i++)
    {
        tasks.Add(client.ExecuteToolAsync("fastTool", new { iteration = i }));
    }
    
    var results = await Task.WhenAll(tasks);
    
    // Assert
    Assert.Equal(1000, results.Length);
    Assert.All(results, r => Assert.NotNull(r));
}
```

#### 2. ಸ್ಟ್ರೆಸ್ ಪರೀಕ್ಷೆ

ಅತಿಯಾದ ಭಾರದಲ್ಲಿ ವ್ಯವಸ್ಥೆಯನ್ನು ಪರೀಕ್ಷಿಸಿ:

```java
@Test
public void testServerUnderStress() {
    int maxUsers = 1000;
    int rampUpTimeSeconds = 60;
    int testDurationSeconds = 300;
    
    // ಒತ್ತಡ ಪರೀಕ್ಷೆಗೆ JMeter ಅನ್ನು ವ್ಯವಸ್ಥೆ ಮಾಡು
    StandardJMeterEngine jmeter = new StandardJMeterEngine();
    
    // JMeter ಪರೀಕ್ಷಾ ಯೋಜನೆಯನ್ನು ಸಂರಚಿಸು
    HashTree testPlanTree = new HashTree();
    
    // ಪರೀಕ್ಷಾ ಯೋಜನೆ, ತಂತಿ ಗುಂಪು, ಸಂಗ್ರಾಹಕರೆಗಳನ್ನು ಸೃಜಿಸು
    TestPlan testPlan = new TestPlan("MCP Server Stress Test");
    testPlanTree.add(testPlan);
    
    ThreadGroup threadGroup = new ThreadGroup();
    threadGroup.setNumThreads(maxUsers);
    threadGroup.setRampUp(rampUpTimeSeconds);
    threadGroup.setScheduler(true);
    threadGroup.setDuration(testDurationSeconds);
    
    testPlanTree.add(threadGroup);
    
    // ಸಾಧನ ಕಾರ್ಯಗತಗೊಳಿಸುವಿಕೆಗೆ HTTP ಸಂಗ್ರಾಹಕರೆ ಸೇರಿಸು
    HTTPSampler toolExecutionSampler = new HTTPSampler();
    toolExecutionSampler.setDomain("localhost");
    toolExecutionSampler.setPort(5000);
    toolExecutionSampler.setPath("/mcp/execute");
    toolExecutionSampler.setMethod("POST");
    toolExecutionSampler.addArgument("toolName", "calculator");
    toolExecutionSampler.addArgument("parameters", "{\"operation\":\"add\",\"a\":5,\"b\":7}");
    
    threadGroup.add(toolExecutionSampler);
    
    // ಆಲಿಸುವವರನ್ನು ಸೇರಿಸು
    SummaryReport summaryReport = new SummaryReport();
    threadGroup.add(summaryReport);
    
    // ಪರೀಕ್ಷೆಯನ್ನು ಚಾಲನೆ ಮಾಡು
    jmeter.configure(testPlanTree);
    jmeter.run();
    
    // ಫಲಿತಾಂಶಗಳನ್ನು ಪರಿಶೀಲಿಸು
    assertEquals(0, summaryReport.getErrorCount());
    assertTrue(summaryReport.getAverage() < 200); // ಸರಾಸರಿ ಪ್ರತಿಕ್ರೀಯಾ ಸಮಯ < 200ms
    assertTrue(summaryReport.getPercentile(90.0) < 500); // 90ನೇ ಶತಮಾನ < 500ms
}
```

#### 3. ಮೇಲ್ವಿಚಾರಣೆ ಮತ್ತು ಪ್ರೊಫೈಲಿಂಗ್

ದೀರ್ಘಕಾಲೀನ ಕಾರ್ಯಕ್ಷಮತೆ ವಿಶ್ಲೇಷಣೆಗೆ ಮೇಲ್ವಿಚಾರಣೆಯನ್ನು ಹೊಂದಿಸಿ:

```python
# MCP ಸರ್ವರ್‌ಗಾಗಿ ನಿಗಾವಣೆಗಳನ್ನು ಸಂರಚಿಸಿ
def configure_monitoring(server):
    # Prometheus ಮೆಟ್ರಿಕ್ಸ್‌ಗಳನ್ನು ಸೆಟ್ ಅಪ್ ಮಾಡಿ
    prometheus_metrics = {
        "request_count": Counter("mcp_requests_total", "Total MCP requests"),
        "request_latency": Histogram(
            "mcp_request_duration_seconds", 
            "Request duration in seconds",
            buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 2.5, 5.0, 10.0]
        ),
        "tool_execution_count": Counter(
            "mcp_tool_executions_total", 
            "Tool execution count",
            labelnames=["tool_name"]
        ),
        "tool_execution_latency": Histogram(
            "mcp_tool_duration_seconds", 
            "Tool execution duration in seconds",
            labelnames=["tool_name"],
            buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 2.5, 5.0, 10.0]
        ),
        "tool_errors": Counter(
            "mcp_tool_errors_total",
            "Tool execution errors",
            labelnames=["tool_name", "error_type"]
        )
    }
    
    # ಸಮಯಗಳನ್ನು ಮತ್ತು ಮೆಟ್ರಿಕ್ಸ್ ದಾಖಲಿಸುವ ಮಧ್ಯಂತರ ಸಾಫ್ಟ್‌ವೇರ್ ಅನ್ನು ಸೇರಿಸಿ
    server.add_middleware(PrometheusMiddleware(prometheus_metrics))
    
    # ಮೆಟ್ರಿಕ್ಸ್ ಎಂಡ್‌ಪಾಯಿಂಟ್ ಅನ್ನು ಬಹಿರ್ಗತಗೊಳಿಸಿ
    @server.router.get("/metrics")
    async def metrics():
        return generate_latest()
    
    return server
```

## MCP ವರ್ಕ್ಫ್ಲೋ ವಿನ್ಯಾಸ ಮಾದರಿಗಳು

ಒಳ್ಳೆಯ ವಿನ್ಯಾಸಗೊಂಡ MCP ವರ್ಕ್ಫ್ಲೋಗಳು ಕಾರ್ಯಕ್ಷಮತೆ, ವಿಶ್ವಾಸಾರ್ಹತೆ ಮತ್ತು ನಿರ್ವಹಣಾ ಸುಲಭತೆಯನ್ನು ಸುಧಾರಿಸುತ್ತವೆ. ಪಾಲಿಸುವ ಮುಖ್ಯ ಮಾದರಿಗಳು ಇಲ್ಲಿವೆ:

### 1. ಉಪಕರಣಗಳ ಸರಪಳಿ ಮಾದರಿ

ಪ್ರತಿ ಉಪಕರಣದ ಔಟ್‍ಪುಟ್ ಮುಂದಿನ ಉಪಕರಣದ ಇನ್‌ಪುಟ್ ಆಗುವಂತೆ ಬೆಂಬಲಿಸುವ ಹಲವಾರು ಉಪಕರಣಗಳನ್ನು ಸರಣಿ ಬದಲು ಸಂಪರ್ಕಿಸಿ:

```python
# ಪೈಥಾನ್ ಚೇನ್ ಆಫ್ ಟೂಲ್ಸ್ ಜಾರಿಗೋಳಿಕೆ
class ChainWorkflow:
    def __init__(self, tools_chain):
        self.tools_chain = tools_chain  # ಸರಣಿಯಲ್ಲಿ ಕಾರ್ಯನಿರ್ವಹಿಸಲು ಉಪಕರಣದ ಹೆಸರುಗಳ ಪಟ್ಟಿ
    
    async def execute(self, mcp_client, initial_input):
        current_result = initial_input
        all_results = {"input": initial_input}
        
        for tool_name in self.tools_chain:
            # ಸರಣಿಯಲ್ಲಿನ ಪ್ರತಿ ಉಪಕರಣವನ್ನು ನಿರ್ವಹಿಸಿ, ಮೊದಲು ಫಲಿತಾಂಶವನ್ನು ಹಂಚಿಕೊಳ್ಳಿ
            response = await mcp_client.execute_tool(tool_name, current_result)
            
            # ಫಲಿತಾಂಶಗಳನ್ನು ಸಂಗ್ರಹಿಸಿ ಮತ್ತು ಮುಂದಿನ ಉಪಕರಣಕ್ಕೆ ಇನ್‌ಪುಟ್ ಆಗಿಸಿ
            all_results[tool_name] = response.result
            current_result = response.result
        
        return {
            "final_result": current_result,
            "all_results": all_results
        }

# ಉದಾಹರಣೆ ಬಳಕೆ ಕ್ರಮ
data_processing_chain = ChainWorkflow([
    "dataFetch",
    "dataCleaner",
    "dataAnalyzer",
    "dataVisualizer"
])

result = await data_processing_chain.execute(
    mcp_client,
    {"source": "sales_database", "table": "transactions"}
)
```

### 2. ಡಿಸ್ಪ್ಯಾಚರ್ ಮಾದರಿ

ಇನ್‌ಪುಟಿನ ಆಧಾರದ ಮೇಲೆ ಸ್ಪೆಶಲೈಸ್ಡ್ ಉಪಕರಣಗಳಿಗೆ ಡಿಸ್ಪ್ಯಾಚ್ ಮಾಡುವ ಕೇಂದ್ರಿತ ಉಪಕರಣವನ್ನು ಬಳಸಿ:

```csharp
public class ContentDispatcherTool : IMcpTool
{
    private readonly IMcpClient _mcpClient;
    
    public ContentDispatcherTool(IMcpClient mcpClient)
    {
        _mcpClient = mcpClient;
    }
    
    public string Name => "contentProcessor";
    public string Description => "Processes content of various types";
    
    public object GetSchema()
    {
        return new {
            type = "object",
            properties = new {
                content = new { type = "string" },
                contentType = new { 
                    type = "string",
                    enum = new[] { "text", "html", "markdown", "csv", "code" }
                },
                operation = new { 
                    type = "string",
                    enum = new[] { "summarize", "analyze", "extract", "convert" }
                }
            },
            required = new[] { "content", "contentType", "operation" }
        };
    }
    
    public async Task<ToolResponse> ExecuteAsync(ToolRequest request)
    {
        var content = request.Parameters.GetProperty("content").GetString();
        var contentType = request.Parameters.GetProperty("contentType").GetString();
        var operation = request.Parameters.GetProperty("operation").GetString();
        
        // Determine which specialized tool to use
        string targetTool = DetermineTargetTool(contentType, operation);
        
        // Forward to the specialized tool
        var specializedResponse = await _mcpClient.ExecuteToolAsync(
            targetTool,
            new { content, options = GetOptionsForTool(targetTool, operation) }
        );
        
        return new ToolResponse { Result = specializedResponse.Result };
    }
    
    private string DetermineTargetTool(string contentType, string operation)
    {
        return (contentType, operation) switch
        {
            ("text", "summarize") => "textSummarizer",
            ("text", "analyze") => "textAnalyzer",
            ("html", _) => "htmlProcessor",
            ("markdown", _) => "markdownProcessor",
            ("csv", _) => "csvProcessor",
            ("code", _) => "codeAnalyzer",
            _ => throw new ToolExecutionException($"No tool available for {contentType}/{operation}")
        };
    }
    
    private object GetOptionsForTool(string toolName, string operation)
    {
        // Return appropriate options for each specialized tool
        return toolName switch
        {
            "textSummarizer" => new { length = "medium" },
            "htmlProcessor" => new { cleanUp = true, operation },
            // Options for other tools...
            _ => new { }
        };
    }
}
```

### 3. ಸಮಾಂತರ ಪ್ರೊಸೆಸಿಂಗ್ ಮಾದರಿ

ಕಾರ್ಯಕ್ಷಮತೆಗೆ ಹಲವು ಉಪಕರಣಗಳನ್ನು ತಾವು ತಾವು ನಿರ್ವಹಿಸಲೆಂದು ಅನುಮತಿಸಿ:

```java
public class ParallelDataProcessingWorkflow {
    private final McpClient mcpClient;
    
    public ParallelDataProcessingWorkflow(McpClient mcpClient) {
        this.mcpClient = mcpClient;
    }
    
    public WorkflowResult execute(String datasetId) {
        // ಹಂತ 1: ಡೇಟಾಸೆಟ್ ಮೆಟಾಡೇಟಾ ತಗೋಳಿ (ಒಪ್ಪಂದಿತ)
        ToolResponse metadataResponse = mcpClient.executeTool("datasetMetadata", 
            Map.of("datasetId", datasetId));
        
        // ಹಂತ 2: ಹಲವು ವಿಶ್ಲೇಷಣೆಗಳನ್ನು ಸಮಾಂತರವಾಗಿ ಪ್ರಾರಂಭಿಸಿ
        CompletableFuture<ToolResponse> statisticalAnalysis = CompletableFuture.supplyAsync(() ->
            mcpClient.executeTool("statisticalAnalysis", Map.of(
                "datasetId", datasetId,
                "type", "comprehensive"
            ))
        );
        
        CompletableFuture<ToolResponse> correlationAnalysis = CompletableFuture.supplyAsync(() ->
            mcpClient.executeTool("correlationAnalysis", Map.of(
                "datasetId", datasetId,
                "method", "pearson"
            ))
        );
        
        CompletableFuture<ToolResponse> outlierDetection = CompletableFuture.supplyAsync(() ->
            mcpClient.executeTool("outlierDetection", Map.of(
                "datasetId", datasetId,
                "sensitivity", "medium"
            ))
        );
        
        // ಎಲ್ಲಾ ಸಮಾಂತರ ಕಾರ್ಯಗಳು ಪೂರ್ಣಗೊಳ್ಳುವನ್ನು ಕಾಯಿರಿ
        CompletableFuture<Void> allAnalyses = CompletableFuture.allOf(
            statisticalAnalysis, correlationAnalysis, outlierDetection
        );
        
        allAnalyses.join();  // ಪೂರ್ಣಗೊಳ್ಳುವನ್ನು ಕಾಯಿರಿ
        
        // ಹಂತ 3: ಫಲಿತಾಂಶಗಳನ್ನು ಸಂಯೋಜಿಸಿ
        Map<String, Object> combinedResults = new HashMap<>();
        combinedResults.put("metadata", metadataResponse.getResult());
        combinedResults.put("statistics", statisticalAnalysis.join().getResult());
        combinedResults.put("correlations", correlationAnalysis.join().getResult());
        combinedResults.put("outliers", outlierDetection.join().getResult());
        
        // ಹಂತ 4: ಸಾರಾಂಶ ವರದಿಯನ್ನು ರಚಿಸಿ
        ToolResponse summaryResponse = mcpClient.executeTool("reportGenerator", 
            Map.of("analysisResults", combinedResults));
        
        // ಸಂಪೂರ್ಣ ಕಾರ್ಯಪ್ರವಾಹ ಫಲಿತಾಂಶವನ್ನು ಹಿಂತಿರುಗಿಸಿ
        WorkflowResult result = new WorkflowResult();
        result.setDatasetId(datasetId);
        result.setAnalysisResults(combinedResults);
        result.setSummaryReport(summaryResponse.getResult());
        
        return result;
    }
}
```

### 4. ದೋಷ ಪುನರ್‌ಪ್ರಾಪ್ತಿ ಮಾದರಿ

ಉಪಕರಣ ವೈಫಲ್ಯಗಳಿಗೆ ಮೃದುವಾದ ಬ್ಯಾಕ್‌ಅಪ್‌ಗಳನ್ನು ಜಾರಿಗೆ ತರು:

```python
class ResilientWorkflow:
    def __init__(self, mcp_client):
        self.client = mcp_client
    
    async def execute_with_fallback(self, primary_tool, fallback_tool, parameters):
        try:
            # ಪ್ರಾಥಮಿಕ ಉಪಕರಣವನ್ನು ಮೊದಲು ಪ್ರಯತ್ನಿಸಿ
            response = await self.client.execute_tool(primary_tool, parameters)
            return {
                "result": response.result,
                "source": "primary",
                "tool": primary_tool
            }
        except ToolExecutionException as e:
            # ವಿಫಲತೆಯನ್ನು ದಾಖಲಿಸಿ
            logging.warning(f"Primary tool '{primary_tool}' failed: {str(e)}")
            
            # ದ್ವಿತೀಯ ಉಪಕರಣಕ್ಕೆ ಹಿಂತರುವಿರಿ
            try:
                # ಹಿಂತರುವು ಉಪಕರಣಕ್ಕಾಗಿ ಪಾರಾಮೀಟರ್‌ಗಳನ್ನು ಪರಿವರ್ತಿಸಬೇಕಾಗಬಹುದು
                fallback_params = self._adapt_parameters(parameters, primary_tool, fallback_tool)
                
                response = await self.client.execute_tool(fallback_tool, fallback_params)
                return {
                    "result": response.result,
                    "source": "fallback",
                    "tool": fallback_tool,
                    "primaryError": str(e)
                }
            except ToolExecutionException as fallback_error:
                # ಎರಡೂ ಉಪಕರಣಗಳು ವಿಫಲಗೊಂಡಿವೆ
                logging.error(f"Both primary and fallback tools failed. Fallback error: {str(fallback_error)}")
                raise WorkflowExecutionException(
                    f"Workflow failed: primary error: {str(e)}; fallback error: {str(fallback_error)}"
                )
    
    def _adapt_parameters(self, params, from_tool, to_tool):
        """Adapt parameters between different tools if needed"""
        # ಈ ಅನುಷ್ಠಾನವು ವಿಶೇಷ ಉಪಕರಣಗಳ ಮೇಲೆ ಅವಲಂಬಿತವಾಗಿರುತ್ತದೆ
        # ಈ ಉದಾಹರಣೆಗೆ, ನಾವು ಮೂಲ ಪಾರಾಮೀಟರ್‌ಗಳನ್ನು ಹಿಂತಿರುಗಿಸುವೆವು
        return params

# ಉದಾಹರಣೆಯ ಬಳಕೆ
async def get_weather(workflow, location):
    return await workflow.execute_with_fallback(
        "premiumWeatherService",  # ಪ್ರಾಥಮಿಕ (ಪಾವತಿಸುವ) ಹವಾಮಾನ API
        "basicWeatherService",    # ಹಿಂತರುವು (ಉಚಿತ) ಹವಾಮಾನ API
        {"location": location}
    )
```

### 5. ವರ್ಕ್ಫ್ಲೋ ಸಂಯೋಜನೆ ಮಾದರಿ

ಸರಳ ವರ್ಕ್ಫ್ಲೋಗಳನ್ನು ಸಂಯೋಜಿಸಿ ಸಂಕೀರ್ಣ ones ರಚಿಸಿ:

```csharp
public class CompositeWorkflow : IWorkflow
{
    private readonly List<IWorkflow> _workflows;
    
    public CompositeWorkflow(IEnumerable<IWorkflow> workflows)
    {
        _workflows = new List<IWorkflow>(workflows);
    }
    
    public async Task<WorkflowResult> ExecuteAsync(WorkflowContext context)
    {
        var results = new Dictionary<string, object>();
        
        foreach (var workflow in _workflows)
        {
            var workflowResult = await workflow.ExecuteAsync(context);
            
            // Store each workflow's result
            results[workflow.Name] = workflowResult;
            
            // Update context with the result for the next workflow
            context = context.WithResult(workflow.Name, workflowResult);
        }
        
        return new WorkflowResult(results);
    }
    
    public string Name => "CompositeWorkflow";
    public string Description => "Executes multiple workflows in sequence";
}

// Example usage
var documentWorkflow = new CompositeWorkflow(new IWorkflow[] {
    new DocumentFetchWorkflow(),
    new DocumentProcessingWorkflow(),
    new InsightGenerationWorkflow(),
    new ReportGenerationWorkflow()
});

var result = await documentWorkflow.ExecuteAsync(new WorkflowContext {
    Parameters = new { documentId = "12345" }
});
```

# MCP ಸერვರ್‌ಗಳನ್ನು ಪರೀಕ್ಷಿಸುವುದು: ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು ಮತ್ತು ಪ್ರಮುಖ ಸಲಹೆಗಳು

## ಅವಲೋಕನ

ಪರೀಕ್ಷೆ MCP ಸರ್ವರ್‌ಗಳ ವಿಶ್ವಾಸಾರ್ಹ, ಉನ್ನತ ಗುಣಮಟ್ಟದ ಅಭಿವೃದ್ಧಿಯ ಪ್ರಮುಖ ಅಂಶವಾಗಿದೆ. ಘಟಕ ಪರೀಕ್ಷೆಯಿಂದ ಸಂಯೋಜನೆ ಪರೀಕ್ಷೆ ಮತ್ತು ತುದಿಗೆ ತುದಿ ಮಾನ್ಯತೆ ವರೆಗೆ, ನಿಮ್ಮ MCP ಸರ್ವರ್‌ಗಳನ್ನು ಅಭಿವೃದ್ಧಿ ಜೀವನಚಕ್ರದಲ್ಲಿ ಪರೀಕ್ಷಿಸುವ ಸಮಗ್ರ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು ಮತ್ತು ಸಲಹೆಗಳು ಈ ಮಾರ್ಗದರ್ಶಿಯಲ್ಲಿ ಒದಗಿಸಲಾಗಿದೆ.

## MCP ಸರ್ವರ್‌ಗಳಿಗೆ ಪರೀಕ್ಷೆಯ ಪ್ರಾಮುಖ್ಯತೆ

MCP ಸರ್ವರ್‌ಗಳು AI ಮಾದರಿ ಮತ್ತು ಗ್ರಾಹಕ ಅಪ್ಲಿಕೇಶನ್‌ಗಳ ನಡುವಣ ಪ್ರಮುಖ ಮಧ್ಯವರ್ತಿಯಾಗಿವೆ. ಪೂರ್ಣ ಪರೀಕ್ಷೆಯಿಂದ ಕೆಳಗಿನವು ಭದ್ರವಾಗುತ್ತವೆ:

- ಉತ್ಪಾದನಾ ವಾತಾವರಣಗಳಲ್ಲಿ ವಿಶ್ವಾಸಾರ್ಹತೆ  
- ವಿನಂತಿ ಮತ್ತು ಪ್ರತಿಕ್ರಿಯೆಗಳ ನಿಖರ ನಿರ್ವಹಣೆ  
- MCP ನಿರ್ದಿಷ್ಟಪಡಿಸಿ ಸರಿಯಾದ ಅನುಷ್ಠಾನ   
- ವೈಫಲ್ಯಗಳು ಮತ್ತು ಎಡ್ಜ್ ಕೇಸ್‌ಗಳ ವಿರುದ್ಧ ಸಹನಶೀಲತೆ  
- ವಿವಿಧ ಲೋಡ್ಗಳಲ್ಲಿನ ಸತತ ಕಾರ್ಯಕ್ಷಮತೆ  

## MCP ಸರ್ವರ್‌ಗಳಿಗೆ ಘಟಕ ಪರೀಕ್ಷೆ

### ಘಟಕ ಪರೀಕ್ಷೆ (ಮೂಲಭೂತ)

ಘಟಕ ಪರೀಕ್ಷೆಗಳು ನಿಮ್ಮ MCP ಸರ್ವರ್‌ನ ಒಂದೊಂದು ಘಟಕಗಳನ್ನು ಪ್ರತ್ಯೇಕವಾಗಿ ಪರಿಶೀಲಿಸುತ್ತವೆ.

#### ಪರೀಕ್ಷಿಸುವುದು ಏನು

1. **ಸಂಪನ್ಮೂಲ ನಿರ್ವಹಕರು**: ಪ್ರತಿ ಸಂಪನ್ಮೂಲ ನಿರ್ವಹಕದ ಲಾಜಿಕ್ ಅನ್ನು ಸ್ವತಂತ್ರವಾಗಿ ಪರೀಕ್ಷಿಸಿ  
2. **ಉಪಕರಣ ಅನುಷ್ಥಾನಗಳು**: ವಿಭಿನ್ನ ಇನ್‌ಪುಟ್‌ಗಳಿಗೆ ಉಪಕರಣಗಳ ವರ್ತನೆಯನ್ನು ಪರಿಶೀಲಿಸಿ  
3. **ಪ್ರಾಂಪ್ಟ್ ಟೆಂಪ್ಲೇಟ್ಗಳು**: ಪ್ರಾಂಪ್ಟ್ ಟೆಂಪ್ಲೇಟ್ಗಳು ಸರಿಯಾಗಿ ರೆಂಡರ್ ಆಗುತ್ತವೆಯೇ ಎಂದು ಖಚಿತಪಡಿಸಿ  
4. **ಸ್ಕೀಮಾ ಮಾನ್ಯತೆ**: ಪರಿಮಾಣ ಪರಿಶೀಲನೆ ಲಾಜಿಕ್ ಅನ್ನು ಪರೀಕ್ಷಿಸಿ  
5. **ದೋಷ ನಿರ್ವಹಣೆ**: ಅಮಾನ್ಯ ಇನ್ ಪುಟ್‌ಗಳಿಗೆ ದೋಷ ಪ್ರತಿಕ್ರಿಯೆಗಳನ್ನು ಪರೀಕ್ಷಿಸಿ  

#### ಘಟಕ ಪರೀಕ್ಷೆಯ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

```csharp
// Example unit test for a calculator tool in C#
[Fact]
public async Task CalculatorTool_Add_ReturnsCorrectSum()
{
    // Arrange
    var calculator = new CalculatorTool();
    var parameters = new Dictionary<string, object>
    {
        ["operation"] = "add",
        ["a"] = 5,
        ["b"] = 7
    };
    
    // Act
    var response = await calculator.ExecuteAsync(parameters);
    var result = JsonSerializer.Deserialize<CalculationResult>(response.Content[0].ToString());
    
    // Assert
    Assert.Equal(12, result.Value);
}
```

```python
# ಪೈಥಾನ್‌ನಲ್ಲಿ ಕ್ಯಾಲ್ಕ್ಯುಲೇಟರ್ ಟೂಲ್ ಗಾಗಿ ಉದಾಹರಣಾ ಘಟಕ ಪರೀಕ್ಷೆ
def test_calculator_tool_add():
    # ವ್ಯವಸ್ಥೆ ಮಾಡು
    calculator = CalculatorTool()
    parameters = {
        "operation": "add",
        "a": 5,
        "b": 7
    }
    
    # ಕಾರ್ಯ ಮಾಡು
    response = calculator.execute(parameters)
    result = json.loads(response.content[0].text)
    
    # ದೃಢೀಕರಿಸು
    assert result["value"] == 12
```

### ಸಂಯೋಜನೆ ಪರೀಕ್ಷೆ (ಮಧ್ಯಮ ಪದವಿ)

ಸಂಯೋಜನೆ ಪರೀಕ್ಷೆ MCP ಸರ್ವರ್‌ನ ಘಟಕಗಳ ನಡುವಣ ಸಂವಹನವನ್ನು ಪರಿಶೀಲಿಸುತ್ತದೆ.

#### ಪರೀಕ್ಷಿಸುವುದು ಏನು

1. **ಸರ್ವರ್ ಆರಂಭಿಸುವಿಕೆ**: ವಿಭಿನ್ನ ಸಂರಚನೆಗಳೊಂದಿಗೆ ಸರ್ವರ್ ಪ್ರಾರಂಭವನ್ನು ಪರೀಕ್ಷಿಸಿ  
2. **ರೌಟ್ ನೋಂದಣಿ**: ಎಲ್ಲಾ ಎಂಡ್‌ಪಾಯಿಂಟ್‌ಗಳು ಸರಿಯಾಗಿ ನೋಂದಣಿಯಾಗಿದ್ದಾರೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸಿ  
3. **ವಿನಂತಿ ಪ್ರಕ್ರಿಯೆ**: ಸಂಪೂರ್ಣ ವಿನಂತಿ-ಪ್ರತಿಕ್ರಿಯೆ ಚಕ್ರವನ್ನು ಪರೀಕ್ಷಿಸಿ  
4. **ದೋಷ ಪ್ರಸರಣ**: ಘಟಕಗಳ ನಡುವೆ ದೋಷಗಳು ಸೂಕ್ತವಾಗಿ ನಿರ್ವಹಿಸಲ್ಪಡುವುದೇ ಎಂದು ಖಚಿತಪಡಿಸಿ  
5. **ಪರಿಶೀಲನೆ ಮತ್ತು ಪ್ರಾಧಿಕರಣೆ**: ಭದ್ರತಾ ಯಂತ್ರಾಂಗಗಳನ್ನು ಪರೀಕ್ಷಿಸಿ  

#### ಸಂಯೋಜನೆ ಪರೀಕ್ಷೆಯ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

```csharp
// Example integration test for MCP server in C#
[Fact]
public async Task Server_ProcessToolRequest_ReturnsValidResponse()
{
    // Arrange
    var server = new McpServer();
    server.RegisterTool(new CalculatorTool());
    await server.StartAsync();
    
    var request = new McpRequest
    {
        Tool = "calculator",
        Parameters = new Dictionary<string, object>
        {
            ["operation"] = "multiply",
            ["a"] = 6,
            ["b"] = 7
        }
    };
    
    // Act
    var response = await server.ProcessRequestAsync(request);
    
    // Assert
    Assert.NotNull(response);
    Assert.Equal(McpStatusCodes.Success, response.StatusCode);
    // Additional assertions for response content
    
    // Cleanup
    await server.StopAsync();
}
```

### ತುದಿಗೆ ತುದಿ ಪರೀಕ್ಷೆ (ಅತ್ಯುಚ್ಚ ಪದವಿ)

ತುದಿಗೆ ತುದಿ ಪರೀಕ್ಷೆ ಗ್ರಾಹಕದಿಂದ ಸರ್ವರ್‍ವರೆಗೆ ಸಂಪೂರ್ಣ ವ್ಯವಸ್ಥೆಯ ವರ್ತನೆ ಅನ್ನು ಪರಿಶೀಲಿಸುತ್ತದೆ.

#### ಪರೀಕ್ಷಿಸುವುದು ಏನು

1. **ಗ್ರಾಹಕ-ಸರ್ವರ್ ಸಂವಹನ**: ಸಂಪೂರ್ಣ ವಿನಂತಿ-ಪ್ರತಿಕ್ರಿಯೆ ಚಕ್ರಗಳನ್ನು ಪರೀಕ್ಷಿಸಿ  
2. **ನಿಜವಾದ ಗ್ರಾಹಕ SDK ಗಳು**: ನೈಜ ಗ್ರಾಹಕ ಅನುಷ್ಠಾನಗಳೊಂದಿಗೆ ಪರೀಕ್ಷಿಸಿ  
3. **ಲೋಡ್‍ಅಡಿಯಲ್ಲಿ ಕಾರ್ಯಕ್ಷಮತೆ**: ಅನೇಕ samtidನಿಕ ವಿನಂತಿಗಳೊಂದಿಗೆ ವರ್ತನೆಯನ್ನು ಪರಿಶೀಲಿಸಿ  
4. **ದೋಷ ಪುನರ್‍ಪ್ರಾಪ್ತಿ**: ವೈಫಲ್ಯಗಳಿಂದ ವ್ಯವಸ್ಥೆಯ ಪುನರ್ ಕಾಪಾಡುವುದನ್ನು ಪರೀಕ್ಷಿಸಿ  
5. **ದೀರ್ಘಾವಧಿ ಕಾರ್ಯಗಳು**: ಸ್ಟ್ರೀಮಿಂಗ್ ಮತ್ತು ದೀರ್ಘ ಕಾರ್ಯಗಳ ನಿರ್ವಹಣೆಯನ್ನು ಪರೀಕ್ಷಿಸಿ  

#### ತುದಿಗೆ ತುದಿ ಪರೀಕ್ಷೆಯ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

```typescript
// ಟೈಪ್ಸ್ಕ್ರಿಪ್ಟ್‌ನಲ್ಲಿ ಕ್ಲೈಂಟ್‌ನೊಂದಿಗೆ ಉದಾಹರಣೆಯ E2E ಟೆಸ್ಟ್
describe('MCP Server E2E Tests', () => {
  let client: McpClient;
  
  beforeAll(async () => {
    // ಪರೀಕ್ಷಾ ಪರಿಸರದಲ್ಲಿ ಸರ್ವರ್ ಪ್ರಾರಂಭಿಸಿ
    await startTestServer();
    client = new McpClient('http://localhost:5000');
  });
  
  afterAll(async () => {
    await stopTestServer();
  });
  
  test('Client can invoke calculator tool and get correct result', async () => {
    // ಚಟುವಟಿಕೆ
    const response = await client.invokeToolAsync('calculator', {
      operation: 'divide',
      a: 20,
      b: 4
    });
    
    // ದೃಢೀಕರಿಸಿ
    expect(response.statusCode).toBe(200);
    expect(response.content[0].text).toContain('5');
  });
});
```

## MCP ಪರೀಕ್ಷೆಗೆ ಮಾಕಿಂಗ್ ತಂತ್ರಗಳು

ಪರೀಕ್ಷೆಯ ಸಮಯದಲ್ಲಿ ಘಟಕಗಳನ್ನು ಪ್ರತ್ಯೇಕಗೊಳಿಸಲು ಮಾಕಿಂಗ್ ಅವಶ್ಯಕ.

### ಮಾಕ್ ಮಾಡಬೇಕಾದ ಘಟಕಗಳು

1. **ಬಾಹ್ಯ AI ಮಾದರಿಗಳು**: ಅಂದಾಜು ಮಾಡಬಹುದಾದ ಪರೀಕ್ಷೆಗೆ ಮಾದರಿ ಪ್ರತಿಕ್ರಿಯೆಗಳನ್ನು ಮಾಕ್ ಮಾಡಿ  
2. **ಬಾಹ್ಯ ಸೇವೆಗಳು**: API ಅವಲಂಬನೆಗಳನ್ನು ಮಾಕ್ ಮಾಡಿ (ಡೇಟಾಬೇಸ್, ಮೂರನೇ ಪಕ್ಷದ ಸೇವೆಗಳು)  
3. **ಪರಿಶೀಲನೆ ಸೇವೆಗಳು**: ಗುರುತಿನ ಪ್ರೊವೈಡರ್ಗಳನ್ನು ಮಾಕ್ ಮಾಡಿ  
4. **ಸಂಪನ್ಮೂಲ ಒದಗಿಸುವವರು**: ದುಬಾರಿ ಸಂಪನ್ಮೂಲ ನಿರ್ವಹಕರನ್ನು ಮಾಕ್ ಮಾಡಿ  

### ಉದಾಹರಣೆ: AI ಮಾದರಿ ಪ್ರತಿಕ್ರಿಯೆ ಮಾಕಿಂಗ್

```csharp
// C# example with Moq
var mockModel = new Mock<ILanguageModel>();
mockModel
    .Setup(m => m.GenerateResponseAsync(
        It.IsAny<string>(),
        It.IsAny<McpRequestContext>()))
    .ReturnsAsync(new ModelResponse { 
        Text = "Mocked model response",
        FinishReason = FinishReason.Completed
    });

var server = new McpServer(modelClient: mockModel.Object);
```

```python
# Python ಉದಾಹರಣೆ unittest.mock ಸಹಿತ
@patch('mcp_server.models.OpenAIModel')
def test_with_mock_model(mock_model):
    # ಮೋಕ್ ಅನ್ನು ರೂಪಿಸು
    mock_model.return_value.generate_response.return_value = {
        "text": "Mocked model response",
        "finish_reason": "completed"
    }
    
    # ಪರೀಕ್ಷೆಯಲ್ಲಿ ಮೋಕ್ ಬಳಸಿ
    server = McpServer(model_client=mock_model)
    # ಪರೀಕ್ಷೆಯೊಂದಿಗೆ ಮುಂದುವರಿತುಕೊಳ್ಳಿ
```

## ಕಾರ್ಯಕ್ಷಮತೆ ಪರೀಕ್ಷೆ

ಕಾರ್ಯಕ್ಷಮತೆ ಪರೀಕ್ಷೆ ಉತ್ಪಾದನಾ MCP ಸರ್ವರ್‌ಗಳಿಗೆ ಅತ್ಯಂತ ಮುಖ್ಯ.

### ಅಳೆಯಬೇಕು ಏನು

1. **ವಿಳಂಬತೆ**: ವಿನಂತಿಗಳ ಪ್ರತಿಕ್ರಿಯಾ ಸಮಯ  
2. **ಪ್ರವಾಹಮಾನತೆ**: ಸೆಕೆಂಡಿಗೆ ನಿರ್ವಹಿಸಿದ ವಿನಂತಿಗಳು  
3. **ಸಂಪನ್ಮೂಲ ಬಳಕೆ**: CPU, ಮೆಮರಿ, ನೆಟ್ವರ್ಕ್ ಬಳಕೆ  
4. ** samtidಕ ನಿರ್ವಹಣೆ**: ಸಮಾಂತರ ವಿನಂತಿಗಳ ಜೊತೆ ವರ್ತನೆ  
5. **ಸ್ಕೇಲಿಂಗ್ ಲಕ್ಷಣಗಳು**: ಲೋಡ್ ಹೆಚ್ಚಾದಂತೆ ಕಾರ್ಯಕ್ಷಮತೆ  

### ಕಾರ್ಯಕ್ಷಮತೆ ಪರೀಕ್ಷೆ ಉಪಕರಣಗಳು

- **k6**: ಮುಕ್ತ ಸ್ರೋತ ಲೋಡ್ ಪರೀಕ್ಷಾ ಉಪಕರಣ  
- **JMeter**: ವ್ಯಾಪಕ ಕಾರ್ಯಕ್ಷಮತೆ ಪರೀಕ್ಷೆ  
- **Locust**: ಪೈಥಾನ್ ಆಧಾರಿತ ಲೋಡ್ ಪರೀಕ್ಷೆ  
- **Azure Load Testing**: ಕ್ಲೌಡ್ ಆಧಾರಿತ ಕಾರ್ಯಕ್ಷಮತೆ ಪರೀಕ್ಷೆ  

### ಉದಾಹರಣೆ: k6 ಸಹಜ ಲೋಡ್ ಪರೀಕ್ಷೆ

```javascript
// MCP ಸರ್ವರ್ ಲೋಡ್ ಟೆಸ್ಟಿಂಗ್‌ಗಾಗಿ k6 ಸ್ಕ್ರಿಪ್ಟ್
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  vus: 10,  // 10 ವირლ್ಚುಯಲ್ ಬಳಕೆದಾರರು
  duration: '30s',
};

export default function () {
  const payload = JSON.stringify({
    tool: 'calculator',
    parameters: {
      operation: 'add',
      a: Math.floor(Math.random() * 100),
      b: Math.floor(Math.random() * 100)
    }
  });

  const params = {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer test-token'
    },
  };

  const res = http.post('http://localhost:5000/api/tools/invoke', payload, params);
  
  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
  
  sleep(1);
}
```

## MCP ಸರ್ವರ್‌ಗಳ ಒಂದು ಪರೀಕ್ಷಾ ಸ್ವಯಂಚಾಲಿತ ವ್ಯವಸ್ಥೆ

ನಿಮ್ಮ ಪರೀಕ್ಷೆಗಳ ಸ್ವಯಂಚಾಲಿಕೆ ಸತತ ಗುಣಮಟ್ಟ ಮತ್ತು ವೇಗವಾದ ಪ್ರತಿಕ್ರಿಯೆ ವಲಯಗಳನ್ನು ಖಚಿತಪಡಿಸುತ್ತದೆ.

### CI/CD ಏಕರೂಪತೆ
1. **ಪೂಲ್ ರಿಕ್ವೆಸ್ಟ್ ಗಳ ಮೇಲೆ ಯೂನಿಟ್ ಟೆಸ್ಟ್ ಗಳನ್ನು ಚಲಾಯಿಸಿ**: ಕೋಡ್ ಬದಲಾವಣೆಗಳು ಇತ್ತೀಚಿನ ಕಾರ್ಯಾಚರಣೆಯನ್ನು ಹಾಳು ಮಾಡದಿರುವುದನ್ನು ಖಾತ್ರಿಪಡಿಸಿ  
2. **ಸ್ಟೇಜಿಂಗ್ ನಲ್ಲಿ ಇಂಟಿಗ್ರೇಶನ್ ಟೆಸ್ಟ್ ಗಳು**: ಪೂರ್ವ-"+ಉತ್ಪಾದನಾ" ಪರಿಸರಗಳಲ್ಲಿ ಇಂಟಿಗ್ರೇಶನ್ ಟೆಸ್ಟ್ ಗಳನ್ನು ನಡೆಸಿ  
3. **ಪ್ರದರ್ಶನ ಮೂಲಸ್ಥಂಭಗಳು**: ರೀಗ್ರೆಶನ್ ಗಳನ್ನು ಹಿಡಿಯಲು ಪ್ರದರ್ಶನ ಮಾನದಂಡಗಳನ್ನು ಉಳಿಸಿ  
4. **ಸುರಕ್ಷತಾ ಸ್ಕ್ಯಾನ್ ಗಳನ್ನು**: ಪೈಪ್‌ಲೈನ್ ಭಾಗವಾಗಿ ಸುರಕ್ಷತಾ ಪರೀಕ್ಷೆಯನ್ನು ಸ್ವಯಂಚಾಲಿತಗೊಳಿಸಿ  

### ಉದಾಹರಣಾ CI ಪೈಪ್ಲೈನ್ (GitHub Actions)

```yaml
name: MCP Server Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Runtime
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: '8.0.x'
    
    - name: Restore dependencies
      run: dotnet restore
    
    - name: Build
      run: dotnet build --no-restore
    
    - name: Unit Tests
      run: dotnet test --no-build --filter Category=Unit
    
    - name: Integration Tests
      run: dotnet test --no-build --filter Category=Integration
      
    - name: Performance Tests
      run: dotnet run --project tests/PerformanceTests/PerformanceTests.csproj
```
  
## MCP ನಿರ್ದಿಷ್ಟತೆಯ ಅನುಕೂಲತೆಗಾಗಿ ಪರೀಕ್ಷೆ

ನಿಮ್ಮ ಸರ್ವರ್ ಸರಿಯಾಗಿ MCP ನಿರ್ದಿಷ್ಟತೆಯನ್ನು ಅನುಷ್ಟಾನ ಮಾಡುತ್ತಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸಿ.

### ಪ್ರಮುಖ ಅನುಕೂಲತೆ ಪ್ರಾಥಮಿಕ ಕ್ಷೇತ್ರಗಳು

1. **API ಎಂಡ್‌ಪಾಯಿಂಟ್‌ಗಳು**: ಅಗತ್ಯವಿರುವ ಎಂಡ್‌ಪಾಯಿಂಟ್‌ಗಳ ಪರೀಕ್ಷೆ (/resources, /tools, ಮುಂತಾದವು)  
2. **ರಿಕ್ವೆಸ್ಟ್/ಪ್ರತಿಕ್ರಿಯೆ ರೂಪರೆಖೆ**: ಯೋಜನೆಯ ಅನುಕೂಲತೆಯನ್ನು ಮಾನ್ಯಗೊಳಿಸಿ  
3. **ದೋಷ ಕೋಡ್ಸ್**: ವಿವಿಧ ಸಂದರ್ಭಗಳಿಗೆ ಸರಿಯಾದ ಸ್ಥಿತಿಸೂಚಕ ಸಂಖ್ಯೆಗಳ ನಿಜವಾದ ಪರಿಶೀಲನೆ  
4. **ವಿಷಯ ರೀತிகள்**: ವಿಭಿನ್ನ ವಿಷಯ ರೀತಿಗಳ ನಿರ್ವಹಣೆಯನ್ನು ಪರೀಕ್ಷಿಸಿ  
5. **ಅಧಿಕೃತ ತೆರವುಹೋಗುವಿಕೆ**: ನಿರ್ದಿಷ್ಟತೆಗೆ ಅನುಗುಣವಾದ ಅತಿಾಧಿಕೃತ ವಿಧಾನಗಳ ಪರಿಶೀಲನೆ  

### ಅನುಕೂಲತೆ ಪರೀಕ್ಷಾ ತೊಳಕಟ್ಟು

```csharp
[Fact]
public async Task Server_ResourceEndpoint_ReturnsCorrectSchema()
{
    // Arrange
    var client = new HttpClient();
    client.DefaultRequestHeaders.Add("Authorization", "Bearer test-token");
    
    // Act
    var response = await client.GetAsync("http://localhost:5000/api/resources");
    var content = await response.Content.ReadAsStringAsync();
    var resources = JsonSerializer.Deserialize<ResourceList>(content);
    
    // Assert
    Assert.Equal(HttpStatusCode.OK, response.StatusCode);
    Assert.NotNull(resources);
    Assert.All(resources.Resources, resource => 
    {
        Assert.NotNull(resource.Id);
        Assert.NotNull(resource.Type);
        // Additional schema validation
    });
}
```
  
## MCP ಸರ್ವರ್ ಪರಿಣಾಮಕಾರಿ ಪರೀಕ್ಷೆಗೆ ಟಾಪ್ 10 ಸಲಹೆಗಳು

1. **ಪರೀಕ್ಷಾ ಸಾಧನ ವ್ಯಾಖ್ಯಾನಗಳನ್ನು ವಿಭಜಿಸಿ**: ಉಪಕರಣ ತರ್ಕದಿಂದ ಸರಿಯಾಗಿ ಷೇಮಾ ವ್ಯಾಖ್ಯಾನಗಳನ್ನು ಸ್ವತಂತ್ರವಾಗಿ ಪರಿಶೀಲಿಸಿ  
2. **ಪರಿಮಿತಿಯ ಹಾಗೂ ಪರಿಮಿತಿಯ ಹೊರಗಿನ ಪರೀಕ್ಷೆ ಮಾಡಿದಿರಿ**: ಭಾಗಾಂತರ ಕೇಸ್‌ಗಳು ಸೇರಿ ವಿಭಿನ್ನ ಇನ್‌ಪುಟ್‌ಗಳೊಂದಿಗೆ ಉಪಕರಣಗಳನ್ನು ಪರೀಕ್ಷಿಸಿ  
3. **ದೋಷ ಪ್ರತಿಕ್ರಿಯೆಗಳ ಪರಿಶೀಲನೆ ಮಾಡಿ**: ಎಲ್ಲ ಸಾಧ್ಯದೋಷ ಪರಿಸ್ಥಿತಿಗಳಿಗೆ ಸರಿಯಾದ ದೋಷ ನಿರ್ವಹಣೆ ಪರಿಶೀಲಿಸಿ  
4. **ಅಧಿಕೃತ ಲಾಜಿಕ್ ಪರೀಕ್ಷೆ**: ವಿಭಿನ್ನ ಬಳಕೆದಾರ ಪಾತ್ರಗಳಿಗೆ ಸರಿಯಾದ ಪ್ರವೇಶ ನಿಯಂತ್ರಣ ಭದ್ರೀಕರಿಸಿ  
5. **ಪರೀಕ್ಷೆ ವ್ಯಾಪ್ತಿಯನ್ನು ಮೇಲ್ವಿಚಾರಣೆ ಮಾಡಿ**: ಪ್ರಮುಖ ಮಾರ್ಗದ ಕೋಡ್ ಅನ್ನು ಹೆಚ್ಚಿನ ವ್ಯಾಪ್ತಿಗೆ ಸಾಧಿಸುವದಕ್ಕೆ ಪ್ರಯತ್ನಿಸಿ  
6. **ಸ್ಟ್ರೀಮಿಂಗ್ ಪ್ರತಿಕ್ರಿಯೆಗಳ ಪರೀಕ್ಷೆ**: ಸ್ಟ್ರೀಮಿಂಗ್ ವಿಷಯದ ಸರಿಯಾದ ನಿರ್ವಹಣೆಯನ್ನು ಖಚಿತಪಡಿಸಿಕೊಳ್ಳಿ  
7. **ನಿಮಿಷದ ಸಮಸ್ಯೆಗಳ ಅನುಕರಣ ಮಾಡಿ**: ಕುಗ್ಗಿದ ನೆಟ್‌ವರ್ಕ್ ಪರಿಸ್ಥಿತಿಗಳಲ್ಲಿ ವರ್ತನೆ ಅನ್ನು ಪರೀಕ್ಷಿಸಿ  
8. **ಸಂಪನ್ಮೂಲ ಮಿತಿಗಳನ್ನು ಪರೀಕ್ಷಿಸಿ**: ಕೋಟಾ ಅಥವಾ ದರ ಮಿತಿಯ ತಲುಪಿದಾಗ ವರ್ತನೆಯನ್ನು ಪರಿಶೀಲಿಸಿ  
9. **ಪರಿವರ್ತನ ಪರೀಕ್ಷೆಗಳನ್ನು ಸ್ವಯಂಚಾಲಿತಗೊಳಿಸಿ**: ಪ್ರತಿಯೊಂದು ಕೋಡ್ ಬದಲಾವಣೆಯಲ್ಲಿ ಚಲಿಸುವ ತೊಳಕಟ್ಟು ರಚಿಸಿ  
10. **ಪರೀಕ್ಷಾ ಪ್ರಕರಣಗಳನ್ನು ದಾಖಲಿಸಿ**: ಪರೀಕ್ಷಾ ಸಂದರ್ಭಗಳ ಸ್ಪಷ್ಟ ದಾಖಲೆ ಉಳಿಸಿ  

## ಸಾಮಾನ್ಯ ಪರೀಕ್ಷಾ ದೋಷಗಳು

- **ಹ್ಯಾಪಿ ಪಾಥ್ ಮೇಲ್ಮೈಮಾಳಿ**: ದೋಷ ಪ್ರಕರಣಗಳನ್ನು ಸಂಪೂರ್ಣವಾಗಿ ಪರೀಕ್ಷಿಸುವುದು ಖಚಿತಪಡಿಸಿಕೊಳ್ಳಿ  
- **ಪ್ರದರ್ಶನ ಪರೀಕ್ಷೆಯನ್ನು ನಿರ್ಲಕ್ಷಿಸುವುದು**: ಉತ್ಪಾದನೆಯಲ್ಲಿನ ಸಮಸ್ಯೆಗಳನ್ನೇ ಮುಂಚಿತವಾಗಿ ಗುರುತಿಸಿ  
- **ಒಳಗೊಂಡು ಮಾತ್ರ ಪರೀಕ್ಷೆ**: ಘಟಕ, ಇಂಟಿಗ್ರೇಶನ್ ಮತ್ತು E2E ಪರೀಕ್ಷೆಗಳ ಘನೀಯ ಸಂಯೋಜನೆ ಮಾಡಿ  
- **ಅಧೂರಾ API ವ್ಯಾಪ್ತಿ**: ಎಲ್ಲ ಎಂಡ್‌ಪಾಯಿಂಟ್‌ಗಳು ಮತ್ತು ವೈಶಿಷ್ಟ್ಯಗಳು ಪರೀಕ್ಷಿತವಾಗಿರಲಿ  
- **ಅಸಮರ್ಥ ಪರೀಕ್ಷಾ ಪರಿಸರಗಳು**: ಒಂದೇ ತರಹದ ಪರೀಕ್ಷা ಪರಿಸರಕ್ಕಾಗಿ ಕಂಟೈನರ್‌ಗಳನ್ನು ಬಳಸಿಕೊಳ್ಳಿ  

## ಸಂಕ್ಷೇಪ

ಅತ್ಯಧಿಕ ವಿಶ್ವಾಸಾರ್ಹ, ಸುಧಾರಿತ MCP ಸರ್ವರ್‌ಗಳನ್ನು ಅಭಿವೃದ್ಧಿಪಡಿಸಲು ಸಮಗ್ರ ಪರೀಕ್ಷಾ ತಂತ್ರಾಂಶ ಅಗತ್ಯವಿದೆ. ಈ ಮಾರ್ಗದರ್ಶನದಲ್ಲಿ ನೀಡಲಾದ ಉತ್ಕೃಷ್ಟ ಅಭ್ಯಾಸಗಳು ಮತ್ತು ಸಲಹೆಗಳನ್ನು ಅನುಷ್ಠಾನಗೊಳಿಸುವ ಮೂಲಕ, ನಿಮ್ಮ MCP ಅನುಷ್ಠಾನಗಳು ಅತ್ಯುತ್ತಮ ಗುಣಮಟ್ಟ, ನಂಬಕತೆ ಮತ್ತು ಪ್ರದರ್ಶನ ಮಟ್ಟವನ್ನು ತಲುಪುವಂತೆ ಮಾಡಬಹುದು.

## ಮುಖ್ಯ ಪಾಠಗಳು

1. **ಉಪಕರಣ ವಿನ್ಯಾಸ**: ಏಕವಿಧಾಯಕರ ಭೂಮಿಕೆಯನ್ನು ಅನುಸರಿಸಿ, ಆಧಾರ ಹೋಲಿಕೆ (ಡಿಪೆಂಡೆನ್ಸಿ ಇಂಜೆಕ್ಷನ್) ಉಪಯೋಗಿಸಿ ಮತ್ತು ಸಂಯೋಜನೀಯ ಉದ್ದೇಶಕ್ಕಾಗಿ ವಿನ್ಯಾಸ ಮಾಡಿ  
2. **ಾಶೇಮಾ ವಿನ್ಯಾಸ**: ಸ್ಪಷ್ಟ, ಚೆನ್ನಾಗಿ ಲಿಖಿತ ಷೇಮಾಗಳನ್ನು ಸರಿಯಾದ ಮಾನ್ಯತೆ ಮಿತಿಗಳೊಂದಿಗೆ ರಚಿಸಿ  
3. **ದೋಷ ನಿರ್ವಹಣೆ**: ಸೌಲಭ್ಯಶೀಲ ದೋಷ ನಿರ್ವಹಣೆ, ಸಂಸ್ಥಿತ ದೋಷ ಪ್ರತಿಕ್ರಿಯೆಗಳು ಮತ್ತು ಮುಕ್ತಿ ಲಾಜಿಕ್ ಅನುಷ್ಠಾನ ಮಾಡಿ  
4. **ಪ್ರದರ್ಶನ**: ಕ್ಯಾಚಿಂಗ್, ಅಸಿಂಕ್ರೋನಸ್ ಪ್ರಕ್ರಿಯೆ ಮತ್ತು ಸಂಪನ್ಮೂಲ ನಿರ್ಬಂಧನೆ ಉಪಯೋಗಿಸಿ  
5. **ಸುರಕ್ಷತೆ**: ಸಂಪೂರ್ಣ ಇನ್‌ಪುಟ್ ಪರಿಶೀಲನೆ, ಅಧಿಕೃತ ಪರಿಶೀಲನೆ ಮತ್ತು ಸಂವೇದನಾಶೀಲ ಡೇಟಾ ನಿರ್ವಹಣೆ ಅನ್ವಯಿಸಿ  
6. **ಪರೀಕ್ಷೆ**: ಸಮಗ್ರ ಘಟಕ, ಇಂಟಿಗ್ರೇಶನ್ ಮತ್ತು ಅಂತ್ಯ-ನಂತರ ಪರೀಕ್ಷೆ ರಚಿಸಿ  
7. **ಸಂಸ್ಕರಣಾ ರಚನೆಗಳು**: ಸರಪಳಿ, ಡಿಸ್ಪಾಚರ್ ಮತ್ತು ಸಮಾಂತರ ಪ್ರಕ್ರಿಯೆಗಳಂತಹ ಸ್ಥಾಪಿತರಾದ ಮಾದರಿಯನ್ನು ಅನ್ವಯಿಸಿ  

## ಅಭ್ಯಾಸ

ಕೆಳಗಿನ ಪರಿಭಾಷೆಯೊಂದಿಗೆ ಒಂದು ದಾಖಲೆ ಪ್ರಕ್ರಿಯೆ ವ್ಯವಸ್ಥೆಗಾಗಿ MCP ಉಪಕರಣ ಮತ್ತು ಕಾರ್ಯಪ್ರವಾಹವನ್ನು ವಿನ್ಯಾಸ ಮಾಡಿ:

1. ಹಲವಾರು ಸ್ವರೂಪಗಳಲ್ಲಿ ದಾಖಲೆಗಳನ್ನು ಸ್ವೀಕರಿಸುತ್ತದೆ (PDF, DOCX, TXT)  
2. ದಾಖಲೆಯಿಂದ ಪಠ್ಯ ಮತ್ತು ಪ್ರಮುಖ ಮಾಹಿತಿಯನ್ನು ಹೊರತೆಗೆದುಕೊಳ್ಳುತ್ತದೆ  
3. ದಾಖಲೆಗಳ ಪ್ರಕಾರ ಮತ್ತು ವಿಷಯದಂತೆ ವರ್ಗೀಕರಿಸುತ್ತದೆ  
4. ಪ್ರತಿ ದಾಖಲೆಗಾಗಿ ಸಾರಾಂಶವನ್ನು ರಚಿಸುತ್ತದೆ  

ಈ ಸನ್ನಿವೇಶಕ್ಕೆ ಅತ್ಯುತ್ತಮವಾದ ಉಪಕರಣ ಷೇಮಾ, ದೋಷ ನಿರ್ವಹಣೆ ಮತ್ತು ಕಾರ್ಯಪ್ರವಾಹ ಮಾದರಿಯನ್ನು ಅನುಷ್ಠಾನಗೊಳಿಸಿ. ನೀವು ಹೇಗೆ ಈ ಅನುಷ್ಠಾನವನ್ನು ಪರೀಕ್ಷಿಸುವಿರೋ ಕುರಿತು ಯೋಚಿಸಿರಿ.

## ಸಂಪನ್ಮೂಲಗಳು

1. ಇತ್ತೀಚಿನ ಅಭಿವೃದ್ಧಿಗಳ ಬಗ್ಗೆ ನವೀಕರಣಗಳಿಗಾಗಿ [Azure AI Foundry Discord Community](https://aka.ms/foundrydevs) ನಲ್ಲಿ MCP ಸಮುದಾಯಕ್ಕೆ ಸೇರುವಿರಿ  
2. ಮುಕ್ತಮೂಲ [MCP ಯೋಜನೆಗಳಿಗೆ](https://github.com/modelcontextprotocol) ಸಹಕಾರ ನೀಡಿ  
3. ನಿಮ್ಮ ಸಂಸ್ಥೆಯ AI ಉಪಕ್ರಮಗಳಲ್ಲಿ MCP ಸಿದ್ಧಾಂತಗಳನ್ನು ಅನ್ವಯಿಸಿ  
4. ನಿಮ್ಮ ಕೈಗಾರಿಕೆಗಾಗಿ ವಿಶೇಷ MCP ಅನುಷ್ಠಾನಗಳನ್ನು ಅನ್ವೇಷಿಸಿ  
5. ಬಹುಮಾಧ್ಯಮ ಇಂಟಿಗ್ರೇಶನ್ ಅಥವಾ ಉದ್ಯಮ ಅಪ್ಲಿಕೇಶನ್ ಇಂಟಿಗ್ರೇಶನ್ ಮುಂತಾದ MCP ವಿಷಯಗಳ ಮೇಲ್ಸ್ ತರಬೇತಿಗಳನ್ನು ಪರಿಗಣಿಸಿ  
6. [Hands on Lab](../10-StreamliningAIWorkflowsBuildingAnMCPServerWithAIToolkit/README.md) ಮೂಲಕ ಕಲಿತ ಸಿದ್ಧಾಂತಗಳನ್ನು ಬಳಸಿ ನಿಮ್ಮ MCP ಉಪಕರಣಗಳು ಮತ್ತು ಕಾರ್ಯಪ್ರವಾಹಗಳನ್ನು ನಿರ್ಮಿಸುವುದಕ್ಕೆ ಪ್ರಯತ್ನಿಸಿ  

## ಮುಂದೇನು

ಮುಂದಿನದು: [ಕೇಸ್ ಅಧ್ಯಯನಗಳು](../09-CaseStudy/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**ಗಮನಿಕೆ**:
ಈ ದಾಖಲೆಯನ್ನು AI ಅನುವಾದ ಸೇವೆ [Co-op Translator](https://github.com/Azure/co-op-translator) ಬಳಸಿ ಅನುವಾದಿಸಲಾಗಿದೆ. ನಾವು ಶುದ್ಧತೆಯತ್ತ ಪ್ರಯತ್ನಿಸುತ್ತಿರುವ باوجود, ಸ್ವಯಂಚಾಲಿತ ಅನುವಾದದಲ್ಲಿ ದೋಷಗಳು ಅಥವಾ ತಪ್ಪುಗಳು ಇರಬಹುದು ಎಂಬುದನ್ನು ದಯವಿಟ್ಟು ಗಮನಿಸಿರಿ. ಮೂಲ ದಾಖಲೆ ಅದರ ಸ್ವದೇಶಿ ಭಾಷೆಯಲ್ಲಿನ ಪ್ರತಿಯೇ ಪ್ರಾಮಾಣಿಕ ಮೂಲ ಎಂದು ಪರಿಗಣಿಸಬೇಕು. ಮಹತ್ವದ ಮಾಹಿತಿಗಾಗಿ, ವೃತ್ತಿಪರ ಮಾನವ ಅನುವಾದವನ್ನು ಸಲಹೆ ಮಾಡಲಾಗುತ್ತದೆ. ಈ ಅನುವಾದದ ಬಳಕೆಯಿಂದ ಉಂಟಾಗುವ ಯಾವುದೆ ತಪ್ಪು ಅರ್ಥಗುರುತುಗಳಿಗಾಗಿ ನಾವು ಹೊಣೆಗಾರರಾಗುವುದಿಲ್ಲ.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->