# MCP ਵਿਕਾਸ ਦੀਆਂ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ

[![MCP ਵਿਕਾਸ ਦੀਆਂ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ](../../../translated_images/pa/09.d0f6d86c9d72134c.webp)](https://youtu.be/W56H9W7x-ao)

_(ਇਸ ਪਾਠ ਦਾ ਵੀਡੀਓ ਦੇਖਣ ਲਈ ਉਪਰ ਦਿੱਤੀ ਤਸਵੀਰ 'ਤੇ ਕਲਿਕ ਕਰੋ)_

## ਜਾਇਜ਼ਾ

ਇਹ ਪਾਠ MCP ਸਰਵਰਾਂ ਅਤੇ ਫੀਚਰਾਂ ਨੂੰ ਪ੍ਰੋਡਕਸ਼ਨ ਵਾਤਾਵਰਨਾਂ ਵਿੱਚ ਵਿਕਸਤ ਕਰਨ, ਟੈਸਟ ਕਰਨ ਅਤੇ ਤੈਨਾਤ ਕਰਨ ਲਈ ਉੱਚਤਮ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ 'ਤੇ ਕੇਂਦ੍ਰਿਤ ਹੈ। ਜਿਵੇਂ ਜਿਵੇਂ MCP ਪਰਿਵਾਰਿਕ ਪ੍ਰਣਾਲੀਆਂ ਜਟਿਲਤਾ ਅਤੇ ਮਹੱਤਵ ਵਿੱਚ ਵੱਧ ਰਹੀਆਂ ਹਨ, ਸਥਾਪਤ ਪੈਟਰਨਾਂ ਦੀ ਪਾਲਣਾ ਕਰਨ ਨਾਲ ਭਰੋਸੇਯੋਗਤਾ, ਸੰਭਾਲਯੋਗਤਾ ਅਤੇ ਇੰਟਰਆਪਰੇਬਿਲਟੀ ਯਕੀਨੀ ਬਣਾਈ ਜਾਂਦੀ ਹੈ। ਇਹ ਪਾਠ ਵਾਸਤਵਿਕ ਦੁਨੀਆ ਚ MCP ਲਾਗੂ ਕਰਨ ਤੋਂ ਮਿਲੀ ਅਮਲੀ ਸਿਆਣਪ ਨੂੰ ਇਕੱਠਾ ਕਰਦਾ ਹੈ ਤਾਂ ਜੋ ਤੁਸੀਂ ਮਜ਼ਬੂਤ, ਪ੍ਰਭਾਵਸ਼ਾਲੀ ਸਰਵਰ ਬਣਾਉਣ ਵਿੱਚ ਮਦਦ ਪਾ ਸਕੋ ਜਿਸ ਵਿੱਚ ਪ੍ਰਭਾਵਸ਼ਾਲੀ ਸਰੋਤ, ਪ੍ਰੋਂਪਟਸ ਅਤੇ ਉਪਕਰਨ ਸ਼ਾਮਿਲ ਹਨ।

## ਸਿੱਖਣ ਦੇ ਲਕੜੀ

ਇਸ ਪਾਠ ਦੇ ਅੰਤ ਤੱਕ, ਤੁਸੀਂ ਸਮਰੱਥ ਹੋਵੋਗੇ:

- MCP ਸਰਵਰ ਅਤੇ ਫੀਚਰ ਡਿਜ਼ਾਈਨ ਵਿੱਚ ਉਦਯੋਗ ਦੀ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ ਲਾਗੂ ਕਰਨਾ
- MCP ਸਰਵਰਾਂ ਲਈ ਵਿਸਤਾਰਪੂਰਕ ਟੈਸਟਿੰਗ ਰਣਨੀਤੀਆਂ ਬਣਾਉਣਾ
- ਜਟਿਲ MCP ਐਪਲੀਕੇਸ਼ਨਾਂ ਲਈ ਪ੍ਰਭਾਵਸ਼ਾਲੀ, ਦੁਬਾਰਾ ਵਰਤੋਂ ਯੋਗ ਵਰਕਫ਼ਲੋ ਪੈਟਰਨ ਡਿਜ਼ਾਈਨ ਕਰਨਾ
- MCP ਸਰਵਰਾਂ ਵਿੱਚ ਸਹੀ ਐਰਰ ਹੈਂਡਲਿੰਗ, ਲੌਗਿੰਗ ਅਤੇ ਵੇਖਣਯੋਗਤਾ ਲਾਗੂ ਕਰਨਾ
- ਪ੍ਰਦਰਸ਼ਨ, ਸੁਰੱਖਿਆ ਅਤੇ ਸੰਭਾਲਯੋਗਤਾ ਲਈ MCP ਲਾਗੂ ਕਰਨ ਨੂੰ ਅਪਟੀਮਾਈਜ਼ ਕਰਨਾ

## MCP ਮੁੱਖ ਸਿਧਾਂਤ

ਖਾਸ ਲਾਗੂ ਕਰਨ ਵਾਲੀਆਂ ਪ੍ਰਥਾਵਾਂ ਵਿੱਚ ਲੱਗਣ ਤੋਂ ਪਹਿਲਾਂ, ਇਹ ਜਰੂਰੀ ਹੈ ਕਿ ਤੁਸੀਂ MCP ਵਿਕਾਸ ਨੂੰ ਪ੍ਰਭਾਵਸ਼ਾਲੀ ਬਣਾਉਣ ਵਾਲੇ ਮੁੱਖ ਸਿਧਾਂਤਾਂ ਨੂੰ ਸਮਝੋ:

1. **ਮਿਆਰੀਕ੍ਰਿਤ ਸੰਚਾਰ**: MCP ਆਪਣੀ ਬੁਨਿਆਦ ਵਜੋਂ JSON-RPC 2.0 ਨੂੰ ਵਰਤਦਾ ਹੈ, ਜੋ ਸਾਰੀਆਂ ਲਾਗੂ ਕਰਨਗੀਆਂ ਵਿੱਚ ਬੇਨਤੀ, ਜਵਾਬ ਅਤੇ ਐਰਰ ਹੈਂਡਲਿੰਗ ਲਈ ਲਗਾਤਾਰ ਫਾਰਮੈਟ ਮੁਹੱਈਆ ਕਰਦਾ ਹੈ।

2. **ਉਪਭੋਗਤਾ-ਕੇਂਦਰਤ ਡਿਜ਼ਾਈਨ**: ਹਮੇਸ਼ਾ ਆਪਣੇ MCP ਲਾਗੂ ਕਰਨ ਵਿੱਚ ਉਪਭੋਗਤਾ ਦੀ ਸਹਿਮਤੀ, ਨਿਯੰਤਰਣ ਅਤੇ ਪਾਰਦਰਸ਼ਤਾ ਨੂੰ ਪ੍ਰਾਥਮਿਕਤਾ ਦਿਓ।

3. **ਸੁਰੱਖਿਆ ਪਹਿਲਾ**: ਮਜ਼ਬੂਤ ਸੁਰੱਖਿਆ ਉਪਾਇ ਲਾਗੂ ਕਰੋ ਜਿਵੇਂ ਪ੍ਰਮਾਣਿਕਤਾ, ਅਧਿਕਾਰ, ਪ੍ਰਮਾਣੀਕਰਨ ਅਤੇ ਦਰ ਸੀਮਾ।

4. **ਮੋਡੀਊਲਰ ਆਰਕੀਟੈਕਚਰ**: MCP ਸਰਵਰਾਂ ਨੂੰ ਇੱਕ ਮੋਡੀਊਲਰ ਢੰਗ ਨਾਲ ਡਿਜ਼ਾਈਨ ਕਰੋ, ਜਿੱਥੇ ਹਰ ਇਕ ਮਸ਼ੀਨ ਅਤੇ ਸਰੋਤ ਦਾ ਸਪਸ਼ਟ, ਕੇਂਦਰਿਤ ਉਦੇਸ਼ ਹੋਵੇ।

5. **ਸਟੇਟਫੁਲ ਕਨੈਕਸ਼ਨ**: MCP ਦੀ ਸਮਰੱਥਾ ਦਾ ਲਾਭ ਉਠਾਓ ਜੋ ਕਿ ਕਈ ਬੇਨਤੀਆਂ ਵਿੱਚ ਸਥਿਤੀ ਬਰਕਰਾਰ ਰੱਖੇ, ਇਸ ਨਾਲ ਜ਼ਿਆਦਾ ਸਮੁੱਚੇ ਅਤੇ ਸੰਦਰਭ-ਅਧਾਰਿਤ ਇੰਟਰੈਕਸ਼ਨ ਹੋ ਸਕਦੇ ਹਨ।

## ਅਧਿਕਾਰਿਕ MCP ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ

ਹੇਠਲੇ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ ਮਾਡਲ ਕੰਟੈਕਸਟ ਪ੍ਰੋਟੋਕਾਲ ਦੇ ਅਧਿਕਾਰਿਕ دستਾਵੇਜ਼ ਤੋਂ ਲਏ ਗਏ ਹਨ:

### ਸੁਰੱਖਿਆ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ

1. **ਉਪਭੋਗਤਾ ਦੀ ਸਹਿਮਤੀ ਅਤੇ ਨਿਯੰਤਰਣ**: ਡੇਟਾ ਤੱਕ ਪਹੁੰਚ ਜਾਂ ਕਾਰਵਾਈ ਕਰਨ ਤੋਂ ਪਹਿਲਾਂ ਸਪਸ਼ਟ ਉਪਭੋਗਤਾ ਦੀ ਸਹਿਮਤੀ ਲੋੜੀਂਦੀ ਹੈ। ਕਿਹੜਾ ਡੇਟਾ ਸਾਂਝਾ ਕੀਤਾ ਜਾ ਰਿਹਾ ਹੈ ਅਤੇ ਕਿਹੜੀਆਂ ਕਾਰਵਾਈਆਂ ਅਧਿਕ੍ਰਿਤ ਹਨ, ਇਸ 'ਤੇ ਸਪਸ਼ਟ ਨਿਯੰਤਰਣ ਦਿਓ।

2. **ਡੇਟਾ ਪ੍ਰਾਈਵੇਸੀ**: ਸਿਰਫ਼ ਸਪਸ਼ਟ ਸਹਿਮਤੀ ਨਾਲ ਉਪਭੋਗਤਾ ਦਾ ਡੇਟਾ ਪ੍ਰਦਰਸ਼ਿਤ ਕਰੋ ਅਤੇ ਇਸ ਨੂੰ ਉਚਿਤ ਪਹੁੰਚ ਨਿਯੰਤਰਣ ਨਾਲ ਸੁਰੱਖਿਅਤ ਰੱਖੋ। ਬਿਨਾ ਅਧਿਕਾਰ ਦੇ ਡੇਟਾ ਸੰਜੋਨ ਤੋਂ ਬਚਾਓ।

3. **ਉਪਕਰਨ ਸੁਰੱਖਿਆ**: ਕਿਸੇ ਵੀ ਯੰਤਰ ਨੂੰ ਕਾਲ ਕਰਨ ਤੋਂ ਪਹਿਲਾਂ ਸਪਸ਼ਟ ਉਪਭੋਗਤਾ ਦੀ ਸਹਿਮਤੀ ਲੋੜੀਂਦੀ ਹੈ। ਯਕੀਨੀ ਬਣਾਓ ਕਿ ਉਪਭੋਗਤਾ ਹਰ ਉਪਕਰਨ ਦੀ ਕਾਰਜਸ਼ੀਲਤਾ ਨੂੰ ਸਮਝਦਾ ਹੈ ਅਤੇ ਮਜ਼ਬੂਤ ਸੁਰੱਖਿਆ ਸੀਮਾਵਾਂ ਲਾਗੂ ਹਨ।

4. **ਉਪਕਰਨ ਅਨੁਮਤੀ ਨਿਰੰਤਰਣ**: ਕਨੈਕਸ਼ਨ ਦੌਰਾਨ ਕੇਵਲ ਉਹ ਉਪਕਰਨ ਵਰਤੇ ਜਾ ਸਕਦੇ ਹਨ ਜਿਹੜੇ ਮਾਡਲ ਨੂੰ ਵਿਸ਼ੇਸ਼ ਤੌਰ 'ਤੇ ਅਨੇਕ ਕਰਕੇ ਅਨੁਮਤ ਹਨ।

5. **ਪਰਮਾਣਿਕਤਾ**: ਉਪਕਰਨਾਂ, ਸਰੋਤਾਂ ਜਾਂ ਸੰਵੇਦਨਸ਼ੀਲ ਕਾਰਵਾਈਆਂ ਤੱਕ ਪਹੁੰਚ ਦੇਣ ਤੋਂ ਪਹਿਲਾਂ ਠੀਕ ਪਰਮਾਣਿਕਤਾ ਲੋੜੀਂਦੀ ਹੈ, ਜਿਵੇਂ API ਕੰਢੇ, OAuth ਟੋਕਨ ਜਾਂ ਹੋਰ ਸੁਰੱਖਿਅਤ ਪਰਮਾਣਿਕਤਾ ਤਰੀਕੇ।

6. **ਪੈਰਾਮੀਟਰ ਸੱਚਾਈ**: ਸਾਰੀਆਂ ਉਪਕਰਨ ਕਾਲਾਂ ਲਈ ਪੈਰਾਮੀਟਰਾਂ ਦੀ ਸਹੀ ਜਾਂਚ ਲੱਗਦੀ ਹੈ ਤਾਂ ਜੋ ਤਰ੍ਹਾਂ-ਤਰ੍ਹਾਂ ਦੇ ਗਲਤ ਜਾਂ ਖਤਰਨਾਕ ਇਨਪੁੱਟ ਤੋਂ ਬਚਾਅ ਹੋਵੇ।

7. **ਰੋਕ-ਥਾਮ ਸੀਮਾ**: ਦੁਰਪਯੋਗ ਤੋਂ ਬਚਾਉ ਅਤੇ ਸਰਵਰ ਸਰੋਤਾਂ ਦਾ ਨਿਆਂਸੰਗਤਾ ਨਾਲ ਉਪਯੋਗ ਯਕੀਨੀ ਬਣਾਉਣ ਲਈ ਦਰ ਸੀਮਾ ਲਾਗੂ ਕਰੋ।

### ਲਾਗੂ ਕਰਨਾ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ

1. **ਸਮਰੱਥਾ ਬਾਰਗੇਨਿੰਗ**: ਜੁੜਨ ਵੇਲੇ, ਸਹਿਯੋਗੀ ਫੀਚਰਾਂ, ਪ੍ਰੋਟੋਕੋਲ ਵਰਜਨਾਂ, ਉਪਲਬਧ ਉਪਕਰਨਾਂ ਅਤੇ ਸਰੋਤਾਂ ਬਾਰੇ ਜਾਣਕਾਰੀ ਸਾਂਝਾ ਕਰੋ।

2. **ਉਪਕਰਨ ਡਿਜ਼ਾਈਨ**: ਕੇਂਦਰਿਤ ਉਪਕਰਨ ਬਣਾਓ ਜੋ ਇੱਕ ਜ਼ਿਆਦਾ ਚੰਗੀ ਤਰ੍ਹਾਂ ਕੰਮ ਕਰਦੇ ਹਨ, ਇੱਕ ਜਹਾੜੂ ਵੱਡੇ ਉਪਕਰਨ ਦੀ ਥਾਂ।

3. **ਐਰਰ ਹੈਂਡਲਿੰਗ**: ਮਿਆਰੀਕ੍ਰਿਤ ਐਰਰ ਸੁਨੇਹੇ ਅਤੇ ਕੋਡ ਲਾਗੂ ਕਰੋ ਤਾਂ ਜੋ ਸਮੱਸਿਆਵਾਂ ਨੂੰ ਪਛਾਣਿਆ ਜਾ ਸਕੇ, ਨਿੱਗੜੇ ਮਾਮਲੇ ਸੂਖਮ ਤਰੀਕੇ ਨਾਲ ਸੰਭਾਲੇ ਜਾ ਸਕਣ ਅਤੇ ਕਾਰਜਵਾਹੀਯੋਗ ਫੀਡਬੈਕ ਪ੍ਰੋਵਾਈਡ ਕੀਤਾ ਜਾ ਸਕੇ।

4. **ਲੌਗਿੰਗ**: ਪ੍ਰੋਟੋਕਾਲ ਇੰਟਰੈਕਸ਼ਨਾਂ ਦੀ ਆਡੀਟਿੰਗ, ਡੀਬੱਗਿੰਗ ਅਤੇ ਨਿਗਰਾਨੀ ਲਈ ਸੰਰਚਿਤ ਲੌਗ ਸੈਟ ਕਰੋ।

5. **ਪ੍ਰਗਤੀ ਟ੍ਰੈਕਿੰਗ**: ਲੰਬੇ ਸਮੇਂ ਚੱਲ ਰਹੀ ਕਾਰਵਾਈਆਂ ਲਈ, ਪ੍ਰਗਤੀ ਅਪਡੇਟ ਦਿੱਤੀ ਜਾਵੇ ਤਾਂ ਜੋ ਉਪਭੋਗਤਾ ਇੰਟਰਫੇਸ ਜਵਾਬ ਦੇ ਸਕਣ।

6. **ਬੇਨਤੀ ਰੱਦ ਕਰਨਾ**: ਕਲਾਇੰਟਾਂ ਨੂੰ ਸੁਰਤ ਬੇਨਤੀਆਂ ਰੱਦ ਕਰਨ ਦੀ ਆਗਿਆ ਦਿਓ ਜਿਹੜੀਆਂ ਹੁਣ ਜ਼ਰੂਰੀ ਨਹੀਂ ਹਨ ਜਾਂ ਜ਼ਿਆਦਾ ਸਮਾਂ ਲੈ ਰਹੀਆਂ ਹਨ।

## ਹੋਰ ਸੰਦਰਭ

MCP ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ ਬਾਰੇ ਸਭ ਤੋਂ ਤਾਜ਼ਾ ਜਾਣਕਾਰੀ ਲਈ, ਇਹਨਾਂ ਸੰਦਰਭਾਂ ਨੂੰ ਵੇਖੋ:

- [MCP ਡਾਕੂਮੈਂਟੇਸ਼ਨ](https://modelcontextprotocol.io/)
- [MCP ਵਿਸ਼ੇਸ਼ਤਾ (2025-11-25)](https://spec.modelcontextprotocol.io/specification/2025-11-25/)
- [GitHub ਰਿਪੋਜ਼ਟਰੀ](https://github.com/modelcontextprotocol)
- [ਸੁਰੱਖਿਆ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ](https://modelcontextprotocol.io/specification/draft/basic/security_best_practices)
- [OWASP MCP ਸਿਖਰ 10](https://microsoft.github.io/mcp-azure-security-guide/mcp/) - ਸੁਰੱਖਿਆ ਖਤਰੇ ਅਤੇ ਉਪਾਅ
- [MCP ਸੁਰੱਖਿਆ ਸਿਮੀਨਾਰ ਵਰਕਸ਼ਾਪ (ਸ਼ੇਰਪਾ)](https://azure-samples.github.io/sherpa/) - ਹੈਂਡਸ-ਆਨ ਸੁਰੱਖਿਆ ਟ੍ਰੇਨਿੰਗ

## ਅਮਲੀ ਲਾਗੂ ਕਰਨ ਦੇ ਉਦਾਹਰਨ

### ਉਪਕਰਨ ਡਿਜ਼ਾਈਨ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ

#### 1. ਇਕਲੌਤਾ ਜ਼ਿੰਮੇਵਾਰੀ ਸਿਧਾਂਤ

ਹਰ MCP ਉਪਕਰਨ ਦਾ ਸਪਸ਼ਟ, ਕੇਂਦਰਿਤ ਉਦੇਸ਼ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ। ਇਕੱਠੇ ਬਹੁਤ ਸਾਰੇ ਮਾਮਲੇ ਸੰਭਾਲਨ ਵਾਲੇ ਵੱਡੇ ਉਪਕਰਨ ਬਣਾਉਣ ਦੀ ਥਾਂ, ਖਾਸ ਕਾਰਜਾਂ ਲਈ ਵਿਸ਼ੇਸ਼ ਉਪਕਰਨ ਬਣਾਓ ਜੋ ਉਨ੍ਹਾਂ ਵਿੱਚ ਮਾਹਿਰ ਹੋਣ।

```csharp
// A focused tool that does one thing well
public class WeatherForecastTool : ITool
{
    private readonly IWeatherService _weatherService;
    
    public WeatherForecastTool(IWeatherService weatherService)
    {
        _weatherService = weatherService;
    }
    
    public string Name => "weatherForecast";
    public string Description => "Gets weather forecast for a specific location";
    
    public ToolDefinition GetDefinition()
    {
        return new ToolDefinition
        {
            Name = Name,
            Description = Description,
            Parameters = new Dictionary<string, ParameterDefinition>
            {
                ["location"] = new ParameterDefinition
                {
                    Type = ParameterType.String,
                    Description = "City or location name"
                },
                ["days"] = new ParameterDefinition
                {
                    Type = ParameterType.Integer,
                    Description = "Number of forecast days",
                    Default = 3
                }
            },
            Required = new[] { "location" }
        };
    }
    
    public async Task<ToolResponse> ExecuteAsync(IDictionary<string, object> parameters)
    {
        var location = parameters["location"].ToString();
        var days = parameters.ContainsKey("days") 
            ? Convert.ToInt32(parameters["days"]) 
            : 3;
            
        var forecast = await _weatherService.GetForecastAsync(location, days);
        
        return new ToolResponse
        {
            Content = new List<ContentItem>
            {
                new TextContent(JsonSerializer.Serialize(forecast))
            }
        };
    }
}
```

#### 2. ਇਕਸਾਰ ਐਰਰ ਹੈਂਡਲਿੰਗ

ਮਜ਼ਬੂਤ ਐਰਰ ਹੈਂਡਲਿੰਗ ਲਾਗੂ ਕਰੋ ਜਿੱਥੇ ਜਾਣਕਾਰੀਮੁੱਲਕ ਐਰਰ ਸੁਨੇਹੇ ਅਤੇ ਉਚਿਤ ਮੁੜ ਸੰਭਾਲ ਤਕਨੀਕਾਂ ਸ਼ਾਮਿਲ ਹੋਣ।

```python
# ਵਿਆਪਕ ਤਰੁਟੀ ਸੰਭਾਲ ਨਾਲ ਪਾਈਥਨ ਉਦਾਹਰਨ
class DataQueryTool:
    def get_name(self):
        return "dataQuery"
        
    def get_description(self):
        return "Queries data from specified database tables"
    
    async def execute(self, parameters):
        try:
            # ਪੈਰਾਮੀਟਰ ਤਸਦੀਕ
            if "query" not in parameters:
                raise ToolParameterError("Missing required parameter: query")
                
            query = parameters["query"]
            
            # ਸੁਰੱਖਿਆ ਤਸਦੀਕ
            if self._contains_unsafe_sql(query):
                raise ToolSecurityError("Query contains potentially unsafe SQL")
            
            try:
                # ਸਮਾਂ-ਸੀਮਾ ਵਾਲਾ ਡੇਟਾਬੇਸ ਓਪਰੇਸ਼ਨ
                async with timeout(10):  # 10 ਸੈਕਿੰਡ ਸਮਾਂ-ਸੀਮਾ
                    result = await self._database.execute_query(query)
                    
                return ToolResponse(
                    content=[TextContent(json.dumps(result))]
                )
            except asyncio.TimeoutError:
                raise ToolExecutionError("Database query timed out after 10 seconds")
            except DatabaseConnectionError as e:
                # ਕਨੈਕਸ਼ਨ ਸਮੱਸਿਆਵਾਂ ਅਸਥਾਇੀ ਹੋ ਸਕਦੀਆਂ ਹਨ
                self._log_error("Database connection error", e)
                raise ToolExecutionError(f"Database connection error: {str(e)}")
            except DatabaseQueryError as e:
                # ਪੁੱਛ ਤਾਂਚੀਆਂ ਦੀਆਂ ਗੜਬੜਾਂ ਸੰਭਵ ਹੈ ਕਿ 클ਾਇਂਟ ਦੀਆਂ ਗੜਬੜਾਂ ਹਨ
                self._log_error("Database query error", e)
                raise ToolExecutionError(f"Invalid query: {str(e)}")
                
        except ToolError:
            # ਟੂਲ-ਵਿਸ਼ੇਸ਼ ਗਲਤੀਆਂ ਨੂੰ ਗੁਜ਼ਰਨ ਦਿਓ
            raise
        except Exception as e:
            # ਅਚਾਨਕ ਤਰੁਟੀਆਂ ਲਈ ਸਭ ਨੂੰ ਫੜੋ
            self._log_error("Unexpected error in DataQueryTool", e)
            raise ToolExecutionError(f"An unexpected error occurred: {str(e)}")
    
    def _contains_unsafe_sql(self, query):
        # ਐਸਕਿਊਐਲ ਇੰਜੈਕਸ਼ਨ ਪਛਾਣ ਦੀ ਲਾਗੂਆਤ
        pass
        
    def _log_error(self, message, error):
        # ਤਰੁਟੀ ਲਾਗਿੰਗ ਦੀ ਲਾਗੂਆਤ
        pass
```

#### 3. ਪੈਰਾਮੀਟਰ ਸੱਚਾਈ

ਸਦਾ ਪੈਰਾਮੀਟਰਾਂ ਦੀ ਪੂਰੀ ਜਾਂਚ ਕਰੋ ਤਾਂ ਜੋ ਗਲਤ ਜਾਂ ਖਤਰਨਾਕ ਇਨਪੁੱਟ ਨਾ ਪਹੁੰਚੇ।

```javascript
// JavaScript/TypeScript ਉਦਾਹਰਨ ਵਿਸਤ੍ਰਿਤ ਪੈਰਾਮੀਟਰ ਵੈਰੀਫਿਕੇਸ਼ਨ ਨਾਲ
class FileOperationTool {
  getName() {
    return "fileOperation";
  }
  
  getDescription() {
    return "Performs file operations like read, write, and delete";
  }
  
  getDefinition() {
    return {
      name: this.getName(),
      description: this.getDescription(),
      parameters: {
        operation: {
          type: "string",
          description: "Operation to perform",
          enum: ["read", "write", "delete"]
        },
        path: {
          type: "string",
          description: "File path (must be within allowed directories)"
        },
        content: {
          type: "string",
          description: "Content to write (only for write operation)",
          optional: true
        }
      },
      required: ["operation", "path"]
    };
  }
  
  async execute(parameters) {
    // 1. ਪੈਰਾਮੀਟਰ ਮੌਜੂਦਗੀ ਦੀ ਜਾਂਚ ਕਰੋ
    if (!parameters.operation) {
      throw new ToolError("Missing required parameter: operation");
    }
    
    if (!parameters.path) {
      throw new ToolError("Missing required parameter: path");
    }
    
    // 2. ਪੈਰਾਮੀਟਰ ਦੇ ਮਾਡਾਂ ਦੀ ਜਾਂਚ ਕਰੋ
    if (typeof parameters.operation !== "string") {
      throw new ToolError("Parameter 'operation' must be a string");
    }
    
    if (typeof parameters.path !== "string") {
      throw new ToolError("Parameter 'path' must be a string");
    }
    
    // 3. ਪੈਰਾਮੀਟਰ ਮੁੱਲਾਂ ਦੀ ਜਾਂਚ ਕਰੋ
    const validOperations = ["read", "write", "delete"];
    if (!validOperations.includes(parameters.operation)) {
      throw new ToolError(`Invalid operation. Must be one of: ${validOperations.join(", ")}`);
    }
    
    // 4. ਲਿਖਣ ਦੀ ਕਾਰਵਾਈ ਲਈ ਸਮੱਗਰੀ ਮੌਜੂਦਗੀ ਦੀ ਜਾਂਚ ਕਰੋ
    if (parameters.operation === "write" && !parameters.content) {
      throw new ToolError("Content parameter is required for write operation");
    }
    
    // 5. ਪਾਥ ਸੁਰੱਖਿਆ ਵੈਰੀਫਿਕੇਸ਼ਨ
    if (!this.isPathWithinAllowedDirectories(parameters.path)) {
      throw new ToolError("Access denied: path is outside of allowed directories");
    }
    
    // ਤਸਦੀਕ ਕੀਤੇ ਪੈਰਾਮੀਟਰਾਂ ਦੇ ਆਧਾਰ 'ਤੇ ਕਿਰਿਆਨਵਈ
    // ...
  }
  
  isPathWithinAllowedDirectories(path) {
    // ਪਾਥ ਸੁਰੱਖਿਆ ਜਾਂਚ ਦੀ ਕਿਰਿਆਨਵਈ
    // ...
  }
}
```

### ਸੁਰੱਖਿਆ ਲਾਗੂ ਕਰਨ ਦੇ ਉਦਾਹਰਨ

#### 1. ਪਰਮਾਣੀਕਰਨ ਅਤੇ ਅਧਿਕਾਰ

```java
// ਪ੍ਰਮਾਣਿਕਤਾ ਅਤੇ ਅਧਿਕਾਰਤ ਕਰਨ ਦੇ ਨਾਲ ਜਾਵਾ ਉਦਾਹਰਨ
public class SecureDataAccessTool implements Tool {
    private final AuthenticationService authService;
    private final AuthorizationService authzService;
    private final DataService dataService;
    
    // ਡਿਪੇਂਡੈਂਸੀ ਇੰਜੈਕਸ਼ਨ
    public SecureDataAccessTool(
            AuthenticationService authService,
            AuthorizationService authzService,
            DataService dataService) {
        this.authService = authService;
        this.authzService = authzService;
        this.dataService = dataService;
    }
    
    @Override
    public String getName() {
        return "secureDataAccess";
    }
    
    @Override
    public ToolResponse execute(ToolRequest request) {
        // 1. ਪ੍ਰਮਾਣਿਕਤਾ ਸੰਦਰਭ ਨਿਕਾਲੋ
        String authToken = request.getContext().getAuthToken();
        
        // 2. ਯੂਜ਼ਰ ਨੂੰ ਪ੍ਰਮਾਣਿਤ ਕਰੋ
        UserIdentity user;
        try {
            user = authService.validateToken(authToken);
        } catch (AuthenticationException e) {
            return ToolResponse.error("Authentication failed: " + e.getMessage());
        }
        
        // 3. ਵਿਸ਼ੇਸ਼ ਪਰਕਿਰਿਆ ਲਈ ਅਧਿਕਾਰਿਤਤਾ ਦੀ ਜਾਂਚ ਕਰੋ
        String dataId = request.getParameters().get("dataId").getAsString();
        String operation = request.getParameters().get("operation").getAsString();
        
        boolean isAuthorized = authzService.isAuthorized(user, "data:" + dataId, operation);
        if (!isAuthorized) {
            return ToolResponse.error("Access denied: Insufficient permissions for this operation");
        }
        
        // 4. ਅਧਿਕਾਰਤ ਪਰਕਿਰਿਆ ਨਾਲ ਅੱਗੇ ਵਧੋ
        try {
            switch (operation) {
                case "read":
                    Object data = dataService.getData(dataId, user.getId());
                    return ToolResponse.success(data);
                case "update":
                    JsonNode newData = request.getParameters().get("newData");
                    dataService.updateData(dataId, newData, user.getId());
                    return ToolResponse.success("Data updated successfully");
                default:
                    return ToolResponse.error("Unsupported operation: " + operation);
            }
        } catch (Exception e) {
            return ToolResponse.error("Operation failed: " + e.getMessage());
        }
    }
}
```

#### 2. ਦਰ ਸੀਮਤ

```csharp
// C# rate limiting implementation
public class RateLimitingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IMemoryCache _cache;
    private readonly ILogger<RateLimitingMiddleware> _logger;
    
    // Configuration options
    private readonly int _maxRequestsPerMinute;
    
    public RateLimitingMiddleware(
        RequestDelegate next,
        IMemoryCache cache,
        ILogger<RateLimitingMiddleware> logger,
        IConfiguration config)
    {
        _next = next;
        _cache = cache;
        _logger = logger;
        _maxRequestsPerMinute = config.GetValue<int>("RateLimit:MaxRequestsPerMinute", 60);
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        // 1. Get client identifier (API key or user ID)
        string clientId = GetClientIdentifier(context);
        
        // 2. Get rate limiting key for this minute
        string cacheKey = $"rate_limit:{clientId}:{DateTime.UtcNow:yyyyMMddHHmm}";
        
        // 3. Check current request count
        if (!_cache.TryGetValue(cacheKey, out int requestCount))
        {
            requestCount = 0;
        }
        
        // 4. Enforce rate limit
        if (requestCount >= _maxRequestsPerMinute)
        {
            _logger.LogWarning("Rate limit exceeded for client {ClientId}", clientId);
            
            context.Response.StatusCode = StatusCodes.Status429TooManyRequests;
            context.Response.Headers.Add("Retry-After", "60");
            
            await context.Response.WriteAsJsonAsync(new
            {
                error = "Rate limit exceeded",
                message = "Too many requests. Please try again later.",
                retryAfterSeconds = 60
            });
            
            return;
        }
        
        // 5. Increment request count
        _cache.Set(cacheKey, requestCount + 1, TimeSpan.FromMinutes(2));
        
        // 6. Add rate limit headers
        context.Response.Headers.Add("X-RateLimit-Limit", _maxRequestsPerMinute.ToString());
        context.Response.Headers.Add("X-RateLimit-Remaining", (_maxRequestsPerMinute - requestCount - 1).ToString());
        
        // 7. Continue with the request
        await _next(context);
    }
    
    private string GetClientIdentifier(HttpContext context)
    {
        // Implementation to extract API key or user ID
        // ...
    }
}
```

## ਟੈਸਟਿੰਗ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ

### 1. ਯੂਨਿਟ ਟੈਸਟਿੰਗ MCP ਉਪਕਰਨਾਂ ਦੀ

ਸਦਾ ਆਪਣੇ ਉਪਕਰਨਾਂ ਨੂੰ ਇੱਕੱਲਾ ਟੈਸਟ ਕਰੋ, ਬਾਹਰੀ ਨਿਰਭਰਤਾਵਾਂ ਨੂੰ ਮੌਕ ਕਰਦੇ ਹੋਏ:

```typescript
// ਟਾਈਪਸਕ੍ਰਿਪਟ ਉਦਾਹਰਨ ਇਕ ਟੂਲ ਯੂਨਿਟ ਟੈਸਟ ਦੀ
describe('WeatherForecastTool', () => {
  let tool: WeatherForecastTool;
  let mockWeatherService: jest.Mocked<IWeatherService>;
  
  beforeEach(() => {
    // ਇਕ ਨਕਲੀ ਮੌਸਮ ਸੇਵਾ ਬਣਾਓ
    mockWeatherService = {
      getForecasts: jest.fn()
    } as any;
    
    // ਨਕਲੀ ਨਿਰਭਰਤਾ ਨਾਲ ਟੂਲ ਬਣਾਓ
    tool = new WeatherForecastTool(mockWeatherService);
  });
  
  it('should return weather forecast for a location', async () => {
    // ਤਿਆਰੀ ਕਰੋ
    const mockForecast = {
      location: 'Seattle',
      forecasts: [
        { date: '2025-07-16', temperature: 72, conditions: 'Sunny' },
        { date: '2025-07-17', temperature: 68, conditions: 'Partly Cloudy' },
        { date: '2025-07-18', temperature: 65, conditions: 'Rain' }
      ]
    };
    
    mockWeatherService.getForecasts.mockResolvedValue(mockForecast);
    
    // ਕਿਰਿਆ ਕਰੋ
    const response = await tool.execute({
      location: 'Seattle',
      days: 3
    });
    
    // ਪੱਕਾ ਕਰੋ
    expect(mockWeatherService.getForecasts).toHaveBeenCalledWith('Seattle', 3);
    expect(response.content[0].text).toContain('Seattle');
    expect(response.content[0].text).toContain('Sunny');
  });
  
  it('should handle errors from the weather service', async () => {
    // ਤਿਆਰੀ ਕਰੋ
    mockWeatherService.getForecasts.mockRejectedValue(new Error('Service unavailable'));
    
    // ਕਿਰਿਆ ਤੇ ਪੱਕਾ ਕਰੋ
    await expect(tool.execute({
      location: 'Seattle',
      days: 3
    })).rejects.toThrow('Weather service error: Service unavailable');
  });
});
```

### 2. ਇੰਟਿਗ੍ਰੇਸ਼ਨ ਟੈਸਟਿੰਗ

ਕਲਾਇੰਟ ਦੀਆਂ ਬੇਨਤੀਆਂ ਤੋਂ ਸਰਵਰ ਦੇ ਜਵਾਬ ਤੱਕ ਪੂਰਾ ਪ੍ਰਵਾਹ ਟੈਸਟ ਕਰੋ:

```python
# ਪਾਇਥਨ ਇੰਟਿਗ੍ਰੇਸ਼ਨ ਟੈਸਟ ਉਦਾਹਰਨ
@pytest.mark.asyncio
async def test_mcp_server_integration():
    # ਟੈਸਟ ਸਰਵਰ ਸ਼ੁਰੂ ਕਰੋ
    server = McpServer()
    server.register_tool(WeatherForecastTool(MockWeatherService()))
    await server.start(port=5000)
    
    try:
        # ਇੱਕ ਕਲਾਈਂਟ ਬਣਾਓ
        client = McpClient("http://localhost:5000")
        
        # ਟੂਲ ਖੋਜ ਦੀ ਜਾਂਚ ਕਰੋ
        tools = await client.discover_tools()
        assert "weatherForecast" in [t.name for t in tools]
        
        # ਟੂਲ ਚਲਾਉਣ ਦੀ ਜਾਂਚ ਕਰੋ
        response = await client.execute_tool("weatherForecast", {
            "location": "Seattle",
            "days": 3
        })
        
        # ਜਵਾਬ ਦੀ ਪੁਸ਼ਟੀ ਕਰੋ
        assert response.status_code == 200
        assert "Seattle" in response.content[0].text
        assert len(json.loads(response.content[0].text)["forecasts"]) == 3
        
    finally:
        # ਸਾਫ਼-ਸਫਾਈ ਕਰੋ
        await server.stop()
```

## ਪ੍ਰਦਰਸ਼ਨ ਅਪਟੀਮਾਈਜ਼ੇਸ਼ਨ

### 1. ਕੈਸ਼ਿੰਗ ਰਣਨੀਤੀਆਂ

ਠੀਕ ਕੈਸ਼ਿੰਗ ਲਾਗੂ ਕਰੋ ਤਾਂ ਜੋ ਲੈਟੈਂਸੀ ਅਤੇ ਸਰੋਤ ਵਰਤੋਂ ਘਟਾਈ ਜਾ ਸਕੇ:

```csharp
// C# example with caching
public class CachedWeatherTool : ITool
{
    private readonly IWeatherService _weatherService;
    private readonly IDistributedCache _cache;
    private readonly ILogger<CachedWeatherTool> _logger;
    
    public CachedWeatherTool(
        IWeatherService weatherService,
        IDistributedCache cache,
        ILogger<CachedWeatherTool> logger)
    {
        _weatherService = weatherService;
        _cache = cache;
        _logger = logger;
    }
    
    public string Name => "weatherForecast";
    
    public async Task<ToolResponse> ExecuteAsync(IDictionary<string, object> parameters)
    {
        var location = parameters["location"].ToString();
        var days = Convert.ToInt32(parameters.GetValueOrDefault("days", 3));
        
        // Create cache key
        string cacheKey = $"weather:{location}:{days}";
        
        // Try to get from cache
        string cachedForecast = await _cache.GetStringAsync(cacheKey);
        if (!string.IsNullOrEmpty(cachedForecast))
        {
            _logger.LogInformation("Cache hit for weather forecast: {Location}", location);
            return new ToolResponse
            {
                Content = new List<ContentItem>
                {
                    new TextContent(cachedForecast)
                }
            };
        }
        
        // Cache miss - get from service
        _logger.LogInformation("Cache miss for weather forecast: {Location}", location);
        var forecast = await _weatherService.GetForecastAsync(location, days);
        string forecastJson = JsonSerializer.Serialize(forecast);
        
        // Store in cache (weather forecasts valid for 1 hour)
        await _cache.SetStringAsync(
            cacheKey,
            forecastJson,
            new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1)
            });
        
        return new ToolResponse
        {
            Content = new List<ContentItem>
            {
                new TextContent(forecastJson)
            }
        };
    }
}
```

#### 2. ਨਿਰਭਰਤਾ ਇੰਜੈਕਸ਼ਨ ਅਤੇ ਟੈਸਟੇਬਿਲਿਟੀ

ਉਪਕਰਨਾਂ ਨੂੰ ਉਨ੍ਹਾਂ ਦੀਆਂ ਨਿਰਭਰਤਾਂ ਕਨਸਟਰਕਟਰ ਇੰਜੈਕਸ਼ਨ ਰਾਹੀਂ ਪ੍ਰਾਪਤ ਕਰਨ ਲਈ ਡਿਜ਼ਾਈਨ ਕਰੋ, ਜਿਸ ਨਾਲ ਉਹ ਟੈਸਟਯੋਗ ਅਤੇ ਸੰਰਚਨਾਤਮਕ ਬਣ ਜਾਂਦੇ ਹਨ:

```java
// ਡਿਪੇਂਡੈਂਸੀ ਇੰਜੈਕਸ਼ਨ ਨਾਲ ਜਾਵਾ ਉਦਾਹਰਨ
public class CurrencyConversionTool implements Tool {
    private final ExchangeRateService exchangeService;
    private final CacheService cacheService;
    private final Logger logger;
    
    // ਨਿਰਮਾਤਾ ਰਾਹੀਂ ਡਿਪੇਂਡੈਂਸੀ ਇੰਜੈਕਟ ਕੀਤੀਆਂ ਗਈਆਂ
    public CurrencyConversionTool(
            ExchangeRateService exchangeService,
            CacheService cacheService,
            Logger logger) {
        this.exchangeService = exchangeService;
        this.cacheService = cacheService;
        this.logger = logger;
    }
    
    // ਟੂਲ ਦਾ ਕਾਰਜਾਨੁਵਾਇ
    // ...
}
```

#### 3. ਕੰਪੋਜ਼ੇਬਲ ਉਪਕਰਨ

ਉਪਕਰਨ ਬਣਾਓ ਜੋ ਮਿਲ ਕੇ ਵੱਧ ਜੱਟਿਲ ਵਰਕਫਲੋਜ਼ ਤਿਆਰ ਕਰ ਸਕਣ:

```python
# ਪਾਈਥਨ ਉਦਾਹਰਨ ਜੋ ਕਿ ਸੰਗ੍ਰਹਿਤ ਤੌਰ ਤੇ ਟੂਲਜ਼ ਨੂੰ ਦਿਖਾ ਰਹੀ ਹੈ
class DataFetchTool(Tool):
    def get_name(self):
        return "dataFetch"
    
    # ਲਾਗੂ ਕਰਨਾ...

class DataAnalysisTool(Tool):
    def get_name(self):
        return "dataAnalysis"
    
    # ਇਹ ਟੂਲ ਡੇਟਾ ਫੈਚ ਟੂਲ ਤੋਂ ਨਤੀਜੇ ਵਰਤ ਸਕਦਾ ਹੈ
    async def execute_async(self, request):
        # ਲਾਗੂ ਕਰਨਾ...
        pass

class DataVisualizationTool(Tool):
    def get_name(self):
        return "dataVisualize"
    
    # ਇਹ ਟੂਲ ਡੇਟਾ ਵਿਸ਼ਲੇਸ਼ਣ ਟੂਲ ਤੋਂ ਨਤੀਜੇ ਵਰਤ ਸਕਦਾ ਹੈ
    async def execute_async(self, request):
        # ਲਾਗੂ ਕਰਨਾ...
        pass

# ਇਹ ਟੂਲਜ਼ ਸੁਤੰਤਰ ਤੌਰ 'ਤੇ ਜਾਂ ਕੰਮ ਦੇ ਪ੍ਰਵਾਹ ਦਾ ਹਿੱਸਾ ਬਣ ਕੇ ਵਰਤੇ ਜਾ ਸਕਦੇ ਹਨ
```

### ਸਕੀਮਾ ਡਿਜ਼ਾਈਨ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ

ਸਕੀਮਾ ਮਾਡਲ ਅਤੇ ਤੁਹਾਡੇ ਉਪਕਰਨ ਵਿੱਚ ਇਕ ਕਰਾਰ ਹੈ। ਚੰਗੀ ਡਿਜ਼ਾਈਨ ਵਾਲੇ ਸਕੀਮਾ ਦੇਣ ਨਾਲ ਉਪਕਰਨ ਦੀ ਵਰਤੋਂ ਵਿੱਚ آسانੀ ਆਉਂਦੀ ਹੈ।

#### 1. ਸਪਸ਼ਟ ਪੈਰਾਮੀਟਰ ਵਰਣਨ

ਹਰ ਪੈਰਾਮੀਟਰ ਲਈ ਵੇਰਵਾ ਸ਼ਾਮਿਲ ਕਰੋ:

```csharp
public object GetSchema()
{
    return new {
        type = "object",
        properties = new {
            query = new { 
                type = "string", 
                description = "Search query text. Use precise keywords for better results." 
            },
            filters = new {
                type = "object",
                description = "Optional filters to narrow down search results",
                properties = new {
                    dateRange = new { 
                        type = "string", 
                        description = "Date range in format YYYY-MM-DD:YYYY-MM-DD" 
                    },
                    category = new { 
                        type = "string", 
                        description = "Category name to filter by" 
                    }
                }
            },
            limit = new { 
                type = "integer", 
                description = "Maximum number of results to return (1-50)",
                default = 10
            }
        },
        required = new[] { "query" }
    };
}
```

#### 2. ਸੱਚਾਈ ਦੀਆਂ ਸੀਮਾਵਾਂ

ਗਲਤ ਇਨਪੁੱਟਾਂ ਤੋਂ ਬਚਨ ਲਈ ਸੱਚਾਈ ਦੀਆਂ ਸ਼ਰਤਾਂ ਸ਼ਾਮਿਲ ਕਰੋ:

```java
Map<String, Object> getSchema() {
    Map<String, Object> schema = new HashMap<>();
    schema.put("type", "object");
    
    Map<String, Object> properties = new HashMap<>();
    
    // ਈਮੇਲ ਪ੍ਰਾਪਰਟੀ ਫਾਰਮੈਟ ਵੈਰੀਫਿਕੇਸ਼ਨ ਨਾਲ
    Map<String, Object> email = new HashMap<>();
    email.put("type", "string");
    email.put("format", "email");
    email.put("description", "User email address");
    
    // ਉਮਰ ਪ੍ਰਾਪਰਟੀ ਸੰਖਿਆਤਮਕ ਸੀਮਾਵਾਂ ਨਾਲ
    Map<String, Object> age = new HashMap<>();
    age.put("type", "integer");
    age.put("minimum", 13);
    age.put("maximum", 120);
    age.put("description", "User age in years");
    
    // ਗਿਣਤੀਬੱਧ ਪ੍ਰਾਪਰਟੀ
    Map<String, Object> subscription = new HashMap<>();
    subscription.put("type", "string");
    subscription.put("enum", Arrays.asList("free", "basic", "premium"));
    subscription.put("default", "free");
    subscription.put("description", "Subscription tier");
    
    properties.put("email", email);
    properties.put("age", age);
    properties.put("subscription", subscription);
    
    schema.put("properties", properties);
    schema.put("required", Arrays.asList("email"));
    
    return schema;
}
```

#### 3. ਇਕਸਾਰ ਵਾਪਸੀ ਸੰਰਚਨਾ

ਆਪਣੇ ਜਵਾਬਾਂ ਵਿੱਚ ਇਕਸਾਰਤਾ ਬਰਕਰਾਰ ਰੱਖੋ ਤਾਂ ਜੋ ਮਾਡਲ ਨਤੀਜੇ ਆਸਾਨੀ ਨਾਲ ਸਮਝ ਸਕਣ:

```python
async def execute_async(self, request):
    try:
        # ਬੇਨਤੀ ਨੂੰ ਪ੍ਰਕਿਰਿਆ ਵਿੱਚ ਲਿਆਓ
        results = await self._search_database(request.parameters["query"])
        
        # ਹਮੇਸ਼ਾ ਇੱਕ ਇੱਕਸਾਰ ਢਾਂਚਾ ਵਾਪਸ ਕਰੋ
        return ToolResponse(
            result={
                "matches": [self._format_item(item) for item in results],
                "totalCount": len(results),
                "queryTime": calculation_time_ms,
                "status": "success"
            }
        )
    except Exception as e:
        return ToolResponse(
            result={
                "matches": [],
                "totalCount": 0,
                "queryTime": 0,
                "status": "error",
                "error": str(e)
            }
        )
    
def _format_item(self, item):
    """Ensures each item has a consistent structure"""
    return {
        "id": item.id,
        "title": item.title,
        "summary": item.summary[:100] + "..." if len(item.summary) > 100 else item.summary,
        "url": item.url,
        "relevance": item.score
    }
```

### ਐਰਰ ਹੈਂਡਲਿੰਗ

ਮਜ਼ਬੂਤ ਐਰਰ ਹੈਂਡਲਿੰਗ MCP ਉਪਕਰਨਾਂ ਦੀ ਭਰੋਸੇਯੋਗਤਾ ਬਣਾਈ ਰੱਖਣ ਲਈ ਜ਼ਰੂਰੀ ਹੈ।

#### 1. ਸੁਖਦਾਇਕ ਐਰਰ ਹੈਂਡਲਿੰਗ

ਉਚਿਤ ਸਤਰਾਂ 'ਤੇ ਐਰਰਾਂ ਨੂੰ ਸੰਭਾਲੋ ਅਤੇ ਜਾਣਕਾਰੀਮੁੱਲਕ ਸੁਨੇਹੇ ਦਿਓ:

```csharp
public async Task<ToolResponse> ExecuteAsync(ToolRequest request)
{
    try
    {
        string fileId = request.Parameters.GetProperty("fileId").GetString();
        
        try
        {
            var fileData = await _fileService.GetFileAsync(fileId);
            return new ToolResponse { 
                Result = JsonSerializer.SerializeToElement(fileData) 
            };
        }
        catch (FileNotFoundException)
        {
            throw new ToolExecutionException($"File not found: {fileId}");
        }
        catch (UnauthorizedAccessException)
        {
            throw new ToolExecutionException("You don't have permission to access this file");
        }
        catch (Exception ex) when (ex is IOException || ex is TimeoutException)
        {
            _logger.LogError(ex, "Error accessing file {FileId}", fileId);
            throw new ToolExecutionException("Error accessing file: The service is temporarily unavailable");
        }
    }
    catch (JsonException)
    {
        throw new ToolExecutionException("Invalid file ID format");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Unexpected error in FileAccessTool");
        throw new ToolExecutionException("An unexpected error occurred");
    }
}
```

#### 2. ਸੰਰਚਿਤ ਐਰਰ ਜਵਾਬ

ਸੰਭਵ ਹੋਵੇ ਤਾਂ ਸੰਰਚਿਤ ਐਰਰ ਜਾਣਕਾਰੀ ਵਾਪਸ ਕਰੋ:

```java
@Override
public ToolResponse execute(ToolRequest request) {
    try {
        // ਲਾਗੂ ਕਰਨਾ
    } catch (Exception ex) {
        Map<String, Object> errorResult = new HashMap<>();
        
        errorResult.put("success", false);
        
        if (ex instanceof ValidationException) {
            ValidationException validationEx = (ValidationException) ex;
            
            errorResult.put("errorType", "validation");
            errorResult.put("errorMessage", validationEx.getMessage());
            errorResult.put("validationErrors", validationEx.getErrors());
            
            return new ToolResponse.Builder()
                .setResult(errorResult)
                .build();
        }
        
        // ਹੋਰ uitzondering ToolExecutionException ਵਜੋਂ ਫੇਰੋ
        throw new ToolExecutionException("Tool execution failed: " + ex.getMessage(), ex);
    }
}
```

#### 3. ਦੁਬਾਰਾ ਕੋਸ਼ਿਸ਼ ਕਰਨ ਦਾ ਤਰਤੀਬ

ਅਸਥਾਈ ਨੁਕਸਾਨਾਂ ਲਈ ਉਚਿਤ ਦੁਬਾਰਾ ਕੋਸ਼ਿਸ਼ ਕਰਨ ਦੀ ਤਰਤੀਬ ਲਾਗੂ ਕਰੋ:

```python
async def execute_async(self, request):
    max_retries = 3
    retry_count = 0
    base_delay = 1  # ਸਕਿੰਟ
    
    while retry_count < max_retries:
        try:
            # ਬਾਹਰੀ API ਨੂੰ ਕਾਲ ਕਰੋ
            return await self._call_api(request.parameters)
        except TransientError as e:
            retry_count += 1
            if retry_count >= max_retries:
                raise ToolExecutionException(f"Operation failed after {max_retries} attempts: {str(e)}")
                
            # ਘਣਾ ਗੁਣਾ ਵਾਪਸੀ
            delay = base_delay * (2 ** (retry_count - 1))
            logging.warning(f"Transient error, retrying in {delay}s: {str(e)}")
            await asyncio.sleep(delay)
        except Exception as e:
            # ਗੈਰ-ਅਸਥਾਈ ਗਲਤੀ, ਮੁੜ ਕੋਸ਼ਿਸ਼ ਨਾ ਕਰੋ
            raise ToolExecutionException(f"Operation failed: {str(e)}")
```

### ਪ੍ਰਦਰਸ਼ਨ ਅਪਟੀਮਾਈਜ਼ੇਸ਼ਨ

#### 1. ਕੈਸ਼ਿੰਗ

ਮਹਿੰਗੇ ਕਾਰਜਾਂ ਲਈ ਕੈਸ਼ਿੰਗ ਲਾਗੂ ਕਰੋ:

```csharp
public class CachedDataTool : IMcpTool
{
    private readonly IDatabase _database;
    private readonly IMemoryCache _cache;
    
    public CachedDataTool(IDatabase database, IMemoryCache cache)
    {
        _database = database;
        _cache = cache;
    }
    
    public async Task<ToolResponse> ExecuteAsync(ToolRequest request)
    {
        var query = request.Parameters.GetProperty("query").GetString();
        
        // Create cache key based on parameters
        var cacheKey = $"data_query_{ComputeHash(query)}";
        
        // Try to get from cache first
        if (_cache.TryGetValue(cacheKey, out var cachedResult))
        {
            return new ToolResponse { Result = cachedResult };
        }
        
        // Cache miss - perform actual query
        var result = await _database.QueryAsync(query);
        
        // Store in cache with expiration
        var cacheOptions = new MemoryCacheEntryOptions()
            .SetAbsoluteExpiration(TimeSpan.FromMinutes(15));
            
        _cache.Set(cacheKey, JsonSerializer.SerializeToElement(result), cacheOptions);
        
        return new ToolResponse { Result = JsonSerializer.SerializeToElement(result) };
    }
    
    private string ComputeHash(string input)
    {
        // Implementation to generate stable hash for cache key
    }
}
```

#### 2. ਅਸਿੰਕ੍ਰੋਨਸ ਪ੍ਰਕਿਰਿਆ

I/O-ਅਧਾਰਿਤ ਕਾਰਜਾਂ ਲਈ ਅਸਿੰਕ੍ਰੋਨਸ ਪ੍ਰੋਗ੍ਰਾਮਿੰਗ ਪੈਟਰਨ ਵਰਤੋ:

```java
public class AsyncDocumentProcessingTool implements Tool {
    private final DocumentService documentService;
    private final ExecutorService executorService;
    
    @Override
    public ToolResponse execute(ToolRequest request) {
        String documentId = request.getParameters().get("documentId").asText();
        
        // ਲੰਮੇ ਸਮੇਂ ਚੱਲਣ ਵਾਲੇ ਓਪਰੇਸ਼ਨਾਂ ਲਈ, ਤੁਰੰਤ ਇੱਕ ਪ੍ਰੋਸੈਸਿੰਗ ID ਵਾਪਸ ਕਰੋ
        String processId = UUID.randomUUID().toString();
        
        // ਅਸਿੰਕ ਪ੍ਰੋਸੈਸਿੰਗ ਸ਼ੁਰੂ ਕਰੋ
        CompletableFuture.runAsync(() -> {
            try {
                // ਲੰਮੇ ਸਮੇਂ ਚੱਲਣ ਵਾਲਾ ਓਪਰੇਸ਼ਨ ਕਰੋ
                documentService.processDocument(documentId);
                
                // ਸਥਿਤੀ ਨੂੰ ਅਪਡੇਟ ਕਰੋ (ਆਮ ਤੌਰ 'ਤੇ ਇਹ ਡਾਟਾਬੇਸ ਵਿੱਚ ਸਾਂਭੀ ਜਾਂਦੀ ਹੈ)
                processStatusRepository.updateStatus(processId, "completed");
            } catch (Exception ex) {
                processStatusRepository.updateStatus(processId, "failed", ex.getMessage());
            }
        }, executorService);
        
        // ਪ੍ਰੋਸੈਸ ID ਨਾਲ ਤੁਰੰਤ ਜਵਾਬ ਵਾਪਸ ਕਰੋ
        Map<String, Object> result = new HashMap<>();
        result.put("processId", processId);
        result.put("status", "processing");
        result.put("estimatedCompletionTime", ZonedDateTime.now().plusMinutes(5));
        
        return new ToolResponse.Builder().setResult(result).build();
    }
    
    // ਸਾਥੀ ਸਥਿਤੀ ਚੈੱਕ ਟੂਲ
    public class ProcessStatusTool implements Tool {
        @Override
        public ToolResponse execute(ToolRequest request) {
            String processId = request.getParameters().get("processId").asText();
            ProcessStatus status = processStatusRepository.getStatus(processId);
            
            return new ToolResponse.Builder().setResult(status).build();
        }
    }
}
```

#### 3. ਸਰੋਤ ਰੋਧ

ਜ਼ਿਆਦਾ ਭਾਰ ਤੋਂ ਬਚਣ ਲਈ ਸਰੋਤਾਂ ਦੀ ਰੋਧ ਲਾਗੂ ਕਰੋ:

```python
class ThrottledApiTool(Tool):
    def __init__(self):
        self.rate_limiter = TokenBucketRateLimiter(
            tokens_per_second=5,  # ਪ੍ਰਤੀ ਸਕਿੰਟ 5 ਬੇਨਤੀਆਂ ਦੀ ਆਗਿਆ ਦਿਓ
            bucket_size=10        # 10 ਬੇਨਤੀਆਂ ਤੱਕ ਦੇ ਬਰੱਸਟ ਦੀ ਆਗਿਆ ਦਿਓ
        )
    
    async def execute_async(self, request):
        # ਚੈੱਕ ਕਰੋ ਕਿ ਅਸੀਂ ਅੱਗੇ ਵਧ ਸਕਦੇ ਹਾਂ ਜਾਂ ਇੰਤਜ਼ਾਰ ਕਰਨਾ ਜ਼ਰੂਰੀ ਹੈ
        delay = self.rate_limiter.get_delay_time()
        
        if delay > 0:
            if delay > 2.0:  # ਜੇ ਇੰਤਜ਼ਾਰ ਬਹੁਤ ਲੰਮਾ ਹੈ
                raise ToolExecutionException(
                    f"Rate limit exceeded. Please try again in {delay:.1f} seconds."
                )
            else:
                # مناسب ڈیلے کے وقت کے لئے انتظار کریں
                await asyncio.sleep(delay)
        
        # ਇੱਕ ਟੋਕਨ ਖਪਤ ਕਰੋ ਅਤੇ ਬੇਨਤੀ ਨਾਲ ਅੱਗੇ ਵਧੋ
        self.rate_limiter.consume()
        
        # API ਨੂੰ ਕਾਲ ਕਰੋ
        result = await self._call_api(request.parameters)
        return ToolResponse(result=result)

class TokenBucketRateLimiter:
    def __init__(self, tokens_per_second, bucket_size):
        self.tokens_per_second = tokens_per_second
        self.bucket_size = bucket_size
        self.tokens = bucket_size
        self.last_refill = time.time()
        self.lock = asyncio.Lock()
    
    async def get_delay_time(self):
        async with self.lock:
            self._refill()
            if self.tokens >= 1:
                return 0
            
            # ਅਗਲੇ ਟੋਕਨ ਦੀ ਉਪਲਬਧਤਾ ਤੱਕ ਦਾ ਸਮਾਂ ਗਣਨਾ ਕਰੋ
            return (1 - self.tokens) / self.tokens_per_second
    
    async def consume(self):
        async with self.lock:
            self._refill()
            self.tokens -= 1
    
    def _refill(self):
        now = time.time()
        elapsed = now - self.last_refill
        
        # ਬੀਤੇ ਸਮੇਂ ਦੇ ਆਧਾਰ 'ਤੇ ਨਵੇਂ ਟੋਕਨ ਸ਼ਾਮਲ ਕਰੋ
        new_tokens = elapsed * self.tokens_per_second
        self.tokens = min(self.bucket_size, self.tokens + new_tokens)
        self.last_refill = now
```

### ਸੁਰੱਖਿਆ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ

#### 1. ਇਨਪੁੱਟ ਸੱਚਾਈ

ਹਮੇਸ਼ਾ ਪੈਰਾਮੀਟਰਾਂ ਦੀ ਪੂਰਨ ਜਾਂਚ ਕਰੋ:

```csharp
public async Task<ToolResponse> ExecuteAsync(ToolRequest request)
{
    // Validate parameters exist
    if (!request.Parameters.TryGetProperty("query", out var queryProp))
    {
        throw new ToolExecutionException("Missing required parameter: query");
    }
    
    // Validate correct type
    if (queryProp.ValueKind != JsonValueKind.String)
    {
        throw new ToolExecutionException("Query parameter must be a string");
    }
    
    var query = queryProp.GetString();
    
    // Validate string content
    if (string.IsNullOrWhiteSpace(query))
    {
        throw new ToolExecutionException("Query parameter cannot be empty");
    }
    
    if (query.Length > 500)
    {
        throw new ToolExecutionException("Query parameter exceeds maximum length of 500 characters");
    }
    
    // Check for SQL injection attacks if applicable
    if (ContainsSqlInjection(query))
    {
        throw new ToolExecutionException("Invalid query: contains potentially unsafe SQL");
    }
    
    // Proceed with execution
    // ...
}
```

#### 2. ਅਧਿਕਾਰਤ ਚੈੱਕ

ਠੀਕ ਅਧਿਕਾਰ ਜਾਂਚ ਲਾਗੂ ਕਰੋ:

```java
@Override
public ToolResponse execute(ToolRequest request) {
    // ਬੇਨਤੀ ਵਿੱਚੋਂ ਯੂਜ਼ਰ ਸੰਦਰਭ ਪ੍ਰਾਪਤ ਕਰੋ
    UserContext user = request.getContext().getUserContext();
    
    // ਜਾਂਚੋ ਕਿ ਯੂਜ਼ਰ ਕੋਲ ਲੋੜੀਂਦੇ ਅਧਿਕਾਰ ਹਨ ਜਾਂ ਨਹੀਂ
    if (!authorizationService.hasPermission(user, "documents:read")) {
        throw new ToolExecutionException("User does not have permission to access documents");
    }
    
    // ਖ਼ਾਸ ਸਰੋਤਾਂ ਲਈ, ਉਸ ਸਰੋਤ ਤੱਕ ਪਹੁੰਚ ਦੀ ਜਾਂਚ ਕਰੋ
    String documentId = request.getParameters().get("documentId").asText();
    if (!documentService.canUserAccess(user.getId(), documentId)) {
        throw new ToolExecutionException("Access denied to the requested document");
    }
    
    // ਸਾਧਨ ਚਲਾਉਣ ਨਾਲ ਅੱਗੇ ਵਧੋ
    // ...
}
```

#### 3. ਸੰਵੇਦਨਸ਼ੀਲ ਡੇਟਾ ਹੈਂਡਲਿੰਗ

ਸੰਵੇਦਨਸ਼ੀਲ ਡੇਟਾ ਨੂੰ ਧਿਆਨ ਨਾਲ ਸੰਭਾਲੋ:

```python
class SecureDataTool(Tool):
    def get_schema(self):
        return {
            "type": "object",
            "properties": {
                "userId": {"type": "string"},
                "includeSensitiveData": {"type": "boolean", "default": False}
            },
            "required": ["userId"]
        }
    
    async def execute_async(self, request):
        user_id = request.parameters["userId"]
        include_sensitive = request.parameters.get("includeSensitiveData", False)
        
        # ਯੂਜ਼ਰ ਡਾਟਾ ਪ੍ਰਾਪਤ ਕਰੋ
        user_data = await self.user_service.get_user_data(user_id)
        
        # ਸੰਵੇਦਨਸ਼ੀਲ ਖੇਤਰਾਂ ਨੂੰ ਛਾਂਟੋ ਜੇ ਤੱਕ ਖਾਸ ਤੌਰ 'ਤੇ ਬੇਨਤੀ ਨਾ ਕੀਤੀ ਗਈ ਹੋਵੇ ਅਤੇ ਅਧਿਕਾਰਿਤ ਹੋਵੇ
        if not include_sensitive or not self._is_authorized_for_sensitive_data(request):
            user_data = self._redact_sensitive_fields(user_data)
        
        return ToolResponse(result=user_data)
    
    def _is_authorized_for_sensitive_data(self, request):
        # ਬੇਨਤੀ ਸੰਦਰਭ ਵਿੱਚ ਅਧਿਕਾਰਨ ਪੱਧਰ ਚੈੱਕ ਕਰੋ
        auth_level = request.context.get("authorizationLevel")
        return auth_level == "admin"
    
    def _redact_sensitive_fields(self, user_data):
        # ਮੂਲ ਵਿੱਚ ਸੋਧ ਕਰਨ ਤੋਂ ਬਚਣ ਲਈ ਇੱਕ ਪ੍ਰਤਿਲਿਪੀ ਬਣਾਓ
        redacted = user_data.copy()
        
        # ਖ਼ਾਸ ਸੰਵੇਦਨਸ਼ੀਲ ਖੇਤਰਾਂ ਨੂੰ ਛਾਂਟੋ
        sensitive_fields = ["ssn", "creditCardNumber", "password"]
        for field in sensitive_fields:
            if field in redacted:
                redacted[field] = "REDACTED"
        
        # ਘੁੰਮਵੇਂ ਸੰਵੇਦਨਸ਼ੀਲ ਡਾਟੇ ਨੂੰ ਛਾਂਟੋ
        if "financialInfo" in redacted:
            redacted["financialInfo"] = {"available": True, "accessRestricted": True}
        
        return redacted
```

## MCP ਉਪਕਰਨਾਂ ਲਈ ਟੈਸਟਿੰਗ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ

ਵਿਸਤਾਰਪੂਰਕ ਟੈਸਟਿੰਗ ਯਕੀਨੀ ਬਣਾਉਂਦੀ ਹੈ ਕਿ MCP ਉਪਕਰਨ ਸਹੀ ਕੰਮ ਕਰਦੇ ਹਨ, ਕਿਨਾਰੇ ਮਾਮਲਿਆਂ ਨੂੰ ਸੰਭਾਲਦੇ ਹਨ ਅਤੇ ਪ੍ਰਣਾਲੀ ਦੇ ਬਾਕੀ ਹਿੱਸਿਆਂ ਨਾਲ ਢੰਗ ਨਾਲ ਜੁੜੇ ਹੋਏ ਹਨ।

### ਯੂਨਿਟ ਟੈਸਟਿੰਗ

#### 1. ਹਰ ਉਪਕਰਨ ਨੂੰ ਅਲੱਗ ਟੈਸਟ ਕਰੋ

ਹਰ ਉਪਕਰਨ ਦੀ ਕਾਰਗੁਜ਼ਾਰੀ ਲਈ ਕੇਂਦਰਿਤ ਟੈਸਟ ਬਣਾਓ:

```csharp
[Fact]
public async Task WeatherTool_ValidLocation_ReturnsCorrectForecast()
{
    // Arrange
    var mockWeatherService = new Mock<IWeatherService>();
    mockWeatherService
        .Setup(s => s.GetForecastAsync("Seattle", 3))
        .ReturnsAsync(new WeatherForecast(/* test data */));
    
    var tool = new WeatherForecastTool(mockWeatherService.Object);
    
    var request = new ToolRequest(
        toolName: "weatherForecast",
        parameters: JsonSerializer.SerializeToElement(new { 
            location = "Seattle", 
            days = 3 
        })
    );
    
    // Act
    var response = await tool.ExecuteAsync(request);
    
    // Assert
    Assert.NotNull(response);
    var result = JsonSerializer.Deserialize<WeatherForecast>(response.Result);
    Assert.Equal("Seattle", result.Location);
    Assert.Equal(3, result.DailyForecasts.Count);
}

[Fact]
public async Task WeatherTool_InvalidLocation_ThrowsToolExecutionException()
{
    // Arrange
    var mockWeatherService = new Mock<IWeatherService>();
    mockWeatherService
        .Setup(s => s.GetForecastAsync("InvalidLocation", It.IsAny<int>()))
        .ThrowsAsync(new LocationNotFoundException("Location not found"));
    
    var tool = new WeatherForecastTool(mockWeatherService.Object);
    
    var request = new ToolRequest(
        toolName: "weatherForecast",
        parameters: JsonSerializer.SerializeToElement(new { 
            location = "InvalidLocation", 
            days = 3 
        })
    );
    
    // Act & Assert
    var exception = await Assert.ThrowsAsync<ToolExecutionException>(
        () => tool.ExecuteAsync(request)
    );
    
    Assert.Contains("Location not found", exception.Message);
}
```

#### 2. ਸਕੀਮਾ ਸੱਚਾਈ ਟੈਸਟਿੰਗ

ਟੈਸਟ ਕਰੋ ਕਿ ਸਕੀਮਾ ਸਹੀ ਹੈ ਅਤੇ ਸੀਮਾਵਾਂ ਨੂੰ ਢੰਗ ਨਾਲ ਲਾਗੂ ਕਰਦਾ ਹੈ:

```java
@Test
public void testSchemaValidation() {
    // ਟੂਲ ਇੰਸਟੈਂਸ ਬਣਾਓ
    SearchTool searchTool = new SearchTool();
    
    // ਸਕੀਮਾ ਪ੍ਰਾਪਤ ਕਰੋ
    Object schema = searchTool.getSchema();
    
    // ਸਕੀਮਾ ਨੂੰ ਵੈਲੀਡੇਸ਼ਨ ਲਈ JSON ਵਿੱਚ ਬਦਲੋ
    String schemaJson = objectMapper.writeValueAsString(schema);
    
    // ਸਕੀਮਾ ਵੈਧ JSONSchema ਹੈ ਕਿ ਨਹੀਂ ਇਹ ਵੈਲੀਡੇਟ ਕਰੋ
    JsonSchemaFactory factory = JsonSchemaFactory.byDefault();
    JsonSchema jsonSchema = factory.getJsonSchema(schemaJson);
    
    // ਵੈਧ ਪੈਰਾਮੀਟਰ ਟੈਸਟ ਕਰੋ
    JsonNode validParams = objectMapper.createObjectNode()
        .put("query", "test query")
        .put("limit", 5);
        
    ProcessingReport validReport = jsonSchema.validate(validParams);
    assertTrue(validReport.isSuccess());
    
    // ਲਾਜ਼ਮੀ ਪੈਰਾਮੀਟਰ ਦੀ ਘਾਟ ਟੈਸਟ ਕਰੋ
    JsonNode missingRequired = objectMapper.createObjectNode()
        .put("limit", 5);
        
    ProcessingReport missingReport = jsonSchema.validate(missingRequired);
    assertFalse(missingReport.isSuccess());
    
    // ਗਲਤ ਪੈਰਾਮੀਟਰ ਟਾਈਪ ਟੈਸਟ ਕਰੋ
    JsonNode invalidType = objectMapper.createObjectNode()
        .put("query", "test")
        .put("limit", "not-a-number");
        
    ProcessingReport invalidReport = jsonSchema.validate(invalidType);
    assertFalse(invalidReport.isSuccess());
}
```

#### 3. ਐਰਰ ਹੈਂਡਲਿੰਗ ਟੈਸਟ

ਐਰਰ ਹਾਲਤਾਂ ਲਈ ਵਿਸ਼ੇਸ਼ ਟੈਸਟ ਬਣਾਓ:

```python
@pytest.mark.asyncio
async def test_api_tool_handles_timeout():
    # ਵਿਵਸਥਿਤ ਕਰੋ
    tool = ApiTool(timeout=0.1)  # ਬਹੁਤ ਛੋਟਾ ਸਮਾਂ ਸੀਮਾ
    
    # ਇੱਕ ਬੇਨਤੀ ਦੀ ਨਕਲ ਕਰੋ ਜੋ ਸਮਾਂ ਤੀਅਗ ਜਾਵੇਗਾ
    with aioresponses() as mocked:
        mocked.get(
            "https://api.example.com/data",
            callback=lambda *args, **kwargs: asyncio.sleep(0.5)  # ਸਮਾਂ ਸੀਮਾ ਤੋਂ ਵੱਧ
        )
        
        request = ToolRequest(
            tool_name="apiTool",
            parameters={"url": "https://api.example.com/data"}
        )
        
        # ਕਾਰਵਾਈ ਕਰੋ ਅਤੇ ਦਾਅਵਾ ਕਰੋ
        with pytest.raises(ToolExecutionException) as exc_info:
            await tool.execute_async(request)
        
        # ਵ੍ਯਤਕਤੀ ਵਾਚਕ ਸੰਦਰਭ ਦੀ ਪੁਸ਼ਟੀ ਕਰੋ
        assert "timed out" in str(exc_info.value).lower()

@pytest.mark.asyncio
async def test_api_tool_handles_rate_limiting():
    # ਵਿਵਸਥਿਤ ਕਰੋ
    tool = ApiTool()
    
    # ਦਰ ਦਰਜਾ ਸੀਮਿਤ ਪ੍ਰਤੀਕਿਰਿਆ ਦੀ ਨਕਲ ਕਰੋ
    with aioresponses() as mocked:
        mocked.get(
            "https://api.example.com/data",
            status=429,
            headers={"Retry-After": "2"},
            body=json.dumps({"error": "Rate limit exceeded"})
        )
        
        request = ToolRequest(
            tool_name="apiTool",
            parameters={"url": "https://api.example.com/data"}
        )
        
        # ਕਾਰਵਾਈ ਕਰੋ ਅਤੇ ਦਾਅਵਾ ਕਰੋ
        with pytest.raises(ToolExecutionException) as exc_info:
            await tool.execute_async(request)
        
        # ਯਕੀਨ ਕਰੋ ਕਿ ਵਿਰੋਧ ਸੰਦਰਭ ਵਿੱਚ ਦਰ ਸੀਮਾ ਜਾਣਕਾਰੀ ਹੈ
        error_msg = str(exc_info.value).lower()
        assert "rate limit" in error_msg
        assert "try again" in error_msg
```

### ਇੰਟਿਗ੍ਰੇਸ਼ਨ ਟੈਸਟਿੰਗ

#### 1. ਉਪਕਰਨ ਚੇਨ ਟੈਸਟਿੰਗ

ਕਿਸ਼ਤਿਵਾਰ ਉਪਕਰਨਾਂ ਨੂੰ ਵਧੀਆ ਤਰੀਕੇ ਨਾਲ ਕੰਮ ਕਰਦੇ ਦੇਖੋ:

```csharp
[Fact]
public async Task DataProcessingWorkflow_CompletesSuccessfully()
{
    // Arrange
    var dataFetchTool = new DataFetchTool(mockDataService.Object);
    var analysisTools = new DataAnalysisTool(mockAnalysisService.Object);
    var visualizationTool = new DataVisualizationTool(mockVisualizationService.Object);
    
    var toolRegistry = new ToolRegistry();
    toolRegistry.RegisterTool(dataFetchTool);
    toolRegistry.RegisterTool(analysisTools);
    toolRegistry.RegisterTool(visualizationTool);
    
    var workflowExecutor = new WorkflowExecutor(toolRegistry);
    
    // Act
    var result = await workflowExecutor.ExecuteWorkflowAsync(new[] {
        new ToolCall("dataFetch", new { source = "sales2023" }),
        new ToolCall("dataAnalysis", ctx => new { 
            data = ctx.GetResult("dataFetch"),
            analysis = "trend" 
        }),
        new ToolCall("dataVisualize", ctx => new {
            analysisResult = ctx.GetResult("dataAnalysis"),
            type = "line-chart"
        })
    });
    
    // Assert
    Assert.NotNull(result);
    Assert.True(result.Success);
    Assert.NotNull(result.GetResult("dataVisualize"));
    Assert.Contains("chartUrl", result.GetResult("dataVisualize").ToString());
}
```

#### 2. MCP ਸਰਵਰ ਟੈਸਟਿੰਗ

ਪੂਰੇ ਉਪਕਰਨ ਮੁਲਾਂਕਣ ਅਤੇ ਨਿਭਾਉਣ ਨਾਲ MCP ਸਰਵਰ ਟੈਸਟ ਕਰੋ:

```java
@SpringBootTest
@AutoConfigureMockMvc
public class McpServerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    public void testToolDiscovery() throws Exception {
        // ਖੋਜ ਐਂਡਪਾਇੰਟ ਦੀ ਜਾਂਚ ਕਰੋ
        mockMvc.perform(get("/mcp/tools"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.tools").isArray())
            .andExpect(jsonPath("$.tools[*].name").value(hasItems(
                "weatherForecast", "calculator", "documentSearch"
            )));
    }
    
    @Test
    public void testToolExecution() throws Exception {
        // ਟੂਲ ਬੇਨਤੀ ਬਣਾਓ
        Map<String, Object> request = new HashMap<>();
        request.put("toolName", "calculator");
        
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("operation", "add");
        parameters.put("a", 5);
        parameters.put("b", 7);
        request.put("parameters", parameters);
        
        // ਬੇਨਤੀ ਭੇਜੋ ਅਤੇ ਜਵਾਬ ਦੀ ਪੁਸ਼ਟੀ ਕਰੋ
        mockMvc.perform(post("/mcp/execute")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.result.value").value(12));
    }
    
    @Test
    public void testToolValidation() throws Exception {
        // ਗਲਤ ਟੂਲ ਬੇਨਤੀ ਬਣਾਓ
        Map<String, Object> request = new HashMap<>();
        request.put("toolName", "calculator");
        
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("operation", "divide");
        parameters.put("a", 10);
        // ਪੈਰਾਮੀਟਰ "b" ਮੌਜੂਦ ਨਹੀਂ
        request.put("parameters", parameters);
        
        // ਬੇਨਤੀ ਭੇਜੋ ਅਤੇ ਗਲਤੀ ਦਾ ਜਵਾਬ ਪੁਸ਼ਟੀ ਕਰੋ
        mockMvc.perform(post("/mcp/execute")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.error").exists());
    }
}
```

#### 3. ਆਖਰੀ ਤੋਂ ਆਖਰੀ ਟੈਸਟਿੰਗ

ਮਾਡਲ ਪ੍ਰੋਂਪਟ ਤੋਂ ਉਪਕਰਨ ਨਿਰਵਾਹ ਤੱਕ ਪੂਰਾ ਵਰਕਫਲੋ ਟੈਸਟ ਕਰੋ:

```python
@pytest.mark.asyncio
async def test_model_interaction_with_tool():
    # ਸੈੱਟ ਅਪ ਕਰੋ - MCP ਕਲਾਇੰਟ ਅਤੇ ਮੌਕ ਮਾਡਲ ਸੈੱਟ ਕਰੋ
    mcp_client = McpClient(server_url="http://localhost:5000")
    
    # ਮੌਕ ਮਾਡਲ ਦੇ ਉੱਤਰ
    mock_model = MockLanguageModel([
        MockResponse(
            "What's the weather in Seattle?",
            tool_calls=[{
                "tool_name": "weatherForecast",
                "parameters": {"location": "Seattle", "days": 3}
            }]
        ),
        MockResponse(
            "Here's the weather forecast for Seattle:\n- Today: 65°F, Partly Cloudy\n- Tomorrow: 68°F, Sunny\n- Day after: 62°F, Rain",
            tool_calls=[]
        )
    ])
    
    # ਮੌਕ ਮੌਸਮ ਟੂਲ ਦਾ ਉੱਤਰ
    with aioresponses() as mocked:
        mocked.post(
            "http://localhost:5000/mcp/execute",
            payload={
                "result": {
                    "location": "Seattle",
                    "forecast": [
                        {"date": "2023-06-01", "temperature": 65, "conditions": "Partly Cloudy"},
                        {"date": "2023-06-02", "temperature": 68, "conditions": "Sunny"},
                        {"date": "2023-06-03", "temperature": 62, "conditions": "Rain"}
                    ]
                }
            }
        )
        
        # ਕਾਰਵਾਈ ਕਰੋ
        response = await mcp_client.send_prompt(
            "What's the weather in Seattle?",
            model=mock_model,
            allowed_tools=["weatherForecast"]
        )
        
        # ਦਾਅਵਾ ਕਰੋ
        assert "Seattle" in response.generated_text
        assert "65" in response.generated_text
        assert "Sunny" in response.generated_text
        assert "Rain" in response.generated_text
        assert len(response.tool_calls) == 1
        assert response.tool_calls[0].tool_name == "weatherForecast"
```

### ਪ੍ਰਦਰਸ਼ਨ ਟੈਸਟਿੰਗ

#### 1. ਲੋਡ ਟੈਸਟਿੰਗ

ਟੈਸਟ ਕਰੋ ਕਿ MCP ਸਰਵਰ ਕਿੰਨੀ ਸਹਿਮਤੀਵਾਲੀ ਬੇਨਤੀਆਂ ਸੰਭਾਲ ਸਕਦਾ ਹੈ:

```csharp
[Fact]
public async Task McpServer_HandlesHighConcurrency()
{
    // Arrange
    var server = new McpServer(
        name: "TestServer",
        version: "1.0",
        maxConcurrentRequests: 100
    );
    
    server.RegisterTool(new FastExecutingTool());
    await server.StartAsync();
    
    var client = new McpClient("http://localhost:5000");
    
    // Act
    var tasks = new List<Task<McpResponse>>();
    for (int i = 0; i < 1000; i++)
    {
        tasks.Add(client.ExecuteToolAsync("fastTool", new { iteration = i }));
    }
    
    var results = await Task.WhenAll(tasks);
    
    // Assert
    Assert.Equal(1000, results.Length);
    Assert.All(results, r => Assert.NotNull(r));
}
```

#### 2. ਸਟ੍ਰੈੱਸ ਟੈਸਟਿੰਗ

ਤਕਲੀਫ਼ ਵਾਲੇ ਬੋਝ ਹੇਠ ਪ੍ਰਣਾਲੀ ਟੈਸਟ ਕਰੋ:

```java
@Test
public void testServerUnderStress() {
    int maxUsers = 1000;
    int rampUpTimeSeconds = 60;
    int testDurationSeconds = 300;
    
    // ਸਟ੍ਰੈੱਸ ਟੈਸਟਿੰਗ ਲਈ JMeter ਸੈਟਅਪ ਕਰੋ
    StandardJMeterEngine jmeter = new StandardJMeterEngine();
    
    // JMeter ਟੈਸਟ ਪਲੈਨ ਕੰਫਿਗਰ ਕਰੋ
    HashTree testPlanTree = new HashTree();
    
    // ਟੈਸਟ ਪਲੈਨ, ਥ੍ਰੈਡ ਗਰੁੱਪ, ਸੈਂਪਲਰ ਆਦਿ ਬਣਾਓ
    TestPlan testPlan = new TestPlan("MCP Server Stress Test");
    testPlanTree.add(testPlan);
    
    ThreadGroup threadGroup = new ThreadGroup();
    threadGroup.setNumThreads(maxUsers);
    threadGroup.setRampUp(rampUpTimeSeconds);
    threadGroup.setScheduler(true);
    threadGroup.setDuration(testDurationSeconds);
    
    testPlanTree.add(threadGroup);
    
    // ਟੂਲ ਚਲਾਉਣ ਲਈ HTTP ਸੈਂਪਲਰ ਜੋੜੋ
    HTTPSampler toolExecutionSampler = new HTTPSampler();
    toolExecutionSampler.setDomain("localhost");
    toolExecutionSampler.setPort(5000);
    toolExecutionSampler.setPath("/mcp/execute");
    toolExecutionSampler.setMethod("POST");
    toolExecutionSampler.addArgument("toolName", "calculator");
    toolExecutionSampler.addArgument("parameters", "{\"operation\":\"add\",\"a\":5,\"b\":7}");
    
    threadGroup.add(toolExecutionSampler);
    
    // ਲਿਸਨਰਜ ਸ਼ਾਮਲ ਕਰੋ
    SummaryReport summaryReport = new SummaryReport();
    threadGroup.add(summaryReport);
    
    // ਟੈਸਟ ਚਲਾਓ
    jmeter.configure(testPlanTree);
    jmeter.run();
    
    // ਨਤੀਜੇ ਵੈਧ ਕਰੋ
    assertEquals(0, summaryReport.getErrorCount());
    assertTrue(summaryReport.getAverage() < 200); // ਔਸਤ ਪ੍ਰਤੀਕਿਰਿਆ ਸਮਾਂ < 200ms
    assertTrue(summaryReport.getPercentile(90.0) < 500); // 90ਵੀਂ ਪ੍ਰਤਿਸਤ < 500ms
}
```

#### 3. ਨਿਗਰਾਨੀ ਅਤੇ ਪ੍ਰੋਫਾਈਲਿੰਗ

ਲੰਬੇ ਸਮੇਂ ਦੇ ਪ੍ਰਦਰਸ਼ਨ ਵਿਸ਼ਲੇਸ਼ਣ ਲਈ ਨਿਗਰਾਨੀ ਸੈੱਟ ਕਰੋ:

```python
# MCP ਸਰਵਰ ਲਈ ਨਿਗਰਾਨੀ ਸੈੱਟ ਕਰੋ
def configure_monitoring(server):
    # ਪ੍ਰੋਮੇਥੀਅਸ ਮੈਟ੍ਰਿਕਸ ਸੈੱਟ ਕਰੋ
    prometheus_metrics = {
        "request_count": Counter("mcp_requests_total", "Total MCP requests"),
        "request_latency": Histogram(
            "mcp_request_duration_seconds", 
            "Request duration in seconds",
            buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 2.5, 5.0, 10.0]
        ),
        "tool_execution_count": Counter(
            "mcp_tool_executions_total", 
            "Tool execution count",
            labelnames=["tool_name"]
        ),
        "tool_execution_latency": Histogram(
            "mcp_tool_duration_seconds", 
            "Tool execution duration in seconds",
            labelnames=["tool_name"],
            buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 2.5, 5.0, 10.0]
        ),
        "tool_errors": Counter(
            "mcp_tool_errors_total",
            "Tool execution errors",
            labelnames=["tool_name", "error_type"]
        )
    }
    
    # ਸਮਾਂ ਅਤੇ ਮੈਟ੍ਰਿਕਸ ਨੂੰ ਦਰਜ ਕਰਨ ਲਈ ਮਿਡਲਵੇਅਰ ਜੋੜੋ
    server.add_middleware(PrometheusMiddleware(prometheus_metrics))
    
    # ਮੈਟ੍ਰਿਕਸ ਐਂਡਪੌਇੰਟ ਨੂੰ ਖੁਲ੍ਹਾ ਕਰੋ
    @server.router.get("/metrics")
    async def metrics():
        return generate_latest()
    
    return server
```

## MCP ਵਰਕਫਲੋ ਡਿਜ਼ਾਈਨ ਪੈਟਰਨ

ਛੰਗਾ ਡਿਜ਼ਾਈਨ ਕੀਤਾ MCP ਵਰਕਫਲੋਜ਼ ਪ੍ਰਭਾਵਸ਼ਾਲੀਤਾ, ਭਰੋਸੇਯੋਗਤਾ ਅਤੇ ਸੰਭਾਲਯੋਗਤਾ ਨੂੰ ਸੁਧਾਰਦਾ ਹੈ। ਇੱਥੇ ਕੁਝ ਮੁੱਖ ਪੈਟਰਨ ਹਨ ਜਿਨ੍ਹਾਂ ਦੀ ਪਾਲਣਾ ਕਰੋ:

### 1. ਉਪਕਰਨਾਂ ਦੀ ਚੇਨ ਪੈਟਰਨ

ਕਈ ਉਪਕਰਨਾਂ ਨੂੰ ਇੱਕ ਲੜੀ ਵਿੱਚ ਜੁੜੋ ਜਿੱਥੇ ਹਰ ਉਪਕਰਨ ਦਾ ਨਤੀਜਾ ਅਗਲੇ ਲਈ ਇਨਪੁੱਟ ਬਣਦਾ ਹੈ:

```python
# ਪਾਈਥਨ ਚੇਨ ਆਫ ਟੂਲਜ਼ ਇੰਪਲੀਮੈਂਟੇਸ਼ਨ
class ChainWorkflow:
    def __init__(self, tools_chain):
        self.tools_chain = tools_chain  # ਕ੍ਰਮਬੱਧ ਤੌਰ 'ਤੇ ਚਲਾਉਣ ਲਈ ਟੂਲਾਂ ਦੇ ਨਾਮਾਂ ਦੀ ਸੂਚੀ
    
    async def execute(self, mcp_client, initial_input):
        current_result = initial_input
        all_results = {"input": initial_input}
        
        for tool_name in self.tools_chain:
            # ਚੇਨ ਵਿੱਚ ਹਰ ਟੂਲ ਨੂੰ ਚਲਾਓ, ਪਹਿਲਾਂ ਦੇ ਨਤੀਜੇ ਨੂੰ ਪਾਸ ਕਰਦੇ ਹੋਏ
            response = await mcp_client.execute_tool(tool_name, current_result)
            
            # ਨਤੀਜਾ ਸਟੋਰ ਕਰੋ ਅਤੇ ਅਗਲੇ ਟੂਲ ਲਈ ਇੰਪੁੱਟ ਵਜੋਂ ਵਰਤੋਂ
            all_results[tool_name] = response.result
            current_result = response.result
        
        return {
            "final_result": current_result,
            "all_results": all_results
        }

# ਉਦਾਹਰਨ ਵਰਤੋਂ
data_processing_chain = ChainWorkflow([
    "dataFetch",
    "dataCleaner",
    "dataAnalyzer",
    "dataVisualizer"
])

result = await data_processing_chain.execute(
    mcp_client,
    {"source": "sales_database", "table": "transactions"}
)
```

### 2. ਡਿਸਪੈਚਰ ਪੈਟਰਨ

ਇੱਕ ਕੇਂਦਰੀ ਉਪਕਰਨ ਵਰਤੋ ਜੋ ਇਨਪੁੱਟ ਅਨੁਸਾਰ ਵਿਸ਼ੇਸ਼ ਉਪਕਰਨਾਂ ਨੂੰ ਭੇਜਦਾ ਹੈ:

```csharp
public class ContentDispatcherTool : IMcpTool
{
    private readonly IMcpClient _mcpClient;
    
    public ContentDispatcherTool(IMcpClient mcpClient)
    {
        _mcpClient = mcpClient;
    }
    
    public string Name => "contentProcessor";
    public string Description => "Processes content of various types";
    
    public object GetSchema()
    {
        return new {
            type = "object",
            properties = new {
                content = new { type = "string" },
                contentType = new { 
                    type = "string",
                    enum = new[] { "text", "html", "markdown", "csv", "code" }
                },
                operation = new { 
                    type = "string",
                    enum = new[] { "summarize", "analyze", "extract", "convert" }
                }
            },
            required = new[] { "content", "contentType", "operation" }
        };
    }
    
    public async Task<ToolResponse> ExecuteAsync(ToolRequest request)
    {
        var content = request.Parameters.GetProperty("content").GetString();
        var contentType = request.Parameters.GetProperty("contentType").GetString();
        var operation = request.Parameters.GetProperty("operation").GetString();
        
        // Determine which specialized tool to use
        string targetTool = DetermineTargetTool(contentType, operation);
        
        // Forward to the specialized tool
        var specializedResponse = await _mcpClient.ExecuteToolAsync(
            targetTool,
            new { content, options = GetOptionsForTool(targetTool, operation) }
        );
        
        return new ToolResponse { Result = specializedResponse.Result };
    }
    
    private string DetermineTargetTool(string contentType, string operation)
    {
        return (contentType, operation) switch
        {
            ("text", "summarize") => "textSummarizer",
            ("text", "analyze") => "textAnalyzer",
            ("html", _) => "htmlProcessor",
            ("markdown", _) => "markdownProcessor",
            ("csv", _) => "csvProcessor",
            ("code", _) => "codeAnalyzer",
            _ => throw new ToolExecutionException($"No tool available for {contentType}/{operation}")
        };
    }
    
    private object GetOptionsForTool(string toolName, string operation)
    {
        // Return appropriate options for each specialized tool
        return toolName switch
        {
            "textSummarizer" => new { length = "medium" },
            "htmlProcessor" => new { cleanUp = true, operation },
            // Options for other tools...
            _ => new { }
        };
    }
}
```

### 3. ਸਮਾਂਤਰ 프로ਸੈਸਿੰਗ ਪੈਟਰਨ

ਪ੍ਰਭਾਵਸ਼ਾਲੀਤਾ ਲਈ ਕਈ ਉਪਕਰਨਾਂ ਨੂੰ ਇਕੱਠੇ ਆਮਲ ਵਿੱਚ ਲਿਆਓ:

```java
public class ParallelDataProcessingWorkflow {
    private final McpClient mcpClient;
    
    public ParallelDataProcessingWorkflow(McpClient mcpClient) {
        this.mcpClient = mcpClient;
    }
    
    public WorkflowResult execute(String datasetId) {
        // ਪੱਧਰ 1: ਡੈਟਾਸੈਟ ਮੈਟਾ ਡੇਟਾ ਪ੍ਰਾਪਤ ਕਰੋ (ਸਮਕਾਲੀਕ)
        ToolResponse metadataResponse = mcpClient.executeTool("datasetMetadata", 
            Map.of("datasetId", datasetId));
        
        // ਪੱਧਰ 2: ਕਈ ਵਿਸ਼ਲੇਸ਼ਣ ਇਕੱਠੇ ਸ਼ੁਰੂ ਕਰੋ
        CompletableFuture<ToolResponse> statisticalAnalysis = CompletableFuture.supplyAsync(() ->
            mcpClient.executeTool("statisticalAnalysis", Map.of(
                "datasetId", datasetId,
                "type", "comprehensive"
            ))
        );
        
        CompletableFuture<ToolResponse> correlationAnalysis = CompletableFuture.supplyAsync(() ->
            mcpClient.executeTool("correlationAnalysis", Map.of(
                "datasetId", datasetId,
                "method", "pearson"
            ))
        );
        
        CompletableFuture<ToolResponse> outlierDetection = CompletableFuture.supplyAsync(() ->
            mcpClient.executeTool("outlierDetection", Map.of(
                "datasetId", datasetId,
                "sensitivity", "medium"
            ))
        );
        
        // ਸਾਰੇ ਸਮਕਾਲੀਕ ਕਾਰਜਾਂ ਦੇ ਪੂਰੇ ਹੋਣ ਲਈ ਉਡੀਕ ਕਰੋ
        CompletableFuture<Void> allAnalyses = CompletableFuture.allOf(
            statisticalAnalysis, correlationAnalysis, outlierDetection
        );
        
        allAnalyses.join();  // ਪੂਰਾ ਹੋਣ ਦੀ ਉਡੀਕ ਕਰੋ
        
        // ਪੱਧਰ 3: ਨਤੀਜੇ ਇਕੱਠੇ ਕਰੋ
        Map<String, Object> combinedResults = new HashMap<>();
        combinedResults.put("metadata", metadataResponse.getResult());
        combinedResults.put("statistics", statisticalAnalysis.join().getResult());
        combinedResults.put("correlations", correlationAnalysis.join().getResult());
        combinedResults.put("outliers", outlierDetection.join().getResult());
        
        // ਪੱਧਰ 4: ਸਾਰੰਸ਼ ਰਿਪੋਰਟ ਤਿਆਰ ਕਰੋ
        ToolResponse summaryResponse = mcpClient.executeTool("reportGenerator", 
            Map.of("analysisResults", combinedResults));
        
        // ਪੂਰਾ ਕੰਮ ਦੀ ਪ੍ਰਕਿਰਿਆ ਨਤੀਜਾ ਵਾਪਸ ਕਰੋ
        WorkflowResult result = new WorkflowResult();
        result.setDatasetId(datasetId);
        result.setAnalysisResults(combinedResults);
        result.setSummaryReport(summaryResponse.getResult());
        
        return result;
    }
}
```

### 4. ਐਰਰ ਮੁੜ ਪ੍ਰਾਪਤੀ ਪੈਟਰਨ

ਉਪਕਰਨ ਠੁਕਰਾਓਣ ਲਈ ਸੁਖਦਾਇਕ ਵਿਕਲਪ ਲਾਗੂ ਕਰੋ:

```python
class ResilientWorkflow:
    def __init__(self, mcp_client):
        self.client = mcp_client
    
    async def execute_with_fallback(self, primary_tool, fallback_tool, parameters):
        try:
            # ਪਹਿਲਾ ਮੁੱਢਲਾ ਟੂਲ ਕੋਸ਼ਿਸ਼ ਕਰੋ
            response = await self.client.execute_tool(primary_tool, parameters)
            return {
                "result": response.result,
                "source": "primary",
                "tool": primary_tool
            }
        except ToolExecutionException as e:
            # ਨਾਕਾਮੀ ਨੂੰ ਲੌਗ ਕਰੋ
            logging.warning(f"Primary tool '{primary_tool}' failed: {str(e)}")
            
            # ਦੂਸਰੇ ਟੂਲ ਤੇ ਮੁੜ ਤੋਂ ਕੋਸ਼ਿਸ਼ ਕਰੋ
            try:
                # ਮੁੜ-ਕਿਸੇ ਟੂਲ ਲਈ ਪੈਰਾਮੀਟਰਾਂ ਨੂੰ ਬਦਲਣ ਦੀ ਲੋੜ ਹੋ ਸਕਦੀ ਹੈ
                fallback_params = self._adapt_parameters(parameters, primary_tool, fallback_tool)
                
                response = await self.client.execute_tool(fallback_tool, fallback_params)
                return {
                    "result": response.result,
                    "source": "fallback",
                    "tool": fallback_tool,
                    "primaryError": str(e)
                }
            except ToolExecutionException as fallback_error:
                # ਦੋਵੇਂ ਟੂਲ ਨਾਕਾਮ ਰਹੇ
                logging.error(f"Both primary and fallback tools failed. Fallback error: {str(fallback_error)}")
                raise WorkflowExecutionException(
                    f"Workflow failed: primary error: {str(e)}; fallback error: {str(fallback_error)}"
                )
    
    def _adapt_parameters(self, params, from_tool, to_tool):
        """Adapt parameters between different tools if needed"""
        # ਇਹ ਲਾਗੂ ਕਰਨ ਵਾਲਾ ਵਿਸ਼ੇਸ਼ ਟੂਲਾਂ 'ਤੇ ਨਿਰਭਰ ਕਰੇਗਾ
        # ਇਸ ਉਦਾਹਰਨ ਲਈ, ਅਸੀਂ ਸਿਰਫ਼ ਮੂਲ ਪੈਰਾਮੀਟਰ ਵਾਪਸ ਕਰਾਂਗੇ
        return params

# ਉਦਾਹਰਨ ਵਰਤੋਂ
async def get_weather(workflow, location):
    return await workflow.execute_with_fallback(
        "premiumWeatherService",  # ਮੁੱਖ (ਭੁਗਤਾਨ ਕੀਤੀ) ਮੌਸਮ ਏਪੀਆਈ
        "basicWeatherService",    # ਬੈਕਅੱਪ (ਮੁਫਤ) ਮੌਸਮ ਏਪੀਆਈ
        {"location": location}
    )
```

### 5. ਵਰਕਫਲੋ ਕੰਪੋਜ਼ੀਸ਼ਨ ਪੈਟਰਨ

ਸਧਾਰਣ ਵਰਕਫਲੋਜ਼ ਨੂੰ ਮਿਲਾ ਕੇ ਜਟਿਲ ਵਰਕਫਲੋ ਬਣਾਓ:

```csharp
public class CompositeWorkflow : IWorkflow
{
    private readonly List<IWorkflow> _workflows;
    
    public CompositeWorkflow(IEnumerable<IWorkflow> workflows)
    {
        _workflows = new List<IWorkflow>(workflows);
    }
    
    public async Task<WorkflowResult> ExecuteAsync(WorkflowContext context)
    {
        var results = new Dictionary<string, object>();
        
        foreach (var workflow in _workflows)
        {
            var workflowResult = await workflow.ExecuteAsync(context);
            
            // Store each workflow's result
            results[workflow.Name] = workflowResult;
            
            // Update context with the result for the next workflow
            context = context.WithResult(workflow.Name, workflowResult);
        }
        
        return new WorkflowResult(results);
    }
    
    public string Name => "CompositeWorkflow";
    public string Description => "Executes multiple workflows in sequence";
}

// Example usage
var documentWorkflow = new CompositeWorkflow(new IWorkflow[] {
    new DocumentFetchWorkflow(),
    new DocumentProcessingWorkflow(),
    new InsightGenerationWorkflow(),
    new ReportGenerationWorkflow()
});

var result = await documentWorkflow.ExecuteAsync(new WorkflowContext {
    Parameters = new { documentId = "12345" }
});
```

# MCP ਸਰਵਰਾਂ ਦੀ ਟੈਸਟਿੰਗ: ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ ਅਤੇ ਮੁੱਖ ਟਿੱਪਣੀਆਂ

## ਜਾਇਜ਼ਾ

ਟੈਸਟਿੰਗ ਭਰੋਸੇਯੋਗ, ਉੱਚ-ਗੁਣਵੱਤਾ ਵਾਲੇ MCP ਸਰਵਰਾਂ ਦੇ ਵਿਕਾਸ ਲਈ ਇੱਕ ਅਹੰਕਾਰਕ ਪੱਖ ਹੈ। ਇਹ ਗਾਈਡ ਆਪਣੇ MCP ਸਰਵਰਾਂ ਦੀ ਵਿਕਾਸ ਲਾਈਫਸਾਈਕਲ ਦੌਰਾਨ ਟੈਸਟਿੰਗ ਲਈ ਵਿਸਤਾਰਪੂਰਕ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ ਅਤੇ ਟਿੱਪਣੀਆਂ ਮੁਹੱਈਆ ਕਰਵਾਉਂਦਾ ਹੈ, ਯੂਨਿਟ ਟੈਸਟ ਤੋਂ ਇੰਟਿਗ੍ਰੇਸ਼ਨ ਟੈਸਟ ਅਤੇ ਆਖਰੀ ਤੋਂ ਆਖਰੀ ਪ੍ਰਮਾਣ ਕੇ ਦੀ।

## MCP ਸਰਵਰਾਂ ਲਈ ਟੈਸਟਿੰਗ ਕਿਉਂ ਜ਼ਰੂਰੀ ਹੈ

MCP ਸਰਵਰ AI ਮਾਡਲਾਂ ਅਤੇ ਕਲਾਇੰਟ ਐਪਲੀਕੇਸ਼ਨਾਂ ਦੇ ਵਿਚਕਾਰ ਇਕ ਜਰੂਰੀ ਮੈਡੀਏਟਰ ਵਜੋਂ ਕੰਮ ਕਰਦੇ ਹਨ। ਪੂਰੀ ਟੈਸਟਿੰਗ ਇਹ ਯਕੀਨੀ ਬਣਾਉਂਦੀ ਹੈ:

- ਪ੍ਰੋਡਕਸ਼ਨ ਵਾਤਾਵਰਨ ਵਿੱਚ ਭਰੋਸੇਯੋਗਤਾ
- ਬੇਨਤੀਆਂ ਅਤੇ ਜਵਾਬਾਂ ਦੀ ਸਹੀ ਸੰਭਾਲ
- MCP ਵਿਸ਼ੇਸ਼ਤਾਵਾਂ ਦੀ ਠੀਕ ਤਰ੍ਹਾਂ ਲਾਗੂ ਕਰਨ
- ਨੁਕਸਾਨਾਂ ਅਤੇ ਕਿਨਾਰੀ ਮਾਮਲਿਆਂ ਖਿਲਾਫ਼ ਸਹਿਣਸ਼ੀਲਤਾ
- ਵੱਖ-ਵੱਖ ਲੋਡ ਹੇਠ ਸਥਿਰ ਪ੍ਰਦਰਸ਼ਨ

## MCP ਸਰਵਰਾਂ ਲਈ ਯੂਨਿਟ ਟੈਸਟਿੰਗ

### ਯੂਨਿਟ ਟੈਸਟਿੰਗ (ਬੁਨਿਆਦ)

ਯੂਨਿਟ ਟੈਸਟ MCP ਸਰਵਰ ਦੇ ਵਿਅਕਤੀਗਤ ਹਿੱਸਿਆਂ ਨੂੰ ਅਲੱਗ-ਅਲੱਗ ਜਾਂਚਦਾ ਹੈ।

#### ਕੀ ਟੈਸਟ ਕਰਨਾ ਹੈ

1. **ਸਰੋਤ ਹੈਂਡਲਰ**: ਹਰ ਸਰੋਤ ਹੈਂਡਲਰ ਦੀ ਤਰਕ ਨੂੰ ਅਲੱਗ-ਅਲੱਗ ਟੈਸਟ ਕਰੋ  
2. **ਉਪਕਰਨ ਲਾਗੂ ਕਰਨ**: ਵੱਖ-ਵੱਖ ਇਨਪੁੱਟਸ ਨਾਲ ਉਪਕਰਨ ਦੀ ਵਰਤੋਂ ਦੀ ਪੁਸ਼ਟੀ ਕਰੋ  
3. **ਪ੍ਰੋਂਪਟ ਟੈਮਪਲੇਟ**: ਯਕੀਨੀ ਬਣਾਓ ਕਿ ਪ੍ਰੋਂਪਟ ਟੈਮਪਲੇਟਸ ਠੀਕ ਤਰ੍ਹਾਂ ਰੈਂਡਰ ਹੁੰਦੇ ਹਨ  
4. **ਸਕੀਮਾ ਸੱਚਾਈ**: ਪੈਰਾਮੀਟਰ ਸੱਚਾਈ ਲਾਜਿਕ ਟੈਸਟ ਕਰੋ  
5. **ਐਰਰ ਹੈਂਡਲਿੰਗ**: ਗਲਤ ਇਨਪੁੱਟ ਲਈ ਐਰਰ ਜਵਾਬਾਂ ਦੀ ਪੁਸ਼ਟੀ ਕਰੋ

#### ਯੂਨਿਟ ਟੈਸਟਿੰਗ ਲਈ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ

```csharp
// Example unit test for a calculator tool in C#
[Fact]
public async Task CalculatorTool_Add_ReturnsCorrectSum()
{
    // Arrange
    var calculator = new CalculatorTool();
    var parameters = new Dictionary<string, object>
    {
        ["operation"] = "add",
        ["a"] = 5,
        ["b"] = 7
    };
    
    // Act
    var response = await calculator.ExecuteAsync(parameters);
    var result = JsonSerializer.Deserialize<CalculationResult>(response.Content[0].ToString());
    
    // Assert
    Assert.Equal(12, result.Value);
}
```

```python
# ਪਾਇਥਨ ਵਿੱਚ ਕੈਲਕੁਲੇਟਰ ਟੂਲ ਲਈ ਉਦਾਹਰਣ ਯੂਨਿਟ ਟੈਸਟ
def test_calculator_tool_add():
    # ਵਿਵਸਥਾ ਕਰੋ
    calculator = CalculatorTool()
    parameters = {
        "operation": "add",
        "a": 5,
        "b": 7
    }
    
    # ਕਾਰਵਾਈ ਕਰੋ
    response = calculator.execute(parameters)
    result = json.loads(response.content[0].text)
    
    # ਪੁਸ਼ਟੀ ਕਰੋ
    assert result["value"] == 12
```

### ਇੰਟਿਗ੍ਰੇਸ਼ਨ ਟੈਸਟਿੰਗ (ਮੱਧ ਤਹਿ)

ਇੰਟਿਗ੍ਰੇਸ਼ਨ ਟੈਸਟ MCP ਸਰਵਰ ਦੇ ਹਿੱਸਿਆਂ ਦਰਮਿਆਨ ਬਹਿਚਾਰ ਦੀ ਜਾਂਚ ਕਰਦਾ ਹੈ।

#### ਕੀ ਟੈਸਟ ਕਰਨਾ ਹੈ

1. **ਸਰਵਰ ਸ਼ੁਰੂਆਤ**: ਵੱਖ-ਵੱਖ ਸੰਰਚਨਾਵਾਂ ਨਾਲ ਸਰਵਰ ਨੂੰ ਸ਼ੁਰੂ ਕਰੋ  
2. **ਰੂਟ ਰਜਿਸਟ੍ਰੇਸ਼ਨ**: ਯਕੀਨੀ ਬਣਾਓ ਕਿ ਸਾਰੇ ਏਂਡਪਾਇੰਟ ਠੀਕ ਤਰ੍ਹਾਂ ਰਜਿਸਟਰ ਹਨ  
3. **ਬੇਨਤੀ ਪ੍ਰੋਸੈਸਿੰਗ**: ਪੂਰੇ ਬੇਨਤੀ-ਜਵਾਬ ਚੱਕਰ ਨੂੰ ਟੈਸਟ ਕਰੋ  
4. **ਐਰਰ ਪ੍ਰਸਾਰਣ**: ਪੂਰੇ ਹਿੱਸਿਆਂ ਵਿੱਚ ਐਰਰਾਂ ਦੀ ਠੀਕ ਸਾਂਝ ਨੂੰ ਯਕੀਨੀ ਬਣਾਓ  
5. **ਪਰਮਾਣੀਕਤਾ ਅਤੇ ਅਧਿਕਾਰ**: ਸੁਰੱਖਿਆ ਯੰਤਰਾਂ ਦੀ ਟੈਸਟਿੰਗ ਕਰੋ

#### ਇੰਟਿਗ੍ਰੇਸ਼ਨ ਟੈਸਟਿੰਗ ਲਈ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ

```csharp
// Example integration test for MCP server in C#
[Fact]
public async Task Server_ProcessToolRequest_ReturnsValidResponse()
{
    // Arrange
    var server = new McpServer();
    server.RegisterTool(new CalculatorTool());
    await server.StartAsync();
    
    var request = new McpRequest
    {
        Tool = "calculator",
        Parameters = new Dictionary<string, object>
        {
            ["operation"] = "multiply",
            ["a"] = 6,
            ["b"] = 7
        }
    };
    
    // Act
    var response = await server.ProcessRequestAsync(request);
    
    // Assert
    Assert.NotNull(response);
    Assert.Equal(McpStatusCodes.Success, response.StatusCode);
    // Additional assertions for response content
    
    // Cleanup
    await server.StopAsync();
}
```

### ਆਖਰੀ ਤੋਂ ਆਖਰੀ ਟੈਸਟਿੰਗ (ਉੱਪਰੀ ਤਹਿ)

ਆਖਰੀ ਤੋਂ ਆਖਰੀ ਟੈਸਟ ਪੂਰੀ ਪ੍ਰਣਾਲੀ ਦੇ ਵਰਤਾਰੂ ਬਿਹੈਵਿਅਰ ਦਾ ਪ੍ਰਮਾਣੀਕਰਨ ਕਰਦੇ ਹਨ ਕਲਾਇੰਟ ਤੋਂ ਸਰਵਰ ਤੱਕ।

#### ਕੀ ਟੈਸਟ ਕਰਨਾ ਹੈ

1. **ਕਲਾਇੰਟ-ਸਰਵਰ ਸੰਚਾਰ**: ਪੂਰੇ ਬੇਨਤੀ-ਜਵਾਬ ਚੱਕਰ ਨੂੰ ਟੈਸਟ ਕਰੋ  
2. **ਅਸਲੀ ਕਲਾਇੰਟ SDKs**: ਅਸਲੀ ਕਲਾਇੰਟ ਲਾਗੂ ਕਰਨ ਨਾਲ ਟੈਸਟ ਕਰੋ  
3. **ਲੋਡ ਹੇਠ ਪ੍ਰਦਰਸ਼ਨ**: ਕਈ ਇਕੱਠਾ ਬੇਨਤੀਆਂ ਨਾਲ ਵਰਤਾਰੂ ਦੀ ਜਾਂਚ ਕਰੋ  
4. **ਐਰਰ ਮੁੜ ਪ੍ਰਾਪਤੀ**: ਨੁਕਸਾਨਾਂ ਤੋਂ ਪ੍ਰਣਾਲੀ ਦੀ ਬਹਾਲੀ ਟੈਸਟ ਕਰੋ  
5. **ਲੰਬੇ ਚੱਲ ਰਹੇ ਕਾਰਵਾਈਆਂ**: ਸਟ੍ਰੀਮਿੰਗ ਅਤੇ ਲੰਬੇ ਕਾਰਜਾਂ ਦੀ ਸੰਭਾਲ ਦੀ ਪੁਸ਼ਟੀ ਕਰੋ

#### ਆਖਰੀ ਤੋਂ ਆਖਰੀ ਟੈਸਟਿੰਗ ਲਈ ਸਰਵੋਤਮ ਪ੍ਰਥਾਵਾਂ

```typescript
// ਟਾਈਪਸਕ੍ਰਿਪਟ ਵਿੱਚ ਕਲਾਇੰਟ ਨਾਲ ਉਦਾਹਰਣ E2E ਟੈਸਟ
describe('MCP Server E2E Tests', () => {
  let client: McpClient;
  
  beforeAll(async () => {
    // ਟੈਸਟ ਮਾਹੌਲ ਵਿੱਚ ਸਰਵਰ ਸ਼ੁਰੂ ਕਰੋ
    await startTestServer();
    client = new McpClient('http://localhost:5000');
  });
  
  afterAll(async () => {
    await stopTestServer();
  });
  
  test('Client can invoke calculator tool and get correct result', async () => {
    // ਕਾਰਵਾਈ ਕਰੋ
    const response = await client.invokeToolAsync('calculator', {
      operation: 'divide',
      a: 20,
      b: 4
    });
    
    // ਦਾਅਵਾ ਕਰੋ
    expect(response.statusCode).toBe(200);
    expect(response.content[0].text).toContain('5');
  });
});
```

## MCP ਟੈਸਟਿੰਗ ਲਈ ਮੌਕਿੰਗ ਰਣਨੀਤੀਆਂ

ਟੈਸਟ ਦੌਰਾਨ ਹਿੱਸਿਆਂ ਨੂੰ ਵੱਖ-ਵੱਖ ਕਰਨ ਲਈ ਮੌਕਿੰਗ ਜਰੂਰੀ ਹੈ।

### ਮੌਕ ਕਰਨ ਵਾਲੇ ਹਿੱਸੇ

1. **ਬਾਹਰੀ AI ਮਾਡਲ**: ਭਵਿੱਖਬਾਣੀਯੋਗ ਟੈਸਟਿੰਗ ਲਈ ਮਾਡਲ ਜਵਾਬਾਂ ਮੌਕ ਕਰੋ  
2. **ਬਾਹਰੀ ਸੇਵਾਵਾਂ**: API ਨਿਰਭਰਤਾਵਾਂ (ਡੇਟਾਬੇਸ, ਤੀਜੀ ਪੱਖ ਸੇਵਾਵਾਂ) ਮੌਕ ਕਰੋ  
3. **ਪਰਮਾਣੀਕਤਾ ਸੇਵਾਵਾਂ**: ਪਛਾਣ ਪ੍ਰਦਾਤਾ ਮੌਕ ਕਰੋ  
4. **ਸਰੋਤ ਪ੍ਰਦਾਤਾ**: ਮਹਿੰਗੇ ਸਰੋਤ ਹੈਂਡਲਰ ਮੌਕ ਕਰੋ

### ਉਦਾਹਰਨ: AI ਮਾਡਲ ਜਵਾਬ ਮੌਕਿੰਗ

```csharp
// C# example with Moq
var mockModel = new Mock<ILanguageModel>();
mockModel
    .Setup(m => m.GenerateResponseAsync(
        It.IsAny<string>(),
        It.IsAny<McpRequestContext>()))
    .ReturnsAsync(new ModelResponse { 
        Text = "Mocked model response",
        FinishReason = FinishReason.Completed
    });

var server = new McpServer(modelClient: mockModel.Object);
```

```python
# unittest.mock ਨਾਲ ਪਾਈਥਨ ਉਦਾਹਰਨ
@patch('mcp_server.models.OpenAIModel')
def test_with_mock_model(mock_model):
    # ਮੌਕ ਕਾਂਫ਼ਿਗਰ ਕਰੋ
    mock_model.return_value.generate_response.return_value = {
        "text": "Mocked model response",
        "finish_reason": "completed"
    }
    
    # ਟੈਸਟ ਵਿੱਚ ਮੌਕ ਦੀ ਵਰਤੋਂ ਕਰੋ
    server = McpServer(model_client=mock_model)
    # ਟੈਸਟ ਨਾਲ ਜਾਰੀ ਰੱਖੋ
```

## ਪ੍ਰਦਰਸ਼ਨ ਟੈਸਟਿੰਗ

ਪ੍ਰਦਰਸ਼ਨ ਟੈਸਟਿੰਗ ਪ੍ਰੋਡਕਸ਼ਨ MCP ਸਰਵਰਾਂ ਲਈ ਜ਼ਰੂਰੀ ਹੈ।

### ਕੀ ਮਾਪਣਾ ਹੈ

1. **ਲੈਟੈਂਸੀ**: ਬੇਨਤੀਆਂ ਲਈ ਜਵਾਬ ਸਮਾਂ  
2. **ਥਰੂਪੁੱਟ**: ਪ੍ਰਤੀ ਸਕਿੰਟ ਸੰਭਾਲੀਆਂ ਬੇਨਤੀਆਂ  
3. **ਸਰੋਤ ਵਰਤੋਂ**: CPU, ਮੈਮੋਰੀ, ਨੈੱਟਵਰਕ ਵਰਤੋਂ  
4. **ਸਹਿਮਤੀਵਾਲੀ ਸੰਭਾਲ**: ਸਮਾਂਤਰ ਬੇਨਤੀਆਂ ਹੇਠ ਵਿਹਾਰ  
5. **ਪੈਮਾਨਾ ਚਿੱਤਰਣ**: ਜਦੋਂ ਲੋਡ ਵਧੇ ਤਦ ਪ੍ਰਦਰਸ਼ਨ

### ਪ੍ਰਦਰਸ਼ਨ ਟੈਸਟਿੰਗ ਲਈ ਟੂਲ

- **k6**: ਖੁੱਲ੍ਹਾ ਸਰੋਤ ਲੋਡ ਟੈਸਟਿੰਗ ਟੂਲ  
- **JMeter**: ਵਿਸਤਾਰਪੂਰਕ ਪ੍ਰਦਰਸ਼ਨ ਟੈਸਟਿੰਗ  
- **Locust**: Python ਆਧਾਰਿਤ ਲੋਡ ਟੈਸਟਿੰਗ  
- **Azure Load Testing**: ਕਲਾਉਡ ਆਧਾਰਤ ਪ੍ਰਦਰਸ਼ਨ ਟੈਸਟਿੰਗ

### ਉਦਾਹਰਨ: k6 ਨਾਲ ਬੁਨਿਆਦੀ ਲੋਡ ਟੈਸਟ

```javascript
// MCP ਸਰਵਰ ਲਈ ਲੋਡ ਟੈਸਟਿੰਗ ਲਈ k6 ਸਕ੍ਰਿਪਟ
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  vus: 10,  // 10 ਵਰਚੂਅਲ ਯੂਜ਼ਰਜ਼
  duration: '30s',
};

export default function () {
  const payload = JSON.stringify({
    tool: 'calculator',
    parameters: {
      operation: 'add',
      a: Math.floor(Math.random() * 100),
      b: Math.floor(Math.random() * 100)
    }
  });

  const params = {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer test-token'
    },
  };

  const res = http.post('http://localhost:5000/api/tools/invoke', payload, params);
  
  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
  
  sleep(1);
}
```

## MCP ਸਰਵਰਾਂ ਲਈ ਟੈਸਟ ਆਟੋਮੇਸ਼ਨ

ਆਪਣੇ ਟੈਸਟਾਂ ਨੂੰ ਆਟੋਮੇਟ ਕਰਨ ਨਾਲ ਗੁਣਵੱਤਾ ਸਥਿਰ ਰਹਿੰਦੀ ਹੈ ਅਤੇ ਫੀਡਬੈਕ ਲੂਪ ਤੇਜ਼ ਹੁੰਦਾ ਹੈ।

### ਸੀ ਆਈ/ਸੀਡੀ ਇੰਟੀਗ੍ਰੇਸ਼ਨ
1. **ਪੁਲ ਰਿਕਵੇਸਟਾਂ 'ਤੇ ਯੂਨਿਟ ਟੈਸਟ ਚਲਾਓ**: ਇਹ ਯਕੀਨੀ ਬਣਾਓ ਕਿ ਕੋਡ ਬਦਲਾਅ ਮੌਜੂਦਾ ਫੰਕਸ਼ਨਲਟੀ ਨੂੰ ਖ਼ਰਾਬ ਨਾ ਕਰਨ
2. **ਸਟੇਜਿੰਗ ਵਿੱਚ ਇੰਟੀਗ੍ਰੇਸ਼ਨ ਟੈਸਟਸ**: ਪ੍ਰੀ-ਪ੍ਰੋਡਕਸ਼ਨ ਪਰਿਵੇਸ਼ਾਂ ਵਿੱਚ ਇੰਟੀਗ੍ਰੇਸ਼ਨ ਟੈਸਟਸ ਚਲਾਓ
3. **ਪ੍ਰਦਰਸ਼ਨ ਬੇਸਲਾਈਨਸ**: ਰਿਗ੍ਰੈਸ਼ਨ ਪਕੜਨ ਲਈ ਪ੍ਰਦਰਸ਼ਨ ਮਾਪਦੰਡ ਬਣਾਏ ਰੱਖੋ
4. **ਸੁਰੱਖਿਆ ਸਕੈਨ**: ਪਾਈਪਲਾਈਨ ਦੇ ਹਿੱਸੇ ਵਜੋਂ ਸੁਰੱਖਿਆ ਟੈਸਟਿੰਗ ਨੂੰ ਆਟੋਮੇਟ ਕਰੋ

### ਉਦਾਹਰਨ CI ਪਾਈਪਲਾਈਨ (GitHub Actions)

```yaml
name: MCP Server Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Runtime
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: '8.0.x'
    
    - name: Restore dependencies
      run: dotnet restore
    
    - name: Build
      run: dotnet build --no-restore
    
    - name: Unit Tests
      run: dotnet test --no-build --filter Category=Unit
    
    - name: Integration Tests
      run: dotnet test --no-build --filter Category=Integration
      
    - name: Performance Tests
      run: dotnet run --project tests/PerformanceTests/PerformanceTests.csproj
```

## MCP ਵਿਸ਼ੇਸ਼ਣ ਨਾਲ ਅਨੁਕੂਲਤਾ ਲਈ ਟੈਸਟਿੰਗ

ਆਪਣੇ ਸਰਵਰ ਦੀ ਜਾਂਚ ਕਰੋ ਕਿ ਉਹ ਸਹੀ ਤਰ੍ਹਾਂ MCP ਵਿਸ਼ੇਸ਼ਣ ਨੂੰ ਲਾਗੂ ਕਰਦਾ ਹੈ।

### ਮੁੱਖ ਅਨੁਕੂਲਤਾ ਖੇਤਰ

1. **API ਐਂਡਪੋਇੰਟਸ**: ਲੋੜੀਂਦੇ ਐਂਡਪੋਇੰਟਸ ਦਾ ਟੈਸਟ ਕਰੋ (/resources, /tools, ਆਦਿ)
2. **ਰਿਕਵੇਸਟ/ਰਿਸਪਾਂਸ ਫਾਰਮੈਟ**: ਸਕੀਮਾ ਅਨੁਕੂਲਤਾ ਦੀ ਪੁਸ਼ਟੀ ਕਰੋ
3. **ਏਰਰ ਕੋਡਸ**: ਵੱਖ-ਵੱਖ ਸਥਿਤੀਆਂ ਲਈ ਸਹੀ ਸਥਿਤੀ ਕੋਡ ਦੀ ਜਾਂਚ ਕਰੋ
4. **ਸਮੱਗਰੀ ਦੇ ਕਿਸਮਾਂ**: ਵੱਖ-ਵੱਖ ਸਮੱਗਰੀ ਕਿਸਮਾਂ ਦਾ ਸੰਭਾਲ ਟੈਸਟ ਕਰੋ
5. **ਪ੍ਰਮਾਣਿਕਤਾ ਫਲੋ**: ਵਿਸ਼ੇਸ਼ਣ-ਅਨੁਕੂਲ ਔਥ ਮਕੈਨਿਜ਼ਮ ਦੀ ਜਾਂਚ ਕਰੋ

### ਅਨੁਕੂਲਤਾ ਟੈਸਟ ਸੂਟ

```csharp
[Fact]
public async Task Server_ResourceEndpoint_ReturnsCorrectSchema()
{
    // Arrange
    var client = new HttpClient();
    client.DefaultRequestHeaders.Add("Authorization", "Bearer test-token");
    
    // Act
    var response = await client.GetAsync("http://localhost:5000/api/resources");
    var content = await response.Content.ReadAsStringAsync();
    var resources = JsonSerializer.Deserialize<ResourceList>(content);
    
    // Assert
    Assert.Equal(HttpStatusCode.OK, response.StatusCode);
    Assert.NotNull(resources);
    Assert.All(resources.Resources, resource => 
    {
        Assert.NotNull(resource.Id);
        Assert.NotNull(resource.Type);
        // Additional schema validation
    });
}
```

## MCP ਸਰਵਰ ਦੀ ਪ੍ਰਭਾਵਸ਼ਾਲੀ ਟੈਸਟਿੰਗ ਲਈ ਸਰਵੋਚ 10 ਟਿਪਸ

1. **ਟੈਸਟ ਟੂਲ ਪਰਿਭਾਸ਼ਾਵਾਂ ਨੂੰ ਵੱਖ ਵੱਖ ਟੈਸਟ ਕਰੋ**: ਟੂਲ ਲਾਜਿਕ ਤੋਂ ਆਜ਼ਾਦ ਸਕੀਮਾ ਪਰਿਭਾਸ਼ਾਵਾਂ ਦੀ ਪੁਸ਼ਟੀ ਕਰੋ
2. **ਪੈਰਾਮੀਟਰਾਈਜ਼ਡ ਟੈਸਟਸ ਦੀ ਵਰਤੋਂ ਕਰੋ**: ਵੱਖ-ਵੱਖ ਇਨਪੁੱਟ, ਜਿਵੇਂ ਕਿ ਐਜ ਕੇਸਾਂ ਨਾਲ ਟੂਲ ਦੀ ਪਰਖ ਕਰੋ
3. **ਏਰਰ ਰਿਸਪਾਂਸ ਚੈੱਕ ਕਰੋ**: ਸਾਰੇ ਸੰਭਵ ਏਰਰ ਹਾਲਤਾਂ ਲਈ ਸਹੀ ਢੰਗ ਨਾਲ ਏਰਰ ਸੰਭਾਲ ਦੀ ਜਾਂਚ ਕਰੋ
4. **ਅਧਿਕਾਰ ਲਾਜਿਕ ਦੀ ਟੈਸਟਿੰਗ ਕਰੋ**: ਵੱਖ-ਵੱਖ ਯੂਜ਼ਰ ਭੂਮਿਕਾਵਾਂ ਲਈ ਸਹੀ ਪਹੁੰਚ ਨਿਯੰਤਰਣ ਯਕੀਨੀ ਬਣਾਓ
5. **ਟੈਸਟ ਕਵਰੇਜ ਮਾਨੀਟਰ ਕਰੋ**: ਅਹਿਮ ਰਾਹ ਕੋਡ ਦੀ ਉੱਚ ਕਵਰੇਜ ਦਾ ਲਕਸ਼ ਰੱਖੋ
6. **ਸਟ੍ਰੀਮਿੰਗ ਰਿਸਪਾਂਸ ਟੈਸਟ ਕਰੋ**: ਸਟ੍ਰੀਮਿੰਗ ਸਮੱਗਰੀ ਦੇ ਸਹੀ ਸੰਭਾਲ ਦੀ ਜਾਂਚ ਕਰੋ
7. **ਨੈੱਟਵਰਕ ਸਮੱਸਿਆਵਾਂ ਦਾ ਅਨੁਕਰਣ ਕਰੋ**: ਖਰਾਬ ਨੈੱਟਵਰਕ ਹਾਲਤਾਂ ਹੇਠ ਟੈਸਟਿੰਗ ਕਰੋ
8. **ਸਰੋਤ ਸੀਮਾਵਾਂ ਦੀ ਟੈਸਟਿੰਗ ਕਰੋ**: ਕੋਟਾ ਜਾਂ ਰੇਟ ਸੀਮਾਵਾਂ ਤੱਕ ਪਹੁੰਚਣ 'ਤੇ ਕੁਦਰਤੀ ਵਿਵਹਾਰ ਦੀ ਜਾਂਚ ਕਰੋ
9. **ਰਿਗ੍ਰੈਸ਼ਨ ਟੈਸਟ ਆਟੋਮੇਟ ਕਰੋ**: ਇੱਕ ਐਸੀ ਸੂਟ ਬਣਾਓ ਜੋ ਹਰ ਕੋਡ ਬਦਲਾਅ 'ਤੇ ਚਲੇ
10. **ਟੈਸਟ ਕੇਸਾਂ ਦਾ ਦਸਤਾਵੇਜ਼ ਬਣਾਓ**: ਟੈਸਟ ਸਥਿਤੀਆਂ ਦੀ ਸਪਸ਼ਟ ਦਸਤਾਵੇਜ਼ਬੰਦੀ ਕਰੋ

## ਆਮ ਟੈਸਟਿੰਗ ਸਮੱਸਿਆਵਾਂ

- **ਕੇਵਲ ਖੁਸ਼੍ਹ ਰਾਹ ਟੈਸਟਿੰਗ 'ਤੇ ਜ਼ਿਆਦਾ ਨਿਰਭਰਤਾ**: ਯਕੀਨੀ ਬਣਾਓ ਕਿ ਏਰਰ ਕੇਸ ਸਚਮੁਚ ਚੰਗੀ ਤਰ੍ਹਾਂ ਟੈਸਟ ਕੀਤੇ ਜਾਣ
- **ਪ੍ਰਦਰਸ਼ਨ ਟੈਸਟਿੰਗ ਨੂੰ ਅਣਡਿੱਠਾ ਕਰਨਾ**: ਉਤਪਾਦਨ 'ਤੇ ਪ੍ਰਭਾਵ ਪੈਣ ਤੋਂ ਪਹਿਲਾਂ ਬੋਟਲਨੇਕਸ ਦੀ ਪਛਾਣ ਕਰੋ
- **ਕੇਵਲ ਪ੍ਰਤੀਕੂਲ ਟੈਸਟਿੰਗ ਕਰਨਾ**: ਯੂਨਿਟ, ਇੰਟੀਗ੍ਰੇਸ਼ਨ ਅਤੇ E2E ਟੈਸਟਸ ਨੂੰ ਮਿਲਾ ਕੇ ਚਲਾਓ
- **ਅਧੂਰੀ API ਕਵਰੇਜ**: ਯਕੀਨੀ ਬਣਾਓ ਕਿ ਸਾਰੇ ਐਂਡਪੋਇੰਟ ਅਤੇ ਫੀਚਰ ਟੈਸਟ ਕੀਤੇ ਗਏ ਹਨ
- **ਟੈਸਟ ਪਰਿਵੇਸ਼ਾਂ ਵਿੱਚ ਅਸਥਿਰਤਾ**: ਸਥਿਰ ਟੈਸਟ ਪਰਿਵੇਸ਼ ਸੰਭਾਲਣ ਲਈ ਕੰਟੇਨਰ ਵਰਤੋਂ

## ਨਤੀਜਾ

ਇੱਕ ਵਿਸਤૃત ਟੈਸਟਿੰਗ ਰਣਨੀਤੀ ਭਰੋਸੇਮੰਦ, ਉੱਚ-ਗੁਣਵੱਤਾ MCP ਸਰਵਰਾਂ ਦੇ ਵਿਕਾਸ ਲਈ ਲਾਜ਼ਮੀ ਹੈ। ਇਸ ਮਾਰਗਦਰਸ਼ਕ ਵਿੱਚ ਦਿੱਤੀਆਂ ਬਿਹਤਰ ਅਭਿਆਸਾਂ ਅਤੇ ਟਿਪ੍ਹਾਂ ਨੂੰ ਲਾਗੂ ਕਰਕੇ, ਤੁਸੀਂ ਆਪਣੇ MCP ਲਾਗੂ ਕਰਨ ਨੂੰ ਸਭ ਤੋਂ ਵੱਧ ਗੁਣਵੱਤਾ, ਭਰੋਸੇਮੰਦ ਅਤੇ ਪ੍ਰਦਰਸ਼ਨ ਮਿਆਰਾਂ ਉੱਤਰਨ ਵਾਲਾ ਬਣਾ ਸਕਦੇ ਹੋ।

## ਮੁੱਖ ਸਿੱਖਣ ਵਾਲੀਆਂ ਗੱਲਾਂ

1. **ਟੂਲ ਡਿਜ਼ਾਇਨ**: ਇਕੱਲਾ ਜ਼ਿੰਮੇਵਾਰੀ ਸਿਧਾਂਤ ਨੂੰ ਫੋਲੋ ਕਰੋ, ਡਿਪੈਂਡੇੰਸੀ ਇੰਜੈਕਸ਼ਨ ਦੀ ਵਰਤੋਂ ਕਰੋ, ਅਤੇ ਆਪਸੀ ਮਿਲਾਪ ਲਈ ਡਿਜ਼ਾਇਨ ਕਰੋ
2. **ਸਕੀਮਾ ਡਿਜ਼ਾਇਨ**: ਸਾਫ਼, ਵਧੀਆ ਦਸਤਾਵੇਜ਼ਬੱਧ ਸਕੀਮਾਂ ਬਣਾਓ ਜਿਨ੍ਹਾਂ ਵਿੱਚ ਢੰਗ ਦੀ ਜਾਂਚ ਸ਼ਾਮਲ ਹੋਵੇ
3. **ਏਰਰ ਹੈਂਡਲਿੰਗ**: ਨਰਮ ਏਰਰ ਸੰਭਾਲ, ਸੰਰਚਿਤ ਏਰਰ ਜਵਾਬ ਅਤੇ ਦੁਬਾਰਾ ਕੋਸ਼ਿਸ਼ ਲਾਜਿਕ ਲਾਗੂ ਕਰੋ
4. **ਪ੍ਰਦਰਸ਼ਨ**: ਕੈਸ਼ਿੰਗ, ਅਸੰਕੇਤਕ ਪ੍ਰੋਸੈਸਿੰਗ ਅਤੇ ਸਰੋਤ ਸੀਮਿਤੀਕਰਨ ਦੀ ਵਰਤੋਂ ਕਰੋ
5. **ਸੁਰੱਖਿਆ**: ਠੀਕ ਇਨਪੁੱਟ ਪਰਖ, ਅਧਿਕਾਰ ਚੈੱਕ ਅਤੇ ਸੰਵੇਦਨਸ਼ੀਲ ਡੇਟਾ ਸੰਭਾਲ ਲਾਗੂ ਕਰੋ
6. **ਟੈਸਟਿੰਗ**: ਵਿਸਤ੍ਰਿਤ ਯੂਨਿਟ, ਇੰਟੀਗ੍ਰੇਸ਼ਨ ਅਤੇ ਐਂਡ-ਟੂ-ਐਂਡ ਟੈਸਟ ਬਣਾਓ
7. **ਵਰਕਫਲੋ ਪੈਟਰਨ**: ਸਥਾਪਤ ਪੈਟਰਨ ਜਿਵੇਂ ਕਿ ଚੇਨਜ਼, ਡਿਸਪੈਚਰਜ਼, ਅਤੇ ਸਮਤਲ ਪ੍ਰੋਸੈਸਿੰਗ ਲਾਗੂ ਕਰੋ

## ਅਭਿਆਸ

ਇੱਕ ਦਸਤਾਵੇਜ਼ ਪ੍ਰੋਸੈਸਿੰਗ ਸਿਸਟਮ ਲਈ MCP ਟੂਲ ਅਤੇ ਵਰਕਫਲੋ ਡਿਜ਼ਾਇਨ ਕਰੋ ਜੋ:

1. ਵੱਖ-ਵੱਖ ਫਾਰਮੈਟਾਂ (PDF, DOCX, TXT) ਵਿੱਚ ਦਸਤਾਵੇਜ਼ਾਂ ਨੂੰ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ
2. ਦਸਤਾਵੇਜ਼ਾਂ ਵਿੱਚੋਂ ਟੈਕਸਟ ਅਤੇ ਮੁੱਖ ਜਾਣਕਾਰੀ ਕੱਢਦਾ ਹੈ
3. ਦਸਤਾਵੇਜ਼ਾਂ ਨੂੰ ਕਿਸਮ ਅਤੇ ਸਮੱਗਰੀ ਅਨੁਸਾਰ ਵਰਗੀਕ੍ਰਿਤ ਕਰਦਾ ਹੈ
4. ਹਰ ਦਸਤਾਵੇਜ਼ ਦਾ ਸਾਰਾਂਸ਼ ਤਿਆਰ ਕਰਦਾ ਹੈ

ਉਸ ਸੰਦਰਭ ਲਈ ਸਭ ਤੋਂ ਢੁਕਵੀਂ ਟੂਲ ਸਕੀਮਾਂ, ਏਰਰ ਹੈਂਡਲਿੰਗ, ਅਤੇ ਵਰਕਫਲੋ ਪੈਟਰਨ ਲਾਗੂ ਕਰੋ। ਸੋਚੋ ਕਿ ਤੁਸੀਂ ਇਸ ਲਾਗੂ ਕਰਨ ਦੀ ਟੈਸਟਿੰਗ ਕਿਵੇਂ ਕਰੋਗੇ।

## ਸਰੋਤ

1. ਆਜ਼ੂਰੇ AI ਫਾਉਂਡਰੀ Discord ਕਮੇਉਨਿਟੀ 'ਤੇ MCP ਕਮੇਉਨਿਟੀ ਵਿੱਚ ਸ਼ਾਮਲ ਹੋਵੋ [Azure AI Foundry Discord Community](https://aka.ms/foundrydevs) ਤਾ ਕਿ ਤਾਜ਼ਾ ਵਿਕਾਸਾਂ ਨਾਲ ਅੱਪਡੇਟ ਰਹੋ
2. ਖੁੱਲ੍ਹਾ ਸਰੋਤ [MCP ਪ੍ਰੋਜੈਕਟਾਂ](https://github.com/modelcontextprotocol) ਵਿੱਚ ਯੋਗਦਾਨ ਪਾਓ
3. ਆਪਣੀ ਸੰਸਥਾ ਦੇ AI ਉਪਰਾਲਿਆਂ ਵਿੱਚ MCP ਸਿਧਾਂਤ ਲਾਗੂ ਕਰੋ
4. ਆਪਣੀ ਉਦਯੋਗ ਲਈ ਵਿਸ਼ੇਸ਼ MCP ਲਾਗੂ ਕਰਨ ਦੀ ਖੋਜ ਕਰੋ
5. ਖਾਸ MCP ਵਿਸ਼ਿਆਂ 'ਤੇ ਉੱਚ ਸਤਰ ਦੇ ਕੋर्स ਲੈਣ ਬਾਰੇ ਸੋਚੋ, ਜਿਵੇਂ ਕਿ ਬਹੁ-ਮੋਡਲ ਇੰਟੀਗ੍ਰੇਸ਼ਨ ਜਾਂ ਐਂਟਰਪ੍ਰਾਈਜ਼ ਐਪਲੀਕੇਸ਼ਨ ਇੰਟੀਗ੍ਰੇਸ਼ਨ
6. [Hands on Lab](../10-StreamliningAIWorkflowsBuildingAnMCPServerWithAIToolkit/README.md) ਦੇ ਜ਼ਰੀਏ ਸਿੱਖੇ ਗਏ ਸਿਧਾਂਤਾਂ ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਆਪਣੇ MCP ਟੂਲ ਅਤੇ ਵਰਕਫਲੋ ਬਣਾਉਣ ਦਾ ਅਭਿਆਸ ਕਰੋ

## ਅਗਲਾ ਕਦਮ

ਅਗਲਾ: [ਕੇਸ ਅਧਿਐਨ](../09-CaseStudy/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**ਅਸਵੀਕਾਰੋਤਾ**:
ਇਸ ਦਸਤਾਵੇਜ਼ ਨੂੰ AI ਅਨੁਵਾਦ ਸੇਵਾ [Co-op Translator](https://github.com/Azure/co-op-translator) ਦੀ ਵਰਤੋਂ ਕਰਕੇ ਅਨੁਵਾਦ ਕੀਤਾ ਗਿਆ ਹੈ। ਜਦੋਂ ਕਿ ਅਸੀਂ ਸਹੀਤਾ ਲਈ ਕੋਸ਼ਿਸ਼ ਕਰਦੇ ਹਾਂ, ਕਿਰਪਾ ਕਰਕੇ ਧਿਆਨ ਦਿਓ ਕਿ ਸਵੈਚਾਲਿਤ ਅਨੁਵਾਦ ਵਿੱਚ ਗਲਤੀਆਂ ਜਾਂ ਅਸਹੀਤਾਂ ਹੋ ਸਕਦੀਆਂ ਹਨ। ਮੂਲ ਦਸਤਾਵੇਜ਼ ਆਪਣੀ ਮੂਲ ਭਾਸ਼ਾ ਵਿੱਚ ਅਧਿਕਾਰਤ ਸਰੋਤ ਮੰਨਿਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ। ਜਰੂਰੀ ਜਾਣਕਾਰੀ ਲਈ, ਪੇਸ਼ੇਵਰ ਮਨੁੱਖੀ ਅਨੁਵਾਦ ਦੀ ਸਿਫਾਰਸ਼ ਕੀਤੀ ਜਾਂਦੀ ਹੈ। ਅਸੀਂ ਇਸ ਅਨੁਵਾਦ ਦੀ ਵਰਤੋਂ ਤੋਂ ਪੈਦਾ ਹੋਈਆਂ ਕਿਸੇ ਵੀ ਗਲਤਫਹਿਮੀਆਂ ਜਾਂ ਭ੍ਰਮਾਂ ਲਈ ਜ਼ਿੰਮੇਵਾਰ ਨਹੀਂ ਹਾਂ।
<!-- CO-OP TRANSLATOR DISCLAIMER END -->