# HTTPS സ്റ്റ്രീമിംഗ് മോഡൽ കോൺടെക്സ്റ്റ് പ്രോട്ടോക്കോൾ (MCP) ഉപയോഗിച്ച്

ഈ അധ്യായം HTTPS ഉപയോഗിച്ച് മോഡൽ കോൺടെക്സ്റ്റ് പ്രോട്ടോക്കോൾ (MCP) ഉപയോഗിച്ച് സുരക്ഷിതവും സ്കെയിലബിളുമായ റിയൽ-ടൈം സ്റ്റ്രീമിംഗ് നടപ്പിലാക്കുന്നതിനുള്ള സമഗ്രമായ മാർഗ്ഗനിർദ്ദേശം നൽകുന്നു. സ്റ്റ്രീമിംഗിന്റെ പ്രേരണ, ലഭ്യമായ ട്രാൻസ്പോർട്ട് മെക്കാനിസങ്ങൾ, MCP-യിൽ സ്റ്റ്രീമബിൾ HTTP എങ്ങനെ നടപ്പിലാക്കാം, സുരക്ഷാ മികച്ച പ്രാക്ടീസുകൾ, SSE-യിൽ നിന്നുള്ള മൈഗ്രേഷൻ, നിങ്ങളുടെ സ്വന്തം സ്റ്റ്രീമിംഗ് MCP ആപ്ലിക്കേഷനുകൾ നിർമ്മിക്കുന്നതിനുള്ള പ്രായോഗിക മാർഗ്ഗനിർദ്ദേശങ്ങൾ എന്നിവ ഇതിൽ ഉൾക്കൊള്ളുന്നു.

## MCP-യിലെ ട്രാൻസ്പോർട്ട് മെക്കാനിസങ്ങളും സ്റ്റ്രീമിംഗും

ഈ വിഭാഗം MCP-യിൽ ലഭ്യമായ വ്യത്യസ്ത ട്രാൻസ്പോർട്ട് മെക്കാനിസങ്ങൾ പരിശോധിക്കുകയും ക്ലയന്റുകളും സർവറുകളും തമ്മിലുള്ള റിയൽ-ടൈം കമ്മ്യൂണിക്കേഷനിൽ സ്റ്റ്രീമിംഗ് കഴിവുകൾ സജ്ജമാക്കുന്നതിലെ അവയുടെ പങ്ക് വിശദീകരിക്കുകയും ചെയ്യുന്നു.

### ട്രാൻസ്പോർട്ട് മെക്കാനിസം എന്താണ്?

ട്രാൻസ്പോർട്ട് മെക്കാനിസം ക്ലയന്റും സർവറും തമ്മിൽ ഡാറ്റ എങ്ങനെ കൈമാറപ്പെടുന്നു എന്ന് നിർവചിക്കുന്നു. MCP വ്യത്യസ്ത പരിസ്ഥിതികൾക്കും ആവശ്യങ്ങൾക്കും അനുയോജ്യമായ നിരവധി ട്രാൻസ്പോർട്ട് തരം പിന്തുണയ്ക്കുന്നു:

- **stdio**: സ്റ്റാൻഡേർഡ് ഇൻപുട്ട്/ഔട്ട്പുട്ട്, ലോക്കൽ CLI അടിസ്ഥാനമാക്കിയ ടൂളുകൾക്ക് അനുയോജ്യം. ലളിതമാണ്, പക്ഷേ വെബ് അല്ലെങ്കിൽ ക്ലൗഡിന് അനുയോജ്യമല്ല.
- **SSE (സർവർ-സെന്റ് ഇവന്റുകൾ)**: HTTP വഴി ക്ലയന്റുകൾക്ക് റിയൽ-ടൈം അപ്‌ഡേറ്റുകൾ പുഷ് ചെയ്യാൻ സർവറുകൾക്ക് അനുവദിക്കുന്നു. വെബ് UI-കൾക്ക് നല്ലത്, പക്ഷേ സ്കെയിലബിലിറ്റിയിലും ഫ്ലെക്സിബിലിറ്റിയിലും പരിമിതമാണ്.
- **Streamable HTTP**: നോട്ടിഫിക്കേഷനുകളും മെച്ചപ്പെട്ട സ്കെയിലബിലിറ്റിയും പിന്തുണയ്ക്കുന്ന ആധുനിക HTTP അടിസ്ഥാനത്തിലുള്ള സ്റ്റ്രീമിംഗ് ട്രാൻസ്പോർട്ട്. മിക്ക പ്രൊഡക്ഷൻ, ക്ലൗഡ് സാഹചര്യങ്ങൾക്കായി ശുപാർശ ചെയ്യുന്നു.

### താരതമ്യ പട്ടിക

ഈ ട്രാൻസ്പോർട്ട് മെക്കാനിസങ്ങൾ തമ്മിലുള്ള വ്യത്യാസങ്ങൾ മനസ്സിലാക്കാൻ താഴെ കാണുന്ന താരതമ്യ പട്ടിക നോക്കുക:

| Transport         | റിയൽ-ടൈം അപ്‌ഡേറ്റുകൾ | സ്റ്റ്രീമിംഗ് | സ്കെയിലബിലിറ്റി | ഉപയോഗ കേസ്                |
|-------------------|------------------|-----------|-------------|-------------------------|
| stdio             | ഇല്ല               | ഇല്ല        | കുറവ്         | ലോക്കൽ CLI ടൂളുകൾ         |
| SSE               | ഉണ്ട്              | ഉണ്ട്       | മധ്യം      | വെബ്, റിയൽ-ടൈം അപ്‌ഡേറ്റുകൾ  |
| Streamable HTTP   | ഉണ്ട്              | ഉണ്ട്       | ഉയർന്ന        | ക്ലൗഡ്, മൾട്ടി-ക്ലയന്റ്     |

> **ടിപ്പ്:** ശരിയായ ട്രാൻസ്പോർട്ട് തിരഞ്ഞെടുക്കുന്നത് പ്രകടനത്തിലും സ്കെയിലബിലിറ്റിയിലും ഉപയോക്തൃ അനുഭവത്തിലും സ്വാധീനം ചെലുത്തുന്നു. ആധുനികവും സ്കെയിലബിളുമായ ക്ലൗഡ്-സജ്ജമായ ആപ്ലിക്കേഷനുകൾക്കായി **Streamable HTTP** ശുപാർശ ചെയ്യുന്നു.

മുൻ അധ്യായങ്ങളിൽ നിങ്ങൾക്ക് കാണിച്ച stdio, SSE ട്രാൻസ്പോർട്ടുകളും ഈ അധ്യായത്തിൽ ഉൾപ്പെടുത്തിയ Streamable HTTP ട്രാൻസ്പോർട്ടും ശ്രദ്ധിക്കുക.

## സ്റ്റ്രീമിംഗ്: ആശയങ്ങളും പ്രേരണയും

സ്റ്റ്രീമിംഗിന്റെ അടിസ്ഥാന ആശയങ്ങളും പ്രേരണകളും മനസ്സിലാക്കുന്നത് ഫലപ്രദമായ റിയൽ-ടൈം കമ്മ്യൂണിക്കേഷൻ സിസ്റ്റങ്ങൾ നടപ്പിലാക്കുന്നതിനായി അനിവാര്യമാണ്.

**സ്റ്റ്രീമിംഗ്** എന്നത് നെറ്റ്‌വർക്ക് പ്രോഗ്രാമിംഗിലെ ഒരു സാങ്കേതിക വിദ്യയാണ്, ഇത് ഒരു മുഴുവൻ പ്രതികരണം തയ്യാറാകാൻ കാത്തിരിക്കാതെ ചെറിയ, കൈകാര്യം ചെയ്യാവുന്ന ഭാഗങ്ങളായി അല്ലെങ്കിൽ ഇവന്റുകളുടെ ശ്രേണിയായി ഡാറ്റ അയയ്ക്കാനും സ്വീകരിക്കാനും അനുവദിക്കുന്നു. ഇത് പ്രത്യേകിച്ച് ഉപകാരപ്രദമാണ്:

- വലിയ ഫയലുകൾ അല്ലെങ്കിൽ ഡാറ്റാസെറ്റുകൾ.
- റിയൽ-ടൈം അപ്‌ഡേറ്റുകൾ (ഉദാ: ചാറ്റ്, പ്രോഗ്രസ് ബാറുകൾ).
- ഉപയോക്താവിനെ അറിയിച്ചുകൊണ്ടിരിക്കേണ്ട ദീർഘകാല കംപ്യൂട്ടേഷനുകൾ.

സ്റ്റ്രീമിംഗിനെക്കുറിച്ച് ഉയർന്ന തലത്തിൽ നിങ്ങൾ അറിയേണ്ടത്:

- ഡാറ്റ ക്രമാനുസൃതമായി വിതരണം ചെയ്യപ്പെടുന്നു, എല്ലാം ഒരുമിച്ച് അല്ല.
- ഡാറ്റ എത്തുമ്പോൾ ക്ലയന്റ് അത് പ്രോസസ് ചെയ്യാം.
- അനുഭവിച്ചിരിക്കുന്ന ലേറ്റൻസി കുറയ്ക്കുകയും ഉപയോക്തൃ അനുഭവം മെച്ചപ്പെടുത്തുകയും ചെയ്യുന്നു.

### സ്റ്റ്രീമിംഗ് ഉപയോഗിക്കേണ്ടത് എന്തുകൊണ്ട്?

സ്റ്റ്രീമിംഗ് ഉപയോഗിക്കുന്നതിന് കാരണം താഴെപ്പറയുന്നവയാണ്:

- ഉപയോക്താക്കൾക്ക് ഉടൻ ഫീഡ്‌ബാക്ക് ലഭിക്കുന്നു, അവസാനത്തിൽ മാത്രമല്ല
- റിയൽ-ടൈം ആപ്ലിക്കേഷനുകളും പ്രതികരണശീലമുള്ള UI-കളും സജ്ജമാക്കുന്നു
- നെറ്റ്‌വർക്ക്, കംപ്യൂട്ട് വിഭവങ്ങളുടെ കൂടുതൽ കാര്യക്ഷമമായ ഉപയോഗം

### ലളിതമായ ഉദാഹരണം: HTTP സ്റ്റ്രീമിംഗ് സർവർ & ക്ലയന്റ്

സ്റ്റ്രീമിംഗ് എങ്ങനെ നടപ്പിലാക്കാമെന്ന് ലളിതമായ ഒരു ഉദാഹരണം:

#### Python

**സർവർ (Python, FastAPI, StreamingResponse ഉപയോഗിച്ച്):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**ക്ലയന്റ് (Python, requests ഉപയോഗിച്ച്):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

ഈ ഉദാഹരണം, എല്ലാ സന്ദേശങ്ങളും ഒരുമിച്ച് തയ്യാറാകാൻ കാത്തിരിക്കാതെ, ലഭ്യമായപ്പോൾ തന്നെ ക്ലയന്റിലേക്ക് ഒരു പരമ്പരയായി സന്ദേശങ്ങൾ അയക്കുന്ന ഒരു സർവർ കാണിക്കുന്നു.

**എങ്ങനെ പ്രവർത്തിക്കുന്നു:**

- സർവർ ഓരോ സന്ദേശവും തയ്യാറാകുമ്പോൾ അത് നൽകുന്നു.
- ക്ലയന്റ് ഓരോ ഭാഗവും ലഭിക്കുമ്പോൾ അത് സ്വീകരിച്ച് പ്രിന്റ് ചെയ്യുന്നു.

**ആവശ്യകതകൾ:**

- സർവർ സ്റ്റ്രീമിംഗ് പ്രതികരണം ഉപയോഗിക്കണം (ഉദാ: FastAPI-യിലെ `StreamingResponse`).
- ക്ലയന്റ് പ്രതികരണം സ്റ്റ്രീമായി പ്രോസസ് ചെയ്യണം (`stream=True` requests-ൽ).
- Content-Type സാധാരണയായി `text/event-stream` അല്ലെങ്കിൽ `application/octet-stream` ആണ്.

#### Java

**സർവർ (Java, Spring Boot, Server-Sent Events ഉപയോഗിച്ച്):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**ക്ലയന്റ് (Java, Spring WebFlux WebClient ഉപയോഗിച്ച്):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java നടപ്പാക്കൽ കുറിപ്പുകൾ:**

- `Flux` ഉപയോഗിച്ച് Spring Boot-ന്റെ റിയാക്ടീവ് സ്റ്റാക്ക് ഉപയോഗിക്കുന്നു
- `ServerSentEvent` ഇവന്റ് തരം ഉൾപ്പെടുന്ന ഘടനാപരമായ ഇവന്റ് സ്റ്റ്രീമിംഗ് നൽകുന്നു
- `WebClient`-ന്റെ `bodyToFlux()` റിയാക്ടീവ് സ്റ്റ്രീമിംഗ് ഉപഭോഗം സജ്ജമാക്കുന്നു
- `delayElements()` ഇവന്റുകൾക്കിടയിലെ പ്രോസസ്സിംഗ് സമയം അനുകരിക്കുന്നു
- ഇവന്റുകൾക്ക് ക്ലയന്റ് കൈകാര്യം മെച്ചപ്പെടുത്താൻ തരം (`info`, `result`) നൽകാം

### താരതമ്യം: ക്ലാസിക് സ്റ്റ്രീമിംഗ് vs MCP സ്റ്റ്രീമിംഗ്

സ്റ്റ്രീമിംഗ് "ക്ലാസിക്" രീതിയിൽ എങ്ങനെ പ്രവർത്തിക്കുന്നു എന്നതും MCP-യിൽ എങ്ങനെ പ്രവർത്തിക്കുന്നു എന്നതും താഴെപ്പറയുന്നപോലെ കാണാം:

| സവിശേഷത                | ക്ലാസിക് HTTP സ്റ്റ്രീമിംഗ്         | MCP സ്റ്റ്രീമിംഗ് (നോട്ടിഫിക്കേഷനുകൾ)      |
|------------------------|-------------------------------|-------------------------------------|
| പ്രധാന പ്രതികരണം          | ചങ്കുകളായി                      | ഒറ്റത്തവണ, അവസാനം                      |
| പ്രോഗ്രസ് അപ്‌ഡേറ്റുകൾ       | ഡാറ്റ ചങ്കുകളായി അയയ്ക്കുന്നു           | നോട്ടിഫിക്കേഷനുകളായി അയയ്ക്കുന്നു               |
| ക്ലയന്റ് ആവശ്യകതകൾ        | സ്റ്റ്രീം പ്രോസസ് ചെയ്യണം           | സന്ദേശ ഹാൻഡ്ലർ നടപ്പിലാക്കണം      |
| ഉപയോഗ കേസ്               | വലിയ ഫയലുകൾ, AI ടോക്കൺ സ്റ്റ്രീമുകൾ | പ്രോഗ്രസ്, ലോഗുകൾ, റിയൽ-ടൈം ഫീഡ്‌ബാക്ക്  |

### പ്രധാന വ്യത്യാസങ്ങൾ

കൂടാതെ, ചില പ്രധാന വ്യത്യാസങ്ങൾ:

- **കമ്മ്യൂണിക്കേഷൻ പാറ്റേൺ:**
  - ക്ലാസിക് HTTP സ്റ്റ്രീമിംഗ്: ഡാറ്റ ചങ്കുകളായി അയയ്ക്കാൻ ലളിതമായ ചങ്ക് ട്രാൻസ്ഫർ എൻകോഡിംഗ് ഉപയോഗിക്കുന്നു
  - MCP സ്റ്റ്രീമിംഗ്: JSON-RPC പ്രോട്ടോക്കോൾ ഉപയോഗിച്ച് ഘടനാപരമായ നോട്ടിഫിക്കേഷൻ സിസ്റ്റം ഉപയോഗിക്കുന്നു

- **സന്ദേശ ഫോർമാറ്റ്:**
  - ക്ലാസിക് HTTP: പുതിയ വരികളോടുകൂടിയ പ്ലെയിൻ ടെക്സ്റ്റ് ചങ്കുകൾ
  - MCP: മെറ്റാഡേറ്റയോടുകൂടിയ ഘടനാപരമായ LoggingMessageNotification ഒബ്ജക്റ്റുകൾ

- **ക്ലയന്റ് നടപ്പാക്കൽ:**
  - ക്ലാസിക് HTTP: സ്റ്റ്രീമിംഗ് പ്രതികരണങ്ങൾ പ്രോസസ് ചെയ്യുന്ന ലളിതമായ ക്ലയന്റ്
  - MCP: വ്യത്യസ്ത തരത്തിലുള്ള സന്ദേശങ്ങൾ പ്രോസസ് ചെയ്യാൻ സന്ദേശ ഹാൻഡ്ലർ ഉള്ള കൂടുതൽ സങ്കീർണ്ണമായ ക്ലയന്റ്

- **പ്രോഗ്രസ് അപ്‌ഡേറ്റുകൾ:**
  - ക്ലാസിക് HTTP: പ്രോഗ്രസ് പ്രധാന പ്രതികരണ സ്റ്റ്രീമിന്റെ ഭാഗമാണ്
  - MCP: പ്രധാന പ്രതികരണം അവസാനം വരുമ്പോൾ പ്രോഗ്രസ് വേർതിരിച്ച നോട്ടിഫിക്കേഷൻ സന്ദേശങ്ങളായി അയയ്ക്കുന്നു

### ശുപാർശകൾ

ക്ലാസിക് സ്റ്റ്രീമിംഗ് (മുൻപ് `/stream` ഉപയോഗിച്ച് കാണിച്ച എന്റ്പോയിന്റ്) നടപ്പിലാക്കുന്നതും MCP വഴി സ്റ്റ്രീമിംഗ് തിരഞ്ഞെടുക്കുന്നതും തമ്മിൽ തിരഞ്ഞെടുക്കുമ്പോൾ ചില ശുപാർശകൾ:

- **ലളിതമായ സ്റ്റ്രീമിംഗ് ആവശ്യങ്ങൾക്കായി:** ക്ലാസിക് HTTP സ്റ്റ്രീമിംഗ് ലളിതമായി നടപ്പിലാക്കാൻ കഴിയും, അടിസ്ഥാന സ്റ്റ്രീമിംഗ് ആവശ്യങ്ങൾക്കായി മതിയാകും.

- **സങ്കീർണ്ണവും ഇന്ററാക്ടീവ് ആപ്ലിക്കേഷനുകൾക്കായി:** MCP സ്റ്റ്രീമിംഗ് കൂടുതൽ ഘടനാപരമായ സമീപനം നൽകുന്നു, സമ്പന്നമായ മെറ്റാഡേറ്റയും നോട്ടിഫിക്കേഷനുകളും അന്തിമ ഫലങ്ങളും വേർതിരിക്കുന്നു.

- **AI ആപ്ലിക്കേഷനുകൾക്കായി:** MCP-യുടെ നോട്ടിഫിക്കേഷൻ സിസ്റ്റം ദീർഘകാല AI ടാസ്കുകൾക്കായി ഉപയോക്താക്കളെ പ്രോഗ്രസ് അറിയിപ്പുകൾ നൽകാൻ പ്രത്യേകമായി ഉപയോഗപ്രദമാണ്.

## MCP-യിൽ സ്റ്റ്രീമിംഗ്

ക്ലാസിക് സ്റ്റ്രീമിംഗും MCP സ്റ്റ്രീമിംഗും തമ്മിലുള്ള വ്യത്യാസങ്ങൾക്കുറിച്ച് നിങ്ങൾക്ക് ശുപാർശകളും താരതമ്യങ്ങളും കാണിച്ചു. ഇപ്പോൾ MCP-യിൽ സ്റ്റ്രീമിംഗ് എങ്ങനെ ഉപയോഗിക്കാമെന്ന് വിശദമായി നോക്കാം.

MCP ഫ്രെയിംവർക്കിനുള്ളിൽ സ്റ്റ്രീമിംഗ് എങ്ങനെ പ്രവർത്തിക്കുന്നു എന്ന് മനസ്സിലാക്കുന്നത് ദീർഘകാല പ്രവർത്തനങ്ങൾക്കിടെ ഉപയോക്താക്കൾക്ക് റിയൽ-ടൈം ഫീഡ്‌ബാക്ക് നൽകുന്ന പ്രതികരണശീലമുള്ള ആപ്ലിക്കേഷനുകൾ നിർമ്മിക്കാൻ അനിവാര്യമാണ്.

MCP-യിൽ, പ്രധാന പ്രതികരണം ചങ്കുകളായി അയയ്ക്കുന്നത് അല്ല, മറിച്ച് ഒരു ടൂൾ ഒരു അഭ്യർത്ഥന പ്രോസസ് ചെയ്യുമ്പോൾ ക്ലയന്റിലേക്ക് **നോട്ടിഫിക്കേഷനുകൾ** അയയ്ക്കുന്നതാണ്. ഈ നോട്ടിഫിക്കേഷനുകളിൽ പ്രോഗ്രസ് അപ്‌ഡേറ്റുകൾ, ലോഗുകൾ, അല്ലെങ്കിൽ മറ്റ് ഇവന്റുകൾ ഉൾപ്പെടാം.

### എങ്ങനെ പ്രവർത്തിക്കുന്നു

പ്രധാന ഫലം ഒറ്റത്തവണ പ്രതികരണമായി അയയ്ക്കപ്പെടുന്നു. എന്നാൽ, പ്രോസസ്സിംഗ് സമയത്ത് നോട്ടിഫിക്കേഷനുകൾ വേർതിരിച്ച സന്ദേശങ്ങളായി അയയ്ക്കാം, അതിലൂടെ ക്ലയന്റ് റിയൽ-ടൈമിൽ അപ്‌ഡേറ്റ് ചെയ്യപ്പെടുന്നു. ക്ലയന്റ് ഈ നോട്ടിഫിക്കേഷനുകൾ കൈകാര്യം ചെയ്ത് പ്രദർശിപ്പിക്കാൻ കഴിയണം.

## നോട്ടിഫിക്കേഷൻ എന്താണ്?

"നോട്ടിഫിക്കേഷൻ" എന്ന് പറഞ്ഞപ്പോൾ MCP-യുടെ സാന്ദർഭ്യത്തിൽ അതിന്റെ അർത്ഥം എന്താണ്?

നോട്ടിഫിക്കേഷൻ എന്നത് ദീർഘകാല പ്രവർത്തനത്തിനിടെ പുരോഗതി, നില, അല്ലെങ്കിൽ മറ്റ് ഇവന്റുകൾ സംബന്ധിച്ച് ക്ലയന്റിനെ അറിയിക്കാൻ സർവറിൽ നിന്നുള്ള സന്ദേശമാണ്. നോട്ടിഫിക്കേഷനുകൾ പരദർശിത്വവും ഉപയോക്തൃ അനുഭവവും മെച്ചപ്പെടുത്തുന്നു.

ഉദാഹരണത്തിന്, ക്ലയന്റ് ഒരു നോട്ടിഫിക്കേഷൻ അയയ്ക്കണം സർവറുമായി പ്രാഥമിക ഹാൻഡ്‌ഷേക്ക് പൂർത്തിയായപ്പോൾ.

ഒരു നോട്ടിഫിക്കേഷൻ JSON സന്ദേശമായി ഇങ്ങനെ കാണപ്പെടും:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

നോട്ടിഫിക്കേഷനുകൾ MCP-യിൽ ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) എന്ന വിഷയത്തിന് (topic) അനുബന്ധമാണ്.

ലോഗിംഗ് പ്രവർത്തിപ്പിക്കാൻ, സർവർ അതിനെ ഫീച്ചർ/ക്യാപബിലിറ്റി ആയി ഇങ്ങനെ സജ്ജമാക്കണം:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> ഉപയോഗിക്കുന്ന SDK അനുസരിച്ച്, ലോഗിംഗ് ഡിഫോൾട്ടായി പ്രവർത്തനക്ഷമമായിരിക്കാം, അല്ലെങ്കിൽ സർവർ കോൺഫിഗറേഷനിൽ അത് വ്യക്തമായി പ്രവർത്തനക്ഷമമാക്കേണ്ടതുണ്ടാകാം.

വിവിധ തരത്തിലുള്ള നോട്ടിഫിക്കേഷനുകൾ ഉണ്ട്:

| നില       | വിവരണം                    | ഉദാഹരണ ഉപയോഗ കേസ്                |
|-----------|-------------------------------|---------------------------------|
| debug     | വിശദമായ ഡീബഗ്ഗിംഗ് വിവരങ്ങൾ | ഫംഗ്ഷൻ എൻട്രി/എക്സിറ്റ് പോയിന്റുകൾ      |
| info      | പൊതുവായ വിവരസന്ദേശങ്ങൾ | പ്രവർത്തന പുരോഗതി അപ്‌ഡേറ്റുകൾ      |
| notice    | സാധാരണ പക്ഷേ പ്രധാനപ്പെട്ട ഇവന്റുകൾ  | കോൺഫിഗറേഷൻ മാറ്റങ്ങൾ           |
| warning   | മുന്നറിയിപ്പ് നിലകൾ             | പഴയ ഫീച്ചർ ഉപയോഗം        |
| error     | പിശക് നിലകൾ               | പ്രവർത്തന പരാജയങ്ങൾ              |
| critical  | ഗുരുതര നിലകൾ            | സിസ്റ്റം ഘടക പരാജയങ്ങൾ       |
| alert     | ഉടൻ നടപടി സ്വീകരിക്കണം | ഡാറ്റ കേടുപാടുകൾ കണ്ടെത്തി      |
| emergency | സിസ്റ്റം ഉപയോഗിക്കാനാകാത്തത്             | പൂർണ്ണ സിസ്റ്റം പരാജയം         |

## MCP-യിൽ നോട്ടിഫിക്കേഷനുകൾ നടപ്പിലാക്കൽ

MCP-യിൽ നോട്ടിഫിക്കേഷനുകൾ നടപ്പിലാക്കാൻ, റിയൽ-ടൈം അപ്‌ഡേറ്റുകൾ കൈകാര്യം ചെയ്യാൻ സർവർ, ക്ലയന്റ് ഇരുവരും സജ്ജമാക്കേണ്ടതാണ്. ഇത് ദീർഘകാല പ്രവർത്തനങ്ങൾക്കിടെ ഉപയോക്താക്കൾക്ക് ഉടൻ ഫീഡ്‌ബാക്ക് നൽകാൻ സഹായിക്കുന്നു.

### സർവർ-പാർശ്വം: നോട്ടിഫിക്കേഷനുകൾ അയയ്ക്കൽ

സർവർ ഭാഗം മുതൽ തുടങ്ങാം. MCP-യിൽ, അഭ്യർത്ഥനകൾ പ്രോസസ് ചെയ്യുമ്പോൾ നോട്ടിഫിക്കേഷനുകൾ അയയ്ക്കാൻ കഴിയുന്ന ടൂളുകൾ നിങ്ങൾ നിർവചിക്കുന്നു. സർവർ സാധാരണയായി `ctx` എന്ന കോൺടെക്സ്റ്റ് ഒബ്ജക്റ്റ് ഉപയോഗിച്ച് ക്ലയന്റിലേക്ക് സന്ദേശങ്ങൾ അയയ്ക്കുന്നു.

#### Python

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

മുൻ ഉദാഹരണത്തിൽ, `process_files` ടൂൾ ഓരോ ഫയലും പ്രോസസ് ചെയ്യുമ്പോൾ ക്ലയന്റിലേക്ക് മൂന്ന് നോട്ടിഫിക്കേഷനുകൾ അയയ്ക്കുന്നു. വിവരസന്ദേശങ്ങൾ അയയ്ക്കാൻ `ctx.info()` മെത്തഡ് ഉപയോഗിക്കുന്നു.

കൂടാതെ, നോട്ടിഫിക്കേഷനുകൾ പ്രവർത്തനക്ഷമമാക്കാൻ, സർവർ സ്റ്റ്രീമിംഗ് ട്രാൻസ്പോർട്ട് (ഉദാ: `streamable-http`) ഉപയോഗിക്കണം, ക്ലയന്റ് സന്ദേശ ഹാൻഡ്ലർ നടപ്പിലാക്കണം. `streamable-http` ട്രാൻസ്പോർട്ട് ഉപയോഗിച്ച് സർവർ സജ്ജമാക്കുന്നത് ഇങ്ങനെ:

```python
mcp.run(transport="streamable-http")
```

#### .NET

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

ഈ .NET ഉദാഹരണത്തിൽ, `ProcessFiles` ടൂൾ `Tool` അറ്റ്രിബ്യൂട്ട് ഉപയോഗിച്ച് അലങ്കരിച്ചിരിക്കുന്നു, ഓരോ ഫയലും പ്രോസസ് ചെയ്യുമ്പോൾ ക്ലയന്റിലേക്ക് മൂന്ന് നോട്ടിഫിക്കേഷനുകൾ അയയ്ക്കുന്നു. വിവരസന്ദേശങ്ങൾ അയയ്ക്കാൻ `ctx.Info()` മെത്തഡ് ഉപയോഗിക്കുന്നു.

നോട്ടിഫിക്കേഷനുകൾ പ്രവർത്തനക്ഷമമാക്കാൻ നിങ്ങളുടെ .NET MCP സർവർ സ്റ്റ്രീമിംഗ് ട്രാൻസ്പോർട്ട് ഉപയോഗിക്കുന്നുണ്ടെന്ന് ഉറപ്പാക്കുക:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

### ക്ലയന്റ്-പാർശ്വം: നോട്ടിഫിക്കേഷനുകൾ സ്വീകരിക്കൽ

ക്ലയന്റ് സന്ദേശ ഹാൻഡ്ലർ നടപ്പിലാക്കി നോട്ടിഫിക്കേഷനുകൾ എത്തുമ്പോൾ അവ പ്രോസസ് ചെയ്ത് പ്രദർശിപ്പിക്കണം.

#### Python

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

മുൻ കോഡിൽ, `message_handler` ഫംഗ്ഷൻ വരുന്ന സന്ദേശം നോട്ടിഫിക്കേഷൻ ആണോ എന്ന് പരിശോധിക്കുന്നു. ആണെങ്കിൽ, അത് പ്രിന്റ് ചെയ്യുന്നു; അല്ലെങ്കിൽ സാധാരണ സർവർ സന്ദേശമായി പ്രോസസ് ചെയ്യുന്നു. കൂടാതെ, `ClientSession` `message_handler` ഉപയോഗിച്ച് ഇൻഷിയലൈസ് ചെയ്യുന്നു, ഇത് വരുന്ന നോട്ടിഫിക്കേഷനുകൾ കൈകാര്യം ചെയ്യാൻ സഹായിക്കുന്നു.

#### .NET

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

ഈ .NET ഉദാഹരണത്തിൽ, `MessageHandler` ഫംഗ്ഷൻ വരുന്ന സന്ദേശം നോട്ടിഫിക്കേഷൻ ആണോ എന്ന് പരിശോധിക്കുന്നു. ആണെങ്കിൽ, അത് പ്ര
## SSE-യിൽ നിന്ന് Streamable HTTP-യിലേക്ക് അപ്ഗ്രേഡ് ചെയ്യൽ

ഇപ്പോൾ Server-Sent Events (SSE) ഉപയോഗിക്കുന്ന ആപ്ലിക്കേഷനുകൾക്ക്, Streamable HTTP-യിലേക്ക് മൈഗ്രേറ്റ് ചെയ്യുന്നത് നിങ്ങളുടെ MCP നടപ്പാക്കലുകൾക്ക് മെച്ചപ്പെട്ട കഴിവുകളും ദീർഘകാലം നിലനിൽക്കാനുള്ള ശേഷിയും നൽകുന്നു.

### എന്തുകൊണ്ട് അപ്ഗ്രേഡ് ചെയ്യണം?

SSE-യിൽ നിന്ന് Streamable HTTP-യിലേക്ക് അപ്ഗ്രേഡ് ചെയ്യാനുള്ള രണ്ട് പ്രധാന കാരണങ്ങൾ ഉണ്ട്:

- Streamable HTTP SSE-യെക്കാൾ മെച്ചപ്പെട്ട സ്കെയിലബിലിറ്റി, പൊരുത്തക്കേട്, സമ്പന്നമായ അറിയിപ്പുകൾ എന്നിവ നൽകുന്നു.
- പുതിയ MCP ആപ്ലിക്കേഷനുകൾക്കായി ഇത് ശുപാർശ ചെയ്ത ട്രാൻസ്പോർട്ടാണ്.

### മൈഗ്രേഷൻ ഘട്ടങ്ങൾ

നിങ്ങളുടെ MCP ആപ്ലിക്കേഷനുകളിൽ SSE-യിൽ നിന്ന് Streamable HTTP-യിലേക്ക് മൈഗ്രേറ്റ് ചെയ്യാനുള്ള വിധം:

- **സർവർ കോഡ് അപ്ഡേറ്റ് ചെയ്യുക** `mcp.run()`-ൽ `transport="streamable-http"` ഉപയോഗിച്ച്.
- **ക്ലയന്റ് കോഡ് അപ്ഡേറ്റ് ചെയ്യുക** SSE ക്ലയന്റിന്റെ പകരം `streamablehttp_client` ഉപയോഗിച്ച്.
- **ക്ലയന്റിൽ ഒരു മെസേജ് ഹാൻഡ്ലർ നടപ്പിലാക്കുക** അറിയിപ്പുകൾ പ്രോസസ്സ് ചെയ്യാൻ.
- **നിലവിലുള്ള ടൂളുകളും വർക്ക്‌ഫ്ലോകളും പൊരുത്തപ്പെടുന്നുണ്ടോ എന്ന് പരിശോധിക്കുക**.

### പൊരുത്തക്കേട് നിലനിർത്തൽ

മൈഗ്രേഷൻ പ്രക്രിയയിൽ നിലവിലുള്ള SSE ക്ലയന്റുകളുമായി പൊരുത്തപ്പെടുന്നത് ശുപാർശ ചെയ്യപ്പെടുന്നു. ചില തന്ത്രങ്ങൾ:

- വ്യത്യസ്ത എൻഡ്‌പോയിന്റുകളിൽ SSEയും Streamable HTTPയും രണ്ടും പ്രവർത്തിപ്പിച്ച് പിന്തുണ നൽകാം.
- ക്ലയന്റുകളെ ക്രമമായി പുതിയ ട്രാൻസ്പോർട്ടിലേക്ക് മാറ്റുക.

### വെല്ലുവിളികൾ

മൈഗ്രേഷൻ സമയത്ത് താഴെപ്പറയുന്ന വെല്ലുവിളികൾ പരിഹരിക്കേണ്ടതാണ്:

- എല്ലാ ക്ലയന്റുകളും അപ്ഡേറ്റ് ചെയ്യപ്പെട്ടിട്ടുണ്ടെന്ന് ഉറപ്പാക്കൽ
- അറിയിപ്പ് ഡെലിവറിയിൽ വ്യത്യാസങ്ങൾ കൈകാര്യം ചെയ്യൽ

## സുരക്ഷാ പരിഗണനകൾ

ഏതൊരു സർവറും നടപ്പിലാക്കുമ്പോഴും, പ്രത്യേകിച്ച് MCP-യിൽ Streamable HTTP പോലുള്ള HTTP അടിസ്ഥാനമാക്കിയ ട്രാൻസ്പോർട്ടുകൾ ഉപയോഗിക്കുമ്പോൾ, സുരക്ഷ പ്രധാനമാണ്.

HTTP അടിസ്ഥാനമാക്കിയ ട്രാൻസ്പോർട്ടുകൾ ഉപയോഗിച്ച് MCP സർവറുകൾ നടപ്പിലാക്കുമ്പോൾ, നിരവധി ആക്രമണ മാർഗങ്ങളും സംരക്ഷണ സംവിധാനങ്ങളും ശ്രദ്ധിക്കേണ്ടതുണ്ട്.

### അവലോകനം

MCP സർവറുകൾ HTTP വഴി പ്രദർശിപ്പിക്കുമ്പോൾ സുരക്ഷ അത്യന്താപേക്ഷിതമാണ്. Streamable HTTP പുതിയ ആക്രമണ സാധ്യതകൾ അവതരിപ്പിക്കുന്നു, അതിനാൽ സൂക്ഷ്മമായ കോൺഫിഗറേഷൻ ആവശ്യമാണ്.

പ്രധാന സുരക്ഷാ പരിഗണനകൾ:

- **Origin ഹെഡർ പരിശോധന**: DNS റിബൈൻഡിംഗ് ആക്രമണങ്ങൾ തടയാൻ `Origin` ഹെഡർ എല്ലായ്പ്പോഴും പരിശോധിക്കുക.
- **ലോകൽഹോസ്റ്റ് ബൈൻഡിംഗ്**: ലോക്കൽ ഡെവലപ്പ്മെന്റിനായി സർവറുകൾ `localhost`-ലേക്ക് ബൈൻഡ് ചെയ്യുക, പൊതു ഇന്റർനെറ്റിൽ പ്രദർശിപ്പിക്കാതിരിക്കാൻ.
- **ഓതന്റിക്കേഷൻ**: പ്രൊഡക്ഷൻ ഡിപ്ലോയ്മെന്റുകൾക്കായി ഓതന്റിക്കേഷൻ (ഉദാ: API കീകൾ, OAuth) നടപ്പിലാക്കുക.
- **CORS**: ആക്‌സസ് നിയന്ത്രിക്കാൻ Cross-Origin Resource Sharing (CORS) നയം ക്രമീകരിക്കുക.
- **HTTPS**: ട്രാഫിക് എൻക്രിപ്റ്റ് ചെയ്യാൻ പ്രൊഡക്ഷനിൽ HTTPS ഉപയോഗിക്കുക.

### മികച്ച പ്രാക്ടീസുകൾ

MCP സ്റ്റ്രീമിംഗ് സർവറിൽ സുരക്ഷ നടപ്പിലാക്കുമ്പോൾ പാലിക്കേണ്ട ചില മികച്ച പ്രാക്ടീസുകൾ:

- പരിശോധനയില്ലാതെ വരുന്ന അഭ്യർത്ഥനകളെ ഒരിക്കലും വിശ്വസിക്കരുത്.
- എല്ലാ ആക്‌സസും പിശകുകളും ലോഗ് ചെയ്ത് നിരീക്ഷിക്കുക.
- സുരക്ഷാ ദുർബലതകൾ പാച്ച് ചെയ്യാൻ ഡിപ്പെൻഡൻസികൾregelmäßig അപ്ഡേറ്റ് ചെയ്യുക.

### വെല്ലുവിളികൾ

MCP സ്റ്റ്രീമിംഗ് സർവറുകളിൽ സുരക്ഷ നടപ്പിലാക്കുമ്പോൾ നേരിടേണ്ട ചില വെല്ലുവിളികൾ:

- വികസന സൗകര്യത്തോടൊപ്പം സുരക്ഷയുടെ ബാലൻസ് നിലനിർത്തൽ
- വിവിധ ക്ലയന്റ് പരിസ്ഥിതികളുമായി പൊരുത്തപ്പെടൽ ഉറപ്പാക്കൽ

### അസൈൻമെന്റ്: നിങ്ങളുടെ സ്വന്തം സ്റ്റ്രീമിംഗ് MCP ആപ്പ് നിർമ്മിക്കുക

**സന്ദർഭം:**
ഒരു MCP സർവർ, ക്ലയന്റ് നിർമ്മിക്കുക, ഇവിടെ സർവർ ഒരു ലിസ്റ്റ് (ഉദാ: ഫയലുകൾ അല്ലെങ്കിൽ ഡോക്യുമെന്റുകൾ) പ്രോസസ്സ് ചെയ്ത് ഓരോ ഇനത്തിനും അറിയിപ്പ് അയയ്ക്കുന്നു. ക്ലയന്റ് ഓരോ അറിയിപ്പും എത്തുമ്പോൾ പ്രദർശിപ്പിക്കണം.

**ഘട്ടങ്ങൾ:**

1. ഒരു സർവർ ടൂൾ നടപ്പിലാക്കുക, ലിസ്റ്റ് പ്രോസസ്സ് ചെയ്ത് ഓരോ ഇനത്തിനും അറിയിപ്പുകൾ അയയ്ക്കുന്നു.
2. അറിയിപ്പുകൾ റിയൽ ടൈമിൽ പ്രദർശിപ്പിക്കാൻ മെസേജ് ഹാൻഡ്ലർ ഉള്ള ക്ലയന്റ് നടപ്പിലാക്കുക.
3. സർവർ, ക്ലയന്റ് രണ്ടും പ്രവർത്തിപ്പിച്ച് നിങ്ങളുടെ നടപ്പാക്കൽ പരീക്ഷിക്കുക, അറിയിപ്പുകൾ ശ്രദ്ധിക്കുക.

[Solution](./solution/README.md)

## കൂടുതൽ വായനയും അടുത്തത്?

MCP സ്റ്റ്രീമിംഗുമായി നിങ്ങളുടെ യാത്ര തുടരാനും കൂടുതൽ പരിജ്ഞാനം സമ്പാദിക്കാനും, ഈ വിഭാഗം അധിക വിഭവങ്ങളും നിർദ്ദേശിച്ച അടുത്ത ഘട്ടങ്ങളും നൽകുന്നു.

### കൂടുതൽ വായന

- [Microsoft: Introduction to HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS in ASP.NET Core](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Streaming Requests](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### അടുത്തത്?

- റിയൽ ടൈം അനലിറ്റിക്സ്, ചാറ്റ്, അല്ലെങ്കിൽ സഹകരണ എഡിറ്റിങ്ങിനായി സ്റ്റ്രീമിംഗ് ഉപയോഗിക്കുന്ന കൂടുതൽ പുരോഗമന MCP ടൂളുകൾ നിർമ്മിക്കാൻ ശ്രമിക്കുക.
- MCP സ്റ്റ്രീമിംഗ് ഫ്രണ്ട്‌എൻഡ് ഫ്രെയിംവർക്ക് (React, Vue, തുടങ്ങിയവ) എന്നിവയുമായി സംയോജിപ്പിച്ച് ലൈവ് UI അപ്‌ഡേറ്റുകൾ പരീക്ഷിക്കുക.
- അടുത്തത്: [Utilising AI Toolkit for VSCode](../07-aitk/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**അസൂയാ**:  
ഈ രേഖ AI വിവർത്തന സേവനം [Co-op Translator](https://github.com/Azure/co-op-translator) ഉപയോഗിച്ച് വിവർത്തനം ചെയ്തതാണ്. നാം കൃത്യതയ്ക്ക് ശ്രമിച്ചിട്ടുണ്ടെങ്കിലും, സ്വയം പ്രവർത്തിക്കുന്ന വിവർത്തനങ്ങളിൽ പിശകുകൾ അല്ലെങ്കിൽ തെറ്റുകൾ ഉണ്ടാകാമെന്ന് ദയവായി ശ്രദ്ധിക്കുക. അതിന്റെ മാതൃഭാഷയിലുള്ള യഥാർത്ഥ രേഖയാണ് പ്രാമാണികമായ ഉറവിടം എന്ന് പരിഗണിക്കേണ്ടതാണ്. നിർണായകമായ വിവരങ്ങൾക്ക്, പ്രൊഫഷണൽ മനുഷ്യ വിവർത്തനം ശുപാർശ ചെയ്യപ്പെടുന്നു. ഈ വിവർത്തനം ഉപയോഗിക്കുന്നതിൽ നിന്നുണ്ടാകുന്ന ഏതെങ്കിലും തെറ്റിദ്ധാരണകൾക്കോ തെറ്റായ വ്യാഖ്യാനങ്ങൾക്കോ ഞങ്ങൾ ഉത്തരവാദികളല്ല.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->