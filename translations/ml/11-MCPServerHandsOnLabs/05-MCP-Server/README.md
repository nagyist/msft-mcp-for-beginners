# MCP เดธเตเตผเดตเตผ เดจเดเดชเตเดชเดพเดเตเดเตฝ

## ๐ฏ เด เดฒเดพเดฌเต เดเตพเดเตเดเตเดณเตเดณเตเดจเตเดจเดคเต

เด เดนเดพเตปเดกเตโเดธเต-เดเตบ เดฒเดพเดฌเต เดจเดฟเดเตเดเตพเดเตเดเต FastMCP เดซเตเดฐเตเดฏเดฟเดเดตเตผเดเตเดเต เดเดชเดฏเตเดเดฟเดเตเดเต เดชเตเดฐเตเดกเดเตเดทเตป-เดฑเตเดกเดฟ MCP เดธเตเตผเดตเตผ เดจเดเดชเตเดชเดพเดเตเดเตเดจเตเดจเดคเดฟเตฝ เดฎเดพเตผเดเดจเดฟเตผเดฆเตเดฆเตเดถเด เดจเตฝเดเตเดจเตเดจเต. เดจเดฟเดเตเดเตพ เดเตเตผ เดธเตเตผเดตเตผ เดเดเดจ เดจเดฟเตผเดฎเตเดฎเดฟเดเตเดเตเด, เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดเดจเตเดฑเดเตเดฐเตเดทเตป เดจเดเดชเตเดชเดพเดเตเดเตเด, เดกเดพเดฑเตเดฑ เดเดเตเดธเดธเต เดเตเดณเตเดเตพ เดธเตเดทเตเดเดฟเดเตเดเตเด, AI-เดเดพเดฒเดฟเดค เดฑเตเดเตเดเตเดฏเดฟเตฝ เดเดจเดฒเดฟเดฑเตเดฑเดฟเดเตเดธเดฟเดจเตเดณเตเดณ เดเดเดฟเดธเตเดฅเดพเดจเดฎเดฟเดเตเด.

## เดเดตเดฒเตเดเดจเด

MCP เดธเตเตผเดตเตผ เดจเดฎเตเดฎเตเดเต เดฑเตเดเตเดเตเดฏเดฟเตฝ เดเดจเดฒเดฟเดฑเตเดฑเดฟเดเตเดธเต เดชเดฐเดฟเดนเดพเดฐเดคเตเดคเดฟเดจเตเดฑเต เดนเตเดฆเดฏเดฎเดพเดฃเต. เดเดคเต AI เดเดธเดฟเดธเตเดฑเตเดฑเดจเตเดฑเตเดเดณเตเด PostgreSQL เดกเดพเดฑเตเดฑเดพเดฌเตเดธเตเด เดคเดฎเตเดฎเดฟเดฒเตเดณเตเดณ เดชเดพเดฒเดฎเดพเดฏเดฟ เดชเตเดฐเดตเตผเดคเตเดคเดฟเดเตเดเต, เดฌเดฟเดธเดฟเดจเดธเต เดกเดพเดฑเตเดฑเดฏเตเดเตเดเต เดธเตเดฐเดเตเดทเดฟเดคเดตเตเด เดฌเตเดฆเตเดงเดฟเดฎเตเดเตเดเตเดณเตเดณ เดเดเตเดธเดธเต เดเดฐเต เดธเตเดฑเตเดฑเดพเตปเดกเตเตผเดกเตเดธเตเดกเต เดชเตเดฐเตเดเตเดเตเดเตเดเตเตพ เดตเดดเดฟ เดจเตฝเดเตเดจเตเดจเต.

เด เดฒเดพเดฌเต เดเดจเตเดฑเตผเดชเตเดฐเตเดธเต เดชเดพเดฑเตเดฑเตเดฃเตเดเดณเตเด เดฎเดฟเดเดเตเด เดชเตเดฐเดพเดเตเดเตเดธเตเดเดณเตเด เดชเดฟเดจเตเดคเตเดเตผเดจเตเดจเต เดเดฐเต เดถเดเตเดคเดตเตเด เดธเตเดเตเดฒเดฌเดฟเตพ เดเดฏ MCP เดธเตเตผเดตเตผ เดจเดฟเตผเดฎเตเดฎเดฟเดเตเดเดพเตป เดจเดฟเดเตเดเดณเต เดชเดเดฟเดชเตเดชเดฟเดเตเดเตเดจเตเดจเต.

## เดชเดเดจ เดฒเดเตเดทเตเดฏเดเตเดเตพ

เด เดฒเดพเดฌเต เดเดตเดธเดพเดจเดฟเดเตเดเตเดจเตเดจเดชเตเดชเตเตพ, เดจเดฟเดเตเดเตพเดเตเดเต เดเดดเดฟเดฏเตเด:

- **เดจเดฟเตผเดฎเตเดฎเดฟเดเตเดเตเด** เดถเดฐเดฟเดฏเดพเดฏ เดเตผเดเตเดเดฟเดเตเดเตเดเดฑเตเด เดธเดเดเดเดจเดฏเตเด เดเดณเตเดณ FastMCP เดธเตเตผเดตเตผ  
- **เดจเดเดชเตเดชเดพเดเตเดเตเด** เดเดฃเดเตเดทเตป เดชเตเดฒเดฟเดเดเตเด เดชเดฟเดถเดเต เดเตเดเดพเดฐเตเดฏเด เดเตเดฏเตเดฏเดฒเตเด เดเดณเตเดณ เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดเดจเตเดฑเดเตเดฐเตเดทเตป  
- **เดธเตเดทเตเดเดฟเดเตเดเตเด** เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดธเตเดเตเดฎ เดเตปเดเตเดฐเตเดธเตเดชเตเดเตเดทเดจเตเด เดเตเดตเดฑเดฟ เดเดเตเดธเดฟเดเตเดฏเตเดทเดจเตเด เดเดณเตเดณ MCP เดเตเดณเตเดเตพ  
- **เดเตเตบเดซเดฟเดเตผ เดเตเดฏเตเดฏเตเด** เดฑเต เดฒเตเดตเตฝ เดธเตเดเตเดฏเตเดฐเดฟเดฑเตเดฑเดฟ เดเตเตบเดเตเดเตเดธเตเดฑเตเดฑเต เดฎเดพเดจเตเดเตเดฎเตเดจเตเดฑเต  
- **เดเตเดเตเด** เดนเตเตฝเดคเตเดคเต เดฎเตเดฃเดฟเดฑเตเดฑเดฑเดฟเดเดเต, เดเดฌเตเดธเตผเดตเดฌเดฟเดฒเดฟเดฑเตเดฑเดฟ เดซเตเดเตเดเดฑเตเดเตพ  
- **เดเตเดธเตเดฑเตเดฑเต เดเตเดฏเตเดฏเตเด** เดจเดฟเดเตเดเดณเตเดเต MCP เดธเตเตผเดตเตผ เดจเดเดชเตเดชเดพเดเตเดเตฝ เดฒเตเดเตเดเดฒเดฟเดฒเตเด VS เดเตเดกเดฟเดฒเตเด

## ๐ เดชเตเดฐเตเดเดเตเดเต เดเดเดจ

MCP เดธเตเตผเดตเตผ เดธเดเดเดเดจ เดชเดฐเดฟเดถเตเดงเดฟเดเตเดเดพเด:

```
mcp_server/
โโโ __init__.py                 # Package initialization
โโโ config.py                   # Configuration management
โโโ health_check.py             # Health monitoring endpoints
โโโ sales_analysis.py           # Main MCP server implementation
โโโ sales_analysis_postgres.py  # Database integration layer
โโโ sales_analysis_text_embeddings.py  # AI/semantic search integration
```

## ๐ง เดเตเตบเดซเดฟเดเดฑเตเดทเตป เดฎเดพเดจเตเดเตเดฎเตเดจเตเดฑเต

### เดเตปเดตเดฏเตเตบเดฎเตเดจเตเดฑเต เดเตเตบเดซเดฟเดเดฑเตเดทเตป (`config.py`)

เดเดฆเตเดฏเด, เดเดฐเต เดถเดเตเดคเดฎเดพเดฏ เดเตเตบเดซเดฟเดเดฑเตเดทเตป เดธเดฟเดธเตเดฑเตเดฑเด เดธเตเดทเตเดเดฟเดเตเดเดพเด:

```python
# mcp_server/config.py
"""
Configuration management for the MCP server.
Handles environment variables, validation, and defaults.
"""
import os
import logging
from typing import Optional, Dict, Any
from dataclasses import dataclass
from dotenv import load_dotenv

# .env เดซเดฏเดฒเดฟเตฝ เดจเดฟเดจเตเดจเต เดชเดฐเดฟเดธเตเดฅเดฟเดคเดฟ เดตเตเดฏเดคเตเดฏเดพเดธเดเตเดเตพ เดฒเตเดกเต เดเตเดฏเตเดฏเตเด
load_dotenv()

logger = logging.getLogger(__name__)

@dataclass
class DatabaseConfig:
    """Database connection configuration."""
    host: str
    port: int
    database: str
    user: str
    password: str
    min_connections: int = 2
    max_connections: int = 10
    command_timeout: int = 30
    
    @classmethod
    def from_env(cls) -> 'DatabaseConfig':
        """Create configuration from environment variables."""
        return cls(
            host=os.getenv('POSTGRES_HOST', 'localhost'),
            port=int(os.getenv('POSTGRES_PORT', '5432')),
            database=os.getenv('POSTGRES_DB', 'zava'),
            user=os.getenv('POSTGRES_USER', 'postgres'),
            password=os.getenv('POSTGRES_PASSWORD', ''),
            min_connections=int(os.getenv('POSTGRES_MIN_CONNECTIONS', '2')),
            max_connections=int(os.getenv('POSTGRES_MAX_CONNECTIONS', '10')),
            command_timeout=int(os.getenv('POSTGRES_COMMAND_TIMEOUT', '30'))
        )
    
    def to_asyncpg_params(self) -> Dict[str, Any]:
        """Convert to asyncpg connection parameters."""
        return {
            'host': self.host,
            'port': self.port,
            'database': self.database,
            'user': self.user,
            'password': self.password,
            'command_timeout': self.command_timeout,
            'server_settings': {
                'application_name': 'zava-mcp-server',
                'jit': 'off',  # เดธเตเดฅเดฟเดฐเดคเดฏเตเดเตเดเดพเดฏเดฟ JIT เดเดชเตเดฐเดพเดชเตเดคเดฎเดพเดเตเดเตเด
                'work_mem': '4MB',
                'statement_timeout': f'{self.command_timeout}s'
            }
        }

@dataclass
class AzureConfig:
    """Azure AI services configuration."""
    project_endpoint: str
    openai_endpoint: str
    embedding_model_deployment: str
    client_id: str
    client_secret: str
    tenant_id: str
    
    @classmethod
    def from_env(cls) -> 'AzureConfig':
        """Create configuration from environment variables."""
        return cls(
            project_endpoint=os.getenv('PROJECT_ENDPOINT', ''),
            openai_endpoint=os.getenv('AZURE_OPENAI_ENDPOINT', ''),
            embedding_model_deployment=os.getenv('EMBEDDING_MODEL_DEPLOYMENT_NAME', 'text-embedding-3-small'),
            client_id=os.getenv('AZURE_CLIENT_ID', ''),
            client_secret=os.getenv('AZURE_CLIENT_SECRET', ''),
            tenant_id=os.getenv('AZURE_TENANT_ID', '')
        )
    
    def is_configured(self) -> bool:
        """Check if all required Azure configuration is present."""
        return all([
            self.project_endpoint,
            self.openai_endpoint,
            self.client_id,
            self.client_secret,
            self.tenant_id
        ])

@dataclass
class ServerConfig:
    """MCP server configuration."""
    host: str = '0.0.0.0'
    port: int = 8000
    log_level: str = 'INFO'
    enable_cors: bool = True
    enable_health_check: bool = True
    applicationinsights_connection_string: Optional[str] = None
    
    @classmethod
    def from_env(cls) -> 'ServerConfig':
        """Create configuration from environment variables."""
        return cls(
            host=os.getenv('MCP_SERVER_HOST', '0.0.0.0'),
            port=int(os.getenv('MCP_SERVER_PORT', '8000')),
            log_level=os.getenv('LOG_LEVEL', 'INFO').upper(),
            enable_cors=os.getenv('ENABLE_CORS', 'true').lower() == 'true',
            enable_health_check=os.getenv('ENABLE_HEALTH_CHECK', 'true').lower() == 'true',
            applicationinsights_connection_string=os.getenv('APPLICATIONINSIGHTS_CONNECTION_STRING')
        )

class MCPServerConfig:
    """Main configuration class for the MCP server."""
    
    def __init__(self):
        self.database = DatabaseConfig.from_env()
        self.azure = AzureConfig.from_env()
        self.server = ServerConfig.from_env()
        
        # เดเตเตบเดซเดฟเดเดฑเตเดทเตป เดธเดพเดงเตเดค เดชเดฐเดฟเดถเตเดงเดฟเดเตเดเตเด
        self._validate_config()
    
    def _validate_config(self):
        """Validate configuration and log warnings for missing values."""
        if not self.database.password:
            logger.warning("Database password is empty. This may cause connection issues.")
        
        if not self.azure.is_configured():
            logger.warning("Azure configuration is incomplete. AI features may not work.")
        
        logger.info(f"Configuration loaded - Database: {self.database.host}:{self.database.port}")
        logger.info(f"Server will run on {self.server.host}:{self.server.port}")

# เดเดเตเดณ เดเตเตบเดซเดฟเดเดฑเตเดทเตป เดเตปเดธเตเดฑเตเดฑเตปเดธเต
config = MCPServerConfig()
```

### เดชเตเดฐเดงเดพเดจ เดเตเตบเดซเดฟเดเดฑเตเดทเตป เดซเตเดเตเดเดฑเตเดเตพ

- **เดเตปเดตเดฏเตเตบเดฎเตเดจเตเดฑเต เดตเตเดฐเดฟเดฏเดฌเดฟเตพ เดฒเตเดกเดฟเดเดเต**: เดเดเตเดเตเดฎเดพเดฑเตเดฑเดฟเดเต .env เดซเดฏเตฝ เดชเดฟเดจเตเดคเตเดฃ  
- **เดเตเดชเตเดชเต เดธเตเดซเตเดฑเตเดฑเดฟ**: เดกเดพเดฑเตเดฑเดพเดเตเดฒเดพเดธเต เดตเดพเดฒเดฟเดกเตเดทเตป, เดเตเดชเตเดชเต เดนเดฟเดจเตเดฑเตเดเตพ  
- **เดซเตเดฒเตเดเตเดธเดฟเดฌเดฟเตพ เดกเดฟเดซเตเตพเดเตเดเตเดเตพ**: เดกเตเดตเดฒเดชเตเดชเตเดฎเตเดจเตเดฑเดฟเดจเตเดณเตเดณ เดธเตเตปเดธเดฟเดฌเดฟเตพ เดกเดฟเดซเตเตพเดเตเดเตเดเตพ  
- **เดตเดพเดฒเดฟเดกเตเดทเตป**: เดธเดนเดพเดฏเดเดฐเดฎเดพเดฏ เดชเดฟเดถเดเต เดธเดจเตเดฆเตเดถเดเตเดเดณเตเดเต เดเตเตบเดซเดฟเดเดฑเตเดทเตป เดตเดพเดฒเดฟเดกเตเดทเตป  
- **เดธเตเดเตเดฏเตเดฐเดฟเดฑเตเดฑเดฟ**: เดธเตเตปเดธเดฟเดฑเตเดฑเตเดตเต เดฎเตเดฒเตเดฏเดเตเดเตพ เดเตปเดตเดฏเตเตบเดฎเตเดจเตเดฑเต เดตเตเดฐเดฟเดฏเดฌเดฟเตพเดฎเดพเตผเดจเตเดจเดฟเตฝ เดจเดฟเดจเตเดจเต เดฎเดพเดคเตเดฐเด

## ๐๏ธ เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดเดจเตเดฑเดเตเดฐเตเดทเตป เดฒเตเดฏเตผ

### PostgreSQL เดชเตเดฐเตเดตเตเดกเตผ (`sales_analysis_postgres.py`)

เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดเดจเตเดฑเดเตเดฐเตเดทเตป เดฒเตเดฏเตผ เดจเดเดชเตเดชเดพเดเตเดเดพเด:

```python
# mcp_server/sales_analysis_postgres.py
"""
PostgreSQL database integration for MCP server.
Handles connections, queries, and schema introspection.
"""
import asyncio
import asyncpg
import logging
from typing import Dict, Any, List, Optional, Tuple
from contextlib import asynccontextmanager
from datetime import datetime
import json

from .config import config

logger = logging.getLogger(__name__)

class PostgreSQLSchemaProvider:
    """Provides PostgreSQL database access and schema information."""
    
    def __init__(self):
        self.connection_pool: Optional[asyncpg.Pool] = None
        self.postgres_config = config.database.to_asyncpg_params()
        
    async def create_pool(self) -> None:
        """Create connection pool for database operations."""
        if self.connection_pool is None:
            try:
                self.connection_pool = await asyncpg.create_pool(
                    **self.postgres_config,
                    min_size=config.database.min_connections,
                    max_size=config.database.max_connections,
                    max_inactive_connection_lifetime=300  # 5 เดฎเดฟเดจเดฟเดฑเตเดฑเต
                )
                logger.info("Database connection pool created successfully")
            except Exception as e:
                logger.error(f"Failed to create database connection pool: {e}")
                raise
    
    async def close_pool(self) -> None:
        """Close the connection pool."""
        if self.connection_pool:
            await self.connection_pool.close()
            self.connection_pool = None
            logger.info("Database connection pool closed")
    
    @asynccontextmanager
    async def get_connection(self):
        """Get a database connection from the pool."""
        if not self.connection_pool:
            await self.create_pool()
        
        async with self.connection_pool.acquire() as connection:
            yield connection
    
    async def set_rls_context(self, connection: asyncpg.Connection, rls_user_id: str) -> None:
        """Set Row Level Security context for the connection."""
        try:
            await connection.execute(
                "SELECT set_config('app.current_rls_user_id', $1, false)",
                rls_user_id
            )
            logger.debug(f"RLS context set for user: {rls_user_id}")
        except Exception as e:
            logger.error(f"Failed to set RLS context: {e}")
            raise
    
    async def get_table_schema(self, table_name: str, rls_user_id: str) -> Dict[str, Any]:
        """Get detailed schema information for a specific table."""
        async with self.get_connection() as conn:
            await self.set_rls_context(conn, rls_user_id)
            
            # เดธเตเดเตเดฎเดฏเตเด เดชเดเตเดเดฟเดเดฏเตเดเต เดชเตเดฐเตเด เดชเดพเดดเตโเดธเต เดเตเดฏเตเดฏเตเด
            if '.' in table_name:
                schema_name, table_name = table_name.split('.', 1)
            else:
                schema_name = 'retail'  # เดกเดฟเดซเตเตพเดเตเดเต เดธเตเดเตเดฎ
            
            # เดเตเดณเด เดตเดฟเดตเดฐเดเตเดเตพ เดจเตเดเตเด
            columns_query = """
                SELECT 
                    column_name,
                    data_type,
                    is_nullable,
                    column_default,
                    character_maximum_length,
                    numeric_precision,
                    numeric_scale,
                    ordinal_position
                FROM information_schema.columns 
                WHERE table_schema = $1 AND table_name = $2
                ORDER BY ordinal_position
            """
            
            columns = await conn.fetch(columns_query, schema_name, table_name)
            
            if not columns:
                raise ValueError(f"Table {schema_name}.{table_name} not found or not accessible")
            
            # เดตเดฟเดฆเตเดถ เดเต เดฌเดจเตเดงเดเตเดเตพ เดจเตเดเตเด
            fk_query = """
                SELECT 
                    kcu.column_name,
                    ccu.table_schema AS foreign_table_schema,
                    ccu.table_name AS foreign_table_name,
                    ccu.column_name AS foreign_column_name
                FROM information_schema.table_constraints tc
                JOIN information_schema.key_column_usage kcu 
                    ON tc.constraint_name = kcu.constraint_name
                JOIN information_schema.constraint_column_usage ccu 
                    ON ccu.constraint_name = tc.constraint_name
                WHERE tc.constraint_type = 'FOREIGN KEY' 
                    AND tc.table_schema = $1 
                    AND tc.table_name = $2
            """
            
            foreign_keys = await conn.fetch(fk_query, schema_name, table_name)
            
            # เดเตปเดกเดเตเดธเตเดเตพ เดจเตเดเตเด
            index_query = """
                SELECT 
                    indexname,
                    indexdef
                FROM pg_indexes 
                WHERE schemaname = $1 AND tablename = $2
            """
            
            indexes = await conn.fetch(index_query, schema_name, table_name)
            
            # เดธเตเดเตเดฎ เดตเดฟเดตเดฐเดเตเดเตพ เดซเตเตผเดฎเดพเดฑเตเดฑเต เดเตเดฏเตเดฏเตเด
            schema_info = {
                "table_name": f"{schema_name}.{table_name}",
                "columns": [
                    {
                        "name": col["column_name"],
                        "type": col["data_type"],
                        "nullable": col["is_nullable"] == "YES",
                        "default": col["column_default"],
                        "max_length": col["character_maximum_length"],
                        "precision": col["numeric_precision"],
                        "scale": col["numeric_scale"],
                        "position": col["ordinal_position"]
                    }
                    for col in columns
                ],
                "foreign_keys": [
                    {
                        "column": fk["column_name"],
                        "references": f"{fk['foreign_table_schema']}.{fk['foreign_table_name']}.{fk['foreign_column_name']}"
                    }
                    for fk in foreign_keys
                ],
                "indexes": [
                    {
                        "name": idx["indexname"],
                        "definition": idx["indexdef"]
                    }
                    for idx in indexes
                ]
            }
            
            return schema_info
    
    async def get_multiple_table_schemas(
        self, 
        table_names: List[str], 
        rls_user_id: str
    ) -> str:
        """Get schema information for multiple tables."""
        schemas = []
        
        for table_name in table_names:
            try:
                schema = await self.get_table_schema(table_name, rls_user_id)
                schemas.append(self._format_schema_for_ai(schema))
            except Exception as e:
                logger.warning(f"Failed to get schema for {table_name}: {e}")
                schemas.append(f"Error retrieving schema for {table_name}: {str(e)}")
        
        return "\n\n".join(schemas)
    
    def _format_schema_for_ai(self, schema: Dict[str, Any]) -> str:
        """Format schema information for AI consumption."""
        table_name = schema["table_name"]
        columns = schema["columns"]
        foreign_keys = schema["foreign_keys"]
        
        # เดเตเดณเด เดจเดฟเตผเดตเดเดจเดเตเดเตพ เดธเตเดทเตเดเดฟเดเตเดเตเด
        column_lines = []
        for col in columns:
            nullable = "NULL" if col["nullable"] else "NOT NULL"
            type_info = col["type"]
            
            if col["max_length"]:
                type_info += f"({col['max_length']})"
            elif col["precision"] and col["scale"]:
                type_info += f"({col['precision']},{col['scale']})"
            
            default_info = f" DEFAULT {col['default']}" if col["default"] else ""
            
            column_lines.append(f"  {col['name']} {type_info} {nullable}{default_info}")
        
        # เดตเดฟเดฆเตเดถ เดเต เดตเดฟเดตเดฐเดเตเดเตพ เดธเตเดทเตเดเดฟเดเตเดเตเด
        fk_lines = []
        for fk in foreign_keys:
            fk_lines.append(f"  {fk['column']} -> {fk['references']}")
        
        # เดตเดพเดฏเดฟเดเตเดเดพเตป เดเดดเดฟเดฏเตเดจเตเดจ เดซเตเตผเดฎเดพเดฑเตเดฑเดฟเดฒเตเดเตเดเต เดธเดเดฏเตเดเดฟเดชเตเดชเดฟเดเตเดเตเด
        schema_text = f"Table: {table_name}\n"
        schema_text += "Columns:\n" + "\n".join(column_lines)
        
        if fk_lines:
            schema_text += "\n\nForeign Keys:\n" + "\n".join(fk_lines)
        
        return schema_text
    
    async def execute_query(
        self, 
        sql_query: str, 
        rls_user_id: str,
        max_rows: int = 20
    ) -> str:
        """Execute a SQL query with Row Level Security context."""
        async with self.get_connection() as conn:
            await self.set_rls_context(conn, rls_user_id)
            
            try:
                # เดเดฐเต เดเตเดตเดฑเดฟ เดเตเดเดเดเตเดเต เดธเดเตเดเดฎเดพเดเตเดเตเด
                rows = await asyncio.wait_for(
                    conn.fetch(sql_query),
                    timeout=config.database.command_timeout
                )
                
                if not rows:
                    return "Query executed successfully. No rows returned."
                
                # เดซเดฒเด เดธเตเดฑเตเดฑเต เดตเดฒเตเดชเตเดชเด เดชเดฐเดฟเดฎเดฟเดคเดชเตเดชเตเดเตเดคเตเดคเตเด
                limited_rows = rows[:max_rows]
                
                # เดซเดฒเดเตเดเตพ เดซเตเตผเดฎเดพเดฑเตเดฑเต เดเตเดฏเตเดฏเตเด
                result = self._format_query_results(limited_rows, len(rows), max_rows)
                
                logger.info(f"Query executed successfully. Returned {len(limited_rows)} rows.")
                return result
                
            except asyncio.TimeoutError:
                error_msg = f"Query timeout after {config.database.command_timeout} seconds"
                logger.error(error_msg)
                raise Exception(error_msg)
            except Exception as e:
                logger.error(f"Query execution failed: {e}")
                raise
    
    def _format_query_results(
        self, 
        rows: List[asyncpg.Record], 
        total_rows: int,
        max_rows: int
    ) -> str:
        """Format query results for AI consumption."""
        if not rows:
            return "No results found."
        
        # เดเตเดณเด เดชเตเดฐเตเดเตพ เดจเตเดเตเด
        columns = list(rows[0].keys())
        
        # เดนเตเดกเตผ เดธเตเดทเตเดเดฟเดเตเดเตเด
        result_lines = [f"Results ({len(rows)} of {total_rows} rows):"]
        result_lines.append("=" * 50)
        
        # เดเตเดณเด เดนเตเดกเดฑเตเดเตพ เดเตเตผเดเตเดเตเด
        header = " | ".join(columns)
        result_lines.append(header)
        result_lines.append("-" * len(header))
        
        # เดกเดพเดฑเตเดฑเดพ เดตเดฐเดฟเดเตพ เดเตเตผเดเตเดเตเด
        for row in rows:
            formatted_values = []
            for col in columns:
                value = row[col]
                if value is None:
                    formatted_values.append("NULL")
                elif isinstance(value, datetime):
                    formatted_values.append(value.strftime("%Y-%m-%d %H:%M:%S"))
                elif isinstance(value, (dict, list)):
                    formatted_values.append(json.dumps(value))
                else:
                    formatted_values.append(str(value))
            
            result_lines.append(" | ".join(formatted_values))
        
        # เดเดตเดถเตเดฏเดฎเตเดเตเดเดฟเตฝ เดเตเดฐเดเตเดเตเดทเตป เดเดฑเดฟเดฏเดฟเดชเตเดชเต เดเตเตผเดเตเดเตเด
        if total_rows > max_rows:
            result_lines.append(f"\n... and {total_rows - max_rows} more rows (truncated for display)")
        
        return "\n".join(result_lines)
    
    async def get_current_utc_date(self) -> str:
        """Get current UTC date/time."""
        async with self.get_connection() as conn:
            result = await conn.fetchval("SELECT NOW() AT TIME ZONE 'UTC'")
            return result.isoformat() + "Z"
    
    async def health_check(self) -> Dict[str, Any]:
        """Perform database health check."""
        try:
            async with self.get_connection() as conn:
                # เดฒเดณเดฟเดคเดฎเดพเดฏ เดเดฃเดเตเดเดฟเดตเดฟเดฑเตเดฑเดฟ เดชเดฐเดฟเดถเตเดงเดจ
                result = await conn.fetchval("SELECT 1")
                
                # เดชเตเตพ เดจเดฟเดฒ เดชเดฐเดฟเดถเตเดงเดฟเดเตเดเตเด
                pool_info = {
                    "min_size": self.connection_pool._minsize if self.connection_pool else 0,
                    "max_size": self.connection_pool._maxsize if self.connection_pool else 0,
                    "current_size": self.connection_pool.get_size() if self.connection_pool else 0,
                    "idle_size": self.connection_pool.get_idle_size() if self.connection_pool else 0
                }
                
                return {
                    "status": "healthy",
                    "database_responsive": result == 1,
                    "pool_info": pool_info
                }
                
        except Exception as e:
            return {
                "status": "unhealthy",
                "error": str(e)
            }

# เดเดเตเดณ เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดชเตเดฐเตเดตเตเดกเตผ เดเตปเดธเตเดฑเตเดฑเตปเดธเต
db_provider = PostgreSQLSchemaProvider()
```

### เดชเตเดฐเดงเดพเดจ เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดฒเตเดฏเตผ เดซเตเดเตเดเดฑเตเดเตพ

- **เดเดฃเดเตเดทเตป เดชเตเดฒเดฟเดเดเต**: asyncpg เดเดชเดฏเตเดเดฟเดเตเดเต เดเดพเดฐเตเดฏเดเตเดทเดฎเดฎเดพเดฏ เดฑเดฟเดธเตเดดเตโเดธเต เดฎเดพเดจเตเดเตเดฎเตเดจเตเดฑเต  
- **RLS เดเดจเตเดฑเดเตเดฐเตเดทเตป**: เดเดเตเดเตเดฎเดพเดฑเตเดฑเดฟเดเต เดฑเต เดฒเตเดตเตฝ เดธเตเดเตเดฏเตเดฐเดฟเดฑเตเดฑเดฟ เดเตเตบเดเตเดเตเดธเตเดฑเตเดฑเต เดธเตเดฑเตเดฑเดฟเดเดเต  
- **เดธเตเดเตเดฎ เดเตปเดเตเดฐเตเดธเตเดชเตเดเตเดทเตป**: เดกเตเดจเดพเดฎเดฟเดเต เดเตเดฌเดฟเตพ เดธเตเดเตเดฎ เดเดฃเตเดเตเดคเตเดคเตฝ  
- **เดชเดฟเดถเดเต เดเตเดเดพเดฐเตเดฏเด เดเตเดฏเตเดฏเตฝ**: เดธเดฎเดเตเดฐเดฎเดพเดฏ เดชเดฟเดถเดเต เดฎเดพเดจเตเดเตเดฎเตเดจเตเดฑเต, เดฒเตเดเดฟเดเดเต  
- **เดเตเดตเดฑเดฟ เดซเตเตผเดฎเดพเดฑเตเดฑเดฟเดเดเต**: AI-เดธเตเดนเตเดฆ เดซเดฒเด เดซเตเตผเดฎเดพเดฑเตเดฑเดฟเดเดเต  
- **เดนเตเตฝเดคเตเดคเต เดฎเตเดฃเดฟเดฑเตเดฑเดฑเดฟเดเดเต**: เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดเดฃเดเตเดเดฟเดตเดฟเดฑเตเดฑเดฟ, เดชเตเตพ เดธเตเดฑเตเดฑเดพเดฑเตเดฑเดธเต เดชเดฐเดฟเดถเตเดงเดจเดเตพ

## ๐ง เดชเตเดฐเดงเดพเดจ MCP เดธเตเตผเดตเตผ เดจเดเดชเตเดชเดพเดเตเดเตฝ

### FastMCP เดธเตเตผเดตเตผ (`sales_analysis.py`)

เดเดชเตเดชเตเตพ เดชเตเดฐเดงเดพเดจ MCP เดธเตเตผเดตเตผ เดจเดเดชเตเดชเดพเดเตเดเดพเด:

```python
# mcp_server/sales_analysis.py
"""
Main MCP server implementation for Zava Retail Sales Analysis.
Provides AI assistants with secure access to retail database.
"""
import logging
import asyncio
from typing import Dict, Any, List, Annotated
from contextlib import asynccontextmanager

from fastmcp import FastMCP, Context
from pydantic import Field

from .config import config
from .sales_analysis_postgres import db_provider
from .health_check import setup_health_endpoints

# เดฒเตเดเดฟเดเดเต เดเตเดฐเดฎเตเดเดฐเดฟเดเตเดเตเด
logging.basicConfig(
    level=getattr(logging, config.server.log_level),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# FastMCP เดธเตเตผเดตเตผ เดเตปเดธเตเดฑเตเดฑเตปเดธเต เดธเตเดทเตเดเดฟเดเตเดเตเด
mcp = FastMCP("Zava Retail Sales Analysis")

# เดธเตเดเตเดฎ เดเดเตเดธเดธเดฟเดจเตเดณเตเดณ เดธเดพเดงเตเดตเดพเดฏ เดชเดเตเดเดฟเดเดเดณเตเดเต เดชเดเตเดเดฟเด
VALID_TABLES = [
    "retail.stores",
    "retail.customers", 
    "retail.categories",
    "retail.product_types",
    "retail.products",
    "retail.orders",
    "retail.order_items",
    "retail.inventory"
]

def get_rls_user_id(ctx: Context) -> str:
    """Extract Row Level Security User ID from request context."""
    # HTTP เดฎเตเดกเดฟเตฝ, เดนเตเดกเดฑเตเดเดณเดฟเตฝ เดจเดฟเดจเตเดจเต เดจเตเดเตเด
    if hasattr(ctx, 'headers') and ctx.headers:
        rls_user_id = ctx.headers.get("x-rls-user-id")
        if rls_user_id:
            logger.debug(f"RLS User ID from headers: {rls_user_id}")
            return rls_user_id
    
    # เดตเดฟเดเดธเดจ/เดชเดฐเตเดเตเดทเดฃเดคเตเดคเดฟเดจเตเดณเตเดณ เดกเดฟเดซเตเตพเดเตเดเต เดซเดพเตพเดฌเดพเดเตเดเต
    default_id = "00000000-0000-0000-0000-000000000000"
    logger.warning(f"No RLS User ID found, using default: {default_id}")
    return default_id

@mcp.tool()
async def get_multiple_table_schemas(
    ctx: Context,
    table_names: Annotated[List[str], Field(description="List of table names to retrieve schemas for. Valid tables: " + ", ".join(VALID_TABLES))]
) -> str:
    """
    Retrieve database schemas for multiple tables in a single request.
    
    This tool provides comprehensive schema information including:
    - Column names, types, and constraints
    - Foreign key relationships
    - Index information
    - Table structure for AI query planning
    
    Args:
        table_names: List of valid table names from the retail schema
        
    Returns:
        Formatted schema information for all requested tables
    """
    rls_user_id = get_rls_user_id(ctx)
    
    # เดชเดเตเดเดฟเดเดฏเตเดเต เดชเตเดฐเตเดเตพ เดธเดพเดงเตเดตเดพเดฃเตเดจเตเดจเต เดชเดฐเดฟเดถเตเดงเดฟเดเตเดเตเด
    invalid_tables = [table for table in table_names if table not in VALID_TABLES]
    if invalid_tables:
        logger.warning(f"Invalid table names requested: {invalid_tables}")
        return f"Error: Invalid table names: {', '.join(invalid_tables)}. Valid tables are: {', '.join(VALID_TABLES)}"
    
    try:
        logger.info(f"Retrieving schemas for tables: {table_names} (User: {rls_user_id})")
        result = await db_provider.get_multiple_table_schemas(table_names, rls_user_id)
        return result
    except Exception as e:
        logger.error(f"Error retrieving table schemas: {e}")
        return f"Error retrieving table schemas: {e!s}"

@mcp.tool()
async def execute_sales_query(
    ctx: Context,
    postgresql_query: Annotated[str, Field(description="A well-formed PostgreSQL query to execute against the retail database. Always get table schemas first before writing queries.")]
) -> str:
    """
    Execute PostgreSQL queries against the retail sales database with Row Level Security.
    
    This tool allows AI assistants to run analytical queries on retail data including:
    - Sales performance analysis
    - Customer behavior insights  
    - Inventory management queries
    - Product performance metrics
    - Store-specific reporting
    
    Important: Row Level Security ensures users only see data they're authorized to access.
    
    Args:
        postgresql_query: SQL query to execute (automatically filtered by RLS)
        
    Returns:
        Query results formatted for AI analysis (limited to 20 rows for readability)
    """
    rls_user_id = get_rls_user_id(ctx)
    
    try:
        logger.info(f"Executing query for user: {rls_user_id}")
        logger.debug(f"Query: {postgresql_query[:100]}...")
        
        result = await db_provider.execute_query(postgresql_query, rls_user_id)
        return result
    except Exception as e:
        logger.error(f"Error executing database query: {e}")
        return f"Error executing database query: {e!s}"

@mcp.tool()
async def get_current_utc_date(ctx: Context) -> str:
    """
    Get the current UTC date and time in ISO format.
    
    Useful for time-sensitive queries and date-based analysis.
    
    Returns:
        Current UTC date/time in ISO format (YYYY-MM-DDTHH:MM:SS.fffffZ)
    """
    try:
        result = await db_provider.get_current_utc_date()
        logger.debug(f"Current UTC date retrieved: {result}")
        return result
    except Exception as e:
        logger.error(f"Error getting current UTC date: {e}")
        return f"Error getting current UTC date: {e!s}"

# เดเดชเตเดฒเดฟเดเตเดเตเดทเตป เดฒเตเดซเตโเดธเตเดเตเดเดฟเตพ เดฎเดพเดจเตเดเตเดฎเตเดจเตเดฑเต
@asynccontextmanager
async def lifespan(app):
    """Manage application startup and shutdown."""
    logger.info("Starting Zava Retail MCP Server...")
    
    try:
        # เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดเดฃเดเตเดทเตป เดชเตเตพ เดเดฐเดเดญเดฟเดเตเดเตเด
        await db_provider.create_pool()
        logger.info("Database connection pool initialized")
        
        # เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดเดฃเดเตเดเดฟเดตเดฟเดฑเตเดฑเดฟ เดชเดฐเดฟเดถเตเดงเดฟเดเตเดเตเด
        health_status = await db_provider.health_check()
        if health_status["status"] != "healthy":
            logger.error(f"Database health check failed: {health_status}")
            raise Exception("Database not healthy")
        
        logger.info("MCP Server startup complete")
        yield
        
    except Exception as e:
        logger.error(f"Startup failed: {e}")
        raise
    finally:
        # เดเตเดฒเตเตปเดเดชเตเดชเต
        logger.info("Shutting down MCP Server...")
        await db_provider.close_pool()
        logger.info("MCP Server shutdown complete")

# เดธเตเตผเดตเตผ เดเดชเตเดฒเดฟเดเตเดเตเดทเตป เดเตเดฐเดฎเตเดเดฐเดฟเดเตเดเตเด
def create_app():
    """Create and configure the MCP server application."""
    
    # FastMCP เดเดชเตเดชเต เดเตปเดธเตเดฑเตเดฑเตปเดธเต เดจเตเดเตเด
    app = mcp.sse_app()
    
    # เดฒเตเดซเตโเดธเตเดเตเดเดฟเตพ เดฎเดพเดจเตเดเตเดฎเตเดจเตเดฑเต เดธเดเตเดเดฎเดพเดเตเดเตเด
    app.router.lifespan_context = lifespan
    
    # เดธเดเตเดตเดฎเดพเดเตเดเดฟเดฏเดพเตฝ เดนเตเตฝเดคเตเดคเต เดเตเดเตเดเต เดเตปเดกเตโเดชเตเดฏเดฟเดจเตเดฑเตเดเตพ เดเตเตผเดเตเดเตเด
    if config.server.enable_health_check:
        setup_health_endpoints(app, db_provider)
    
    # เดธเดเตเดตเดฎเดพเดเตเดเดฟเดฏเดพเตฝ CORS เดเตเดฐเดฎเตเดเดฐเดฟเดเตเดเตเด
    if config.server.enable_cors:
        from fastapi.middleware.cors import CORSMiddleware
        app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],  # เดเดคเตเดชเดพเดฆเดจเดคเตเดคเดฟเดจเดพเดฏเดฟ เดเดจเตเดฏเตเดเตเดฏเดฎเดพเดฏเดฟ เดเตเดฐเดฎเตเดเดฐเดฟเดเตเดเตเด
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    logger.info(f"MCP Server configured - CORS: {config.server.enable_cors}, Health: {config.server.enable_health_check}")
    
    return app

# เดเดชเตเดฒเดฟเดเตเดเตเดทเตป เดเตปเดธเตเดฑเตเดฑเตปเดธเต เดธเตเดทเตเดเดฟเดเตเดเตเด
app = create_app()

# เดตเดฟเดเดธเดจเดคเตเดคเดฟเดจเตเดณเตเดณ เดชเตเดฐเดงเดพเดจ เดชเตเดฐเดตเตเดถเดจ เดชเตเดฏเดฟเดจเตเดฑเต
if __name__ == "__main__":
    import uvicorn
    
    logger.info(f"Starting development server on {config.server.host}:{config.server.port}")
    
    uvicorn.run(
        "sales_analysis:app",
        host=config.server.host,
        port=config.server.port,
        reload=True,
        log_level=config.server.log_level.lower()
    )
```

### เดชเตเดฐเดงเดพเดจ MCP เดธเตเตผเดตเตผ เดซเตเดเตเดเดฑเตเดเตพ

- **เดเตเตพ เดฐเดเดฟเดธเตเดเตเดฐเตเดทเตป**: เดเตเดชเตเดชเต เดธเตเดซเตเดฑเตเดฑเดฟเดฏเตเดเตเดฏเตเดณเตเดณ เดกเดฟเดเตเดฒเดฑเตเดฑเตเดฑเตเดตเต เดเตเตพ เดจเดฟเตผเดตเดเดจเดเตเดเตพ  
- **RLS เดเตเตบเดเตเดเตเดธเตเดฑเตเดฑเต เดฎเดพเดจเตเดเตเดฎเตเดจเตเดฑเต**: เดเดเตเดเตเดฎเดพเดฑเตเดฑเดฟเดเต เดฏเตเดธเตผ เดเดกเดจเตเดฑเดฟเดฑเตเดฑเดฟ เดเดเตเดธเตเดเตเดฐเดพเดเตเดทเดจเตเด เดเตเตบเดเตเดเตเดธเตเดฑเตเดฑเต เดธเตเดฑเตเดฑเดฟเดเดเตเด  
- **เดชเดฟเดถเดเต เดเตเดเดพเดฐเตเดฏเด เดเตเดฏเตเดฏเตฝ**: เดเดชเดฏเตเดเตเดคเต เดธเตเดนเตเดฆ เดชเดฟเดถเดเต เดธเดจเตเดฆเตเดถเดเตเดเดณเตเดเต เดธเดฎเดเตเดฐเดฎเดพเดฏ เดชเดฟเดถเดเต เดฎเดพเดจเตเดเตเดฎเตเดจเตเดฑเต  
- **เดฒเตเดซเตโเดธเตเดเตเดเดฟเตพ เดฎเดพเดจเตเดเตเดฎเตเดจเตเดฑเต**: เดถเดฐเดฟเดฏเดพเดฏ เดธเตเดฑเตเดฑเดพเตผเดเตเดเดชเตเดชเต/เดทเดเตเดเตเดกเตเตบ, เดฑเดฟเดธเตเดดเตโเดธเต เดเตเดฒเตเดจเดชเตเดชเต  
- **เดนเตเตฝเดคเตเดคเต เดฎเตเดฃเดฟเดฑเตเดฑเดฑเดฟเดเดเต**: เดเตปเดฌเดฟเตฝเดฑเตเดฑเต เดนเตเตฝเดคเตเดคเต เดเตเดเตเดเต เดเดจเตเดฑเตเดชเตเดฏเดฟเดจเตเดฑเตเดเตพ  
- **เดกเตเดตเดฒเดชเตเดชเตเดฎเตเดจเตเดฑเต เดชเดฟเดจเตเดคเตเดฃ**: เดนเตเดเตเดเต เดฑเตเดฒเตเดกเต, เดกเตเดฌเดเตเดเดฟเดเดเต เดเดดเดฟเดตเตเดเตพ

## ๐ฅ เดนเตเตฝเดคเตเดคเต เดฎเตเดฃเดฟเดฑเตเดฑเดฑเดฟเดเดเต

### เดนเตเตฝเดคเตเดคเต เดเตเดเตเดเต เดจเดเดชเตเดชเดพเดเตเดเตฝ (`health_check.py`)

```python
# mcp_server/health_check.py
"""
Health check endpoints for monitoring MCP server status.
"""
import logging
from typing import Dict, Any
from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse

logger = logging.getLogger(__name__)

def setup_health_endpoints(app: FastAPI, db_provider) -> None:
    """Add health check endpoints to the FastAPI application."""
    
    @app.get("/health")
    async def health_check() -> JSONResponse:
        """Basic health check endpoint."""
        return JSONResponse(
            status_code=200,
            content={
                "status": "healthy",
                "service": "zava-retail-mcp-server",
                "timestamp": await db_provider.get_current_utc_date()
            }
        )
    
    @app.get("/health/detailed")
    async def detailed_health_check() -> JSONResponse:
        """Detailed health check including database connectivity."""
        health_status = {
            "service": "zava-retail-mcp-server",
            "status": "healthy",
            "components": {}
        }
        
        overall_healthy = True
        
        # เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดชเดฐเดฟเดถเตเดงเดฟเดเตเดเตเด
        try:
            db_health = await db_provider.health_check()
            health_status["components"]["database"] = db_health
            
            if db_health["status"] != "healthy":
                overall_healthy = False
                
        except Exception as e:
            health_status["components"]["database"] = {
                "status": "unhealthy",
                "error": str(e)
            }
            overall_healthy = False
        
        # เดฎเตเดคเตเดคเด เดจเดฟเดฒ เดเดชเตเดกเตเดฑเตเดฑเต เดเตเดฏเตเดฏเตเด
        if not overall_healthy:
            health_status["status"] = "unhealthy"
        
        status_code = 200 if overall_healthy else 503
        
        return JSONResponse(
            status_code=status_code,
            content=health_status
        )
    
    @app.get("/health/ready")
    async def readiness_check() -> JSONResponse:
        """Kubernetes readiness probe endpoint."""
        try:
            # เดชเตเดฐเดงเดพเดจ เดชเตเดฐเดตเตผเดคเตเดคเดจเด เดชเดฐเตเดเตเดทเดฟเดเตเดเตเด
            db_health = await db_provider.health_check()
            
            if db_health["status"] != "healthy":
                raise HTTPException(status_code=503, detail="Database not ready")
            
            return JSONResponse(
                status_code=200,
                content={"status": "ready"}
            )
            
        except Exception as e:
            logger.error(f"Readiness check failed: {e}")
            raise HTTPException(status_code=503, detail="Service not ready")
    
    @app.get("/health/live")
    async def liveness_check() -> JSONResponse:
        """Kubernetes liveness probe endpoint."""
        return JSONResponse(
            status_code=200,
            content={"status": "alive"}
        )
    
    logger.info("Health check endpoints configured")
```

## ๐งช เดจเดฟเดเตเดเดณเตเดเต MCP เดธเตเตผเดตเตผ เดเตเดธเตเดฑเตเดฑเดฟเดเดเต

### เดฒเตเดเตเดเตฝ เดเตเดธเตเดฑเตเดฑเดฟเดเดเต

1. **MCP เดธเตเตผเดตเตผ เดเดฐเดเดญเดฟเดเตเดเตเด**:  
   ```bash
   # เดตเตเตผเดเตเดตเตฝ เดเตปเดตเดฏเตเตบเดฎเตเดจเตเดฑเต เดธเดเตเดตเดฎเดพเดเตเดเตเด
   source mcp-env/bin/activate  # macOS/Linux
   # mcp-env\Scripts\activate   # Windows
   
   # เดธเตเตผเดตเตผ เดเดฐเดเดญเดฟเดเตเดเตเด
   cd mcp_server
   python sales_analysis.py
   ```

2. **เดนเตเตฝเดคเตเดคเต เดเดจเตเดฑเตเดชเตเดฏเดฟเดจเตเดฑเตเดเตพ เดเตเดธเตเดฑเตเดฑเต เดเตเดฏเตเดฏเตเด**:  
   ```bash
   # เดเดเดฟเดธเตเดฅเดพเดจ เดเดฐเตเดเตเดฏ เดชเดฐเดฟเดถเตเดงเดจ
   curl http://localhost:8000/health
   
   # เดตเดฟเดถเดฆเดฎเดพเดฏ เดเดฐเตเดเตเดฏ เดชเดฐเดฟเดถเตเดงเดจ
   curl http://localhost:8000/health/detailed
   ```

3. **MCP เดเตเดณเตเดเตพ เดเตเดธเตเดฑเตเดฑเต เดเตเดฏเตเดฏเตเด**:  
   ```bash
   # เดฒเดญเตเดฏเดฎเดพเดฏ เดเดชเดเดฐเดฃเดเตเดเดณเตเดเต เดชเดเตเดเดฟเด
   curl -X POST http://localhost:8000/mcp \
     -H "Content-Type: application/json" \
     -H "x-rls-user-id: 00000000-0000-0000-0000-000000000000" \
     -d '{"method": "tools/list", "params": {}}'
   
   # เดชเดเตเดเดฟเดเดฏเตเดเต เดธเตเดเตเดฎเดเตพ เดจเตเดเตเด
   curl -X POST http://localhost:8000/mcp \
     -H "Content-Type: application/json" \
     -H "x-rls-user-id: 00000000-0000-0000-0000-000000000000" \
     -d '{
       "method": "tools/call",
       "params": {
         "name": "get_multiple_table_schemas",
         "arguments": {
           "table_names": ["retail.stores", "retail.products"]
         }
       }
     }'
   ```

### VS เดเตเดกเต เดเดจเตเดฑเดเตเดฐเตเดทเตป เดเตเดธเตเดฑเตเดฑเดฟเดเดเต

1. **VS เดเตเดกเต MCP เดเตเตบเดซเดฟเดเตผ เดเตเดฏเตเดฏเตเด**:  
   ```json
   // .vscode/mcp.json
   {
       "servers": {
           "zava-retail-test": {
               "url": "http://127.0.0.1:8000/mcp",
               "type": "http",
               "headers": {"x-rls-user-id": "00000000-0000-0000-0000-000000000000"}
           }
       }
   }
   ```

2. **AI เดเดพเดฑเตเดฑเดฟเตฝ เดเตเดธเตเดฑเตเดฑเต เดเตเดฏเตเดฏเตเด**:  
   - VS เดเตเดกเต AI เดเดพเดฑเตเดฑเต เดคเตเดฑเดเตเดเตเด  
   - `#zava` เดเตเดชเตเดชเต เดเตเดฏเตเดคเต เดจเดฟเดเตเดเดณเตเดเต เดธเตเตผเดตเตผ เดคเดฟเดฐเดเตเดเตเดเตเดเตเดเตเด  
   - เดเตเดฆเดฟเดเตเดเตเด: "เดเดจเตเดคเตเดฒเตเดฒเดพ เดเตเดฌเดฟเดณเตเดเตพ เดฒเดญเตเดฏเดฎเดพเดฃเต?"  
   - เดเตเดฆเดฟเดเตเดเตเด: "เดเตผเดกเดฑเตเดเดณเตเดเต เดเดฃเตเดฃเด เดเดจเตเดธเดฐเดฟเดเตเดเต เดเตเดชเตเดชเต 5 เดธเตเดฑเตเดฑเตเดฑเตเดเตพ เดเดพเดฃเดฟเดเตเดเตเด"

### เดฏเตเดฃเดฟเดฑเตเดฑเต เดเตเดธเตเดฑเตเดฑเดฟเดเดเต

เดธเดฎเดเตเดฐเดฎเดพเดฏ เดฏเตเดฃเดฟเดฑเตเดฑเต เดเตเดธเตเดฑเตเดฑเตเดเตพ เดธเตเดทเตเดเดฟเดเตเดเตเด:

```python
# เดเตเดธเตเดฑเตเดฑเตเดเตพ/test_mcp_server.py
import pytest
import asyncio
from mcp_server.sales_analysis_postgres import PostgreSQLSchemaProvider
from mcp_server.config import config

@pytest.mark.asyncio
async def test_database_connection():
    """Test database connectivity."""
    db = PostgreSQLSchemaProvider()
    
    try:
        await db.create_pool()
        health = await db.health_check()
        assert health["status"] == "healthy"
    finally:
        await db.close_pool()

@pytest.mark.asyncio
async def test_table_schema_retrieval():
    """Test table schema retrieval."""
    db = PostgreSQLSchemaProvider()
    
    try:
        await db.create_pool()
        schema = await db.get_table_schema("retail.stores", "00000000-0000-0000-0000-000000000000")
        
        assert schema["table_name"] == "retail.stores"
        assert len(schema["columns"]) > 0
        
    finally:
        await db.close_pool()

@pytest.mark.asyncio
async def test_query_execution():
    """Test query execution with RLS."""
    db = PostgreSQLSchemaProvider()
    
    try:
        await db.create_pool()
        result = await db.execute_query(
            "SELECT COUNT(*) as store_count FROM retail.stores",
            "00000000-0000-0000-0000-000000000000"
        )
        
        assert "store_count" in result
        
    finally:
        await db.close_pool()
```

## ๐ฏ เดชเตเดฐเดงเดพเดจ เดชเดเดจเดเตเดเตพ

เด เดฒเดพเดฌเต เดชเตเตผเดคเตเดคเดฟเดฏเดพเดเตเดเดฟเดฏ เดถเตเดทเด, เดจเดฟเดเตเดเตพเดเตเดเต เดเดฃเตเดเดพเดเดฃเด:

โ **เดชเตเดฐเดตเตผเดคเตเดคเดจเดเตเดทเดฎเดฎเดพเดฏ MCP เดธเตเตผเดตเตผ**: เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดเดจเตเดฑเดเตเดฐเตเดทเดจเตเดเตเดเตเดเดฟเดฏ FastMCP เดธเตเตผเดตเตผ  
โ **เดเตเตบเดซเดฟเดเดฑเตเดทเตป เดฎเดพเดจเตเดเตเดฎเตเดจเตเดฑเต**: เดถเดเตเดคเดฎเดพเดฏ เดเตปเดตเดฏเตเตบเดฎเตเดจเตเดฑเต เดเดเดฟเดธเตเดฅเดพเดจเดฎเดพเดเตเดเดฟเดฏ เดเตเตบเดซเดฟเดเดฑเตเดทเตป  
โ **เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดฒเตเดฏเตผ**: เดเดฃเดเตเดทเตป เดชเตเดฒเดฟเดเดเตเดเตเดเตเดเดฟเดฏ PostgreSQL เดเดจเตเดฑเดเตเดฐเตเดทเตป  
โ **MCP เดเตเดณเตเดเตพ**: เดธเตเดเตเดฎ เดเตปเดเตเดฐเตเดธเตเดชเตเดเตเดทเดจเตเด เดเตเดตเดฑเดฟ เดเดเตเดธเดฟเดเตเดฏเตเดทเดจเตเด เดเตเดณเตเดเตพ  
โ **RLS เดเดจเตเดฑเดเตเดฐเตเดทเตป**: เดฑเต เดฒเตเดตเตฝ เดธเตเดเตเดฏเตเดฐเดฟเดฑเตเดฑเดฟ เดเตเตบเดเตเดเตเดธเตเดฑเตเดฑเต เดฎเดพเดจเตเดเตเดฎเตเดจเตเดฑเต  
โ **เดนเตเตฝเดคเตเดคเต เดฎเตเดฃเดฟเดฑเตเดฑเดฑเดฟเดเดเต**: เดธเดฎเดเตเดฐเดฎเดพเดฏ เดนเตเตฝเดคเตเดคเต เดเตเดเตเดเต เดเดจเตเดฑเตเดชเตเดฏเดฟเดจเตเดฑเตเดเตพ  
โ **เดเตเดธเตเดฑเตเดฑเดฟเดเดเต เดคเดจเตเดคเตเดฐเด**: เดฒเตเดเตเดเตฝ เดเตเดธเตเดฑเตเดฑเดฟเดเดเตเด VS เดเตเดกเต เดเดจเตเดฑเดเตเดฐเตเดทเดจเตเด

## ๐ เดเดเตเดคเตเดคเดคเต เดเดจเตเดคเดพเดฃเต

**[Lab 06: Tool Development](../06-Tools/README.md)** เดคเตเดเตผเดจเตเดจเต:

- เดจเดฟเดเตเดเดณเตเดเต MCP เดเตเตพ เดถเตเดเดฐเด เดตเดฟเดชเตเดฒเตเดเดฐเดฟเดเตเดเตเด  
- เดเดกเตเดตเดพเตปเดธเตเดกเต เดเตเดตเดฑเดฟ เดชเดพเดฑเตเดฑเตเดฃเตเดเตพ เดจเดเดชเตเดชเดพเดเตเดเตเด  
- เดกเดพเดฑเตเดฑ เดตเดพเดฒเดฟเดกเตเดทเตป, เดเตเดฐเดพเตปเดธเตเดซเตผเดฎเตเดทเตป เดเตเตผเดเตเดเตเด  
- เดชเตเดฐเดคเตเดฏเตเด เดเดจเดฒเดฟเดฑเตเดฑเดฟเดเตเดธเต เดเตเดณเตเดเตพ เดธเตเดทเตเดเดฟเดเตเดเตเด

## ๐ เดเดงเดฟเด เดธเตเดฐเตเดคเดธเตเดเตพ

### FastMCP เดซเตเดฐเตเดฏเดฟเดเดตเตผเดเตเดเต  
- [FastMCP เดกเตเดเตเดฏเตเดฎเตเดจเตเดฑเตเดทเตป](https://github.com/modelcontextprotocol/python-sdk) - เดเดฆเตเดฏเตเดเดฟเด FastMCP เดเตเดกเต  
- [MCP เดธเตเดชเตเดธเดฟเดซเดฟเดเตเดเตเดทเตป](https://modelcontextprotocol.io/docs/) - เดชเตเดฐเตเดเตเดเตเดเตเดเตเตพ เดธเตเดชเตเดธเดฟเดซเดฟเดเตเดเตเดทเตป  
- [เดเตเตพ เดกเตเดตเดฒเดชเตเดชเตเดฎเตเดจเตเดฑเต เดเตเดกเต](https://modelcontextprotocol.io/docs/tools/) - MCP เดเตเดณเตเดเตพ เดธเตเดทเตเดเดฟเดเตเดเตฝ

### เดกเดพเดฑเตเดฑเดพเดฌเตเดธเต เดเดจเตเดฑเดเตเดฐเตเดทเตป  
- [asyncpg เดกเตเดเตเดฏเตเดฎเตเดจเตเดฑเตเดทเตป](https://magicstack.github.io/asyncpg/current/) - PostgreSQL เดเดธเดฟเดเตเดเต เดกเตเดฐเตเดตเตผ  
- [เดเดฃเดเตเดทเตป เดชเตเดฒเดฟเดเดเต เดฎเดฟเดเดเตเด เดชเตเดฐเดพเดเตเดเตเดธเตเดเตพ](https://www.postgresql.org/docs/current/runtime-config-connection.html) - PostgreSQL เดเตเดฏเตเดฃเดฟเดเดเต  
- [เดฑเต เดฒเตเดตเตฝ เดธเตเดเตเดฏเตเดฐเดฟเดฑเตเดฑเดฟ เดเตเดกเต](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) - RLS เดจเดเดชเตเดชเดพเดเตเดเตฝ

### FastAPI เดชเดพเดฑเตเดฑเตเดฃเตเดเตพ  
- [FastAPI เดกเตเดเตเดฏเตเดฎเตเดจเตเดฑเตเดทเตป](https://fastapi.tiangolo.com/) - เดตเตเดฌเต เดซเตเดฐเตเดฏเดฟเดเดตเตผเดเตเดเต เดฑเดซเดฑเตปเดธเต  
- [เดกเดฟเดชเตเดชเตเตปเดกเตปเดธเดฟ เดเตปเดเดเตเดทเตป](https://fastapi.tiangolo.com/tutorial/dependencies/) - FastAPI เดชเดพเดฑเตเดฑเตเดฃเตเดเตพ  
- [เดฌเดพเดเตเดเตเดเตเดฐเตเดฃเตเดเต เดเดพเดธเตเดเตเดเตพ](https://fastapi.tiangolo.com/tutorial/background-tasks/) - เดเดธเดฟเดเตเดเต เดเดพเดธเตโเดเต เดฎเดพเดจเตเดเตเดฎเตเดจเตเดฑเต

---

**เดเดเตเดคเตเดคเดคเต**: เดจเดฟเดเตเดเดณเตเดเต เดเตเดณเตเดเตพ เดตเดฟเดชเตเดฒเตเดเดฐเดฟเดเตเดเดพเตป เดคเดฏเตเดฏเดพเดฑเดพเดฃเต? **[Lab 06: Tool Development](../06-Tools/README.md)** เดคเตเดเตผเดจเตเดจเต.

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**เดเดธเตเดฏเดพ**:  
เด เดฐเตเด AI เดตเดฟเดตเตผเดคเตเดคเดจ เดธเตเดตเดจเด [Co-op Translator](https://github.com/Azure/co-op-translator) เดเดชเดฏเตเดเดฟเดเตเดเต เดตเดฟเดตเตผเดคเตเดคเดจเด เดเตเดฏเตเดคเดคเดพเดฃเต. เดจเดพเด เดเตเดคเตเดฏเดคเดฏเตเดเตเดเต เดถเตเดฐเดฎเดฟเดเตเดเดฟเดเตเดเตเดฃเตเดเตเดเตเดเดฟเดฒเตเด, เดธเตเดตเดฏเด เดชเตเดฐเดตเตผเดคเตเดคเดฟเดเตเดเตเดจเตเดจ เดตเดฟเดตเตผเดคเตเดคเดจเดเตเดเดณเดฟเตฝ เดชเดฟเดถเดเตเดเตพ เดเดฒเตเดฒเตเดเตเดเดฟเตฝ เดคเตเดฑเตเดฑเตเดเตพ เดเดฃเตเดเดพเดเดพเดฎเตเดจเตเดจเต เดฆเดฏเดตเดพเดฏเดฟ เดถเตเดฐเดฆเตเดงเดฟเดเตเดเตเด. เดเดคเดฟเดจเตเดฑเต เดฎเดพเดคเตเดญเดพเดทเดฏเดฟเดฒเตเดณเตเดณ เดฏเดฅเดพเตผเดคเตเดฅ เดฐเตเด เดเดงเดฟเดเดพเดฐเดชเดฐเดฎเดพเดฏ เดเดฑเดตเดฟเดเดฎเดพเดฏเดฟ เดเดฃเดเตเดเดพเดเตเดเดชเตเดชเตเดเดฃเด. เดจเดฟเตผเดฃเดพเดฏเด เดตเดฟเดตเดฐเดเตเดเตพเดเตเดเต, เดชเตเดฐเตเดซเดทเดฃเตฝ เดฎเดจเตเดทเตเดฏ เดตเดฟเดตเตผเดคเตเดคเดจเด เดถเตเดชเดพเตผเดถ เดเตเดฏเตเดฏเดชเตเดชเตเดเตเดจเตเดจเต. เด เดตเดฟเดตเตผเดคเตเดคเดจเด เดเดชเดฏเตเดเดฟเดเตเดเตเดจเตเดจเดคเดฟเตฝ เดจเดฟเดจเตเดจเตเดฃเตเดเดพเดเตเดจเตเดจ เดเดคเตเดเตเดเดฟเดฒเตเด เดคเตเดฑเตเดฑเดฟเดฆเตเดงเดพเดฐเดฃเดเตพเดเตเดเต เดคเตเดฑเตเดฑเดพเดฏ เดตเตเดฏเดพเดเตเดฏเดพเดจเดเตเดเตพเดเตเดเต เดเดเตเดเตพ เดเดคเตเดคเดฐเดตเดพเดฆเดฟเดเดณเดฒเตเดฒ.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->