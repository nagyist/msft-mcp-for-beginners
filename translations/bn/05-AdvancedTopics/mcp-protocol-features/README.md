# MCP ржкрзНрж░рзЛржЯрзЛржХрж▓ ржмрзИрж╢рж┐рж╖рзНржЯрзНржп ржЧржнрзАрж░ржнрж╛ржмрзЗ

ржПржЗ ржЧрж╛ржЗржбржЯрж┐ ржорзМрж▓рж┐ржХ ржЯрзБрж▓ ржПржмржВ рж░рж┐рж╕рзЛрж░рзНрж╕ ржкрж░рж┐ржЪрж╛рж▓ржирж╛рж░ ржмрж╛ржЗрж░рзЗ ржЙржирзНржиржд MCP ржкрзНрж░рзЛржЯрзЛржХрж▓ ржмрзИрж╢рж┐рж╖рзНржЯрзНржпржЧрзБрж▓рзЛ ржЕржирзНржмрзЗрж╖ржг ржХрж░рзЗред ржПржЗ ржмрзИрж╢рж┐рж╖рзНржЯрзНржпржЧрзБрж▓рж┐ ржмрзЛржЭрж╛ ржЖржкржирж╛ржХрзЗ ржЖрж░ржУ ржжрзГржврж╝, ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА-ржмрж╛ржирзНржзржм, ржПржмржВ ржкрзНрж░рзЛржбрж╛ржХрж╢ржи-рж░рзЗржбрж┐ MCP рж╕рж╛рж░рзНржнрж╛рж░ рждрзИрж░рж┐ ржХрж░рждрзЗ рж╕рж╛рж╣рж╛ржпрзНржп ржХрж░рзЗред

## ржХрж╛ржнрж╛рж░ ржХрж░рж╛ ржмрзИрж╢рж┐рж╖рзНржЯрзНржпрж╕ржорзВрж╣

1. **ржкрзНрж░ржЧрждрж┐ ржмрж┐ржЬрзНржЮржкрзНрждрж┐** - ржжрзАрж░рзНржШржорзЗржпрж╝рж╛ржжрзА ржЕржкрж╛рж░рзЗрж╢ржиржЧрзБрж▓рзЛрж░ ржЬржирзНржп ржкрзНрж░ржЧрждрж┐ рж░рж┐ржкрзЛрж░рзНржЯ ржХрж░рж╛
2. **ржЕржирзБрж░рзЛржз ржмрж╛рждрж┐рж▓ржХрж░ржг** - ржХрзНрж▓рж╛ржпрж╝рзЗржирзНржЯржжрзЗрж░ ржЪрж▓ржорж╛ржи ржЕржирзБрж░рзЛржз ржмрж╛рждрж┐рж▓ ржХрж░рж╛рж░ ржЕржирзБржорждрж┐ ржжрзЗржУржпрж╝рж╛
3. **рж░рж┐рж╕рзЛрж░рзНрж╕ ржЯрзЗржоржкрзНрж▓рзЗржЯ** - ржкрзНржпрж╛рж░рж╛ржорж┐ржЯрж╛рж░ рж╕рж╣ ржЧрждрж┐рж╢рзАрж▓ рж░рж┐рж╕рзЛрж░рзНрж╕ URI
4. **рж╕рж╛рж░рзНржнрж╛рж░ рж▓рж╛ржЗржлрж╕рж╛ржЗржХрзЗрж▓ ржЗржнрзЗржирзНржЯрж╕** - рж╕ржарж┐ржХ ржЗржирж┐рж╢рж┐ржпрж╝рж╛рж▓рж╛ржЗржЬрзЗрж╢ржи ржПржмржВ рж╢рж╛ржЯржбрж╛ржЙржи
5. **рж▓ржЧрж┐ржВ ржирж┐ржпрж╝ржирзНрждрзНрж░ржг** - рж╕рж╛рж░рзНржнрж╛рж░-рж╕рж╛ржЗржб рж▓ржЧрж┐ржВ ржХржиржлрж┐ржЧрж╛рж░рзЗрж╢ржи
6. **рждрзНрж░рзБржЯрж┐ ржкрж░рж┐ржЪрж╛рж▓ржирж╛рж░ ржкрзНржпрж╛ржЯрж╛рж░рзНржи** - рж╕ржЩрзНржЧрждрж┐ржкрзВрж░рзНржг рждрзНрж░рзБржЯрж┐ ржкрзНрж░рждрж┐ржХрзНрж░рж┐ржпрж╝рж╛

---

## рзз. ржкрзНрж░ржЧрждрж┐ ржмрж┐ржЬрзНржЮржкрзНрждрж┐

рж╕рзЗржЗ ржЕржкрж╛рж░рзЗрж╢ржиржЧрзБрж▓рзЛрж░ ржЬржирзНржп ржпрзЗржЧрзБрж▓рзЛ рж╕ржоржпрж╝ ржирзЗржпрж╝ (ржбрзЗржЯрж╛ ржкрзНрж░рж╕рзЗрж╕рж┐ржВ, ржлрж╛ржЗрж▓ ржбрж╛ржЙржирж▓рзЛржб, API ржХрж▓), ржкрзНрж░ржЧрждрж┐ ржмрж┐ржЬрзНржЮржкрзНрждрж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржжрзЗрж░ ржЖржкржбрзЗржЯ рж░рж╛ржЦрзЗред

### ржПржЯрж┐ ржХрж┐ржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ

```mermaid
sequenceDiagram
    participant Client
    participant Server
    
    Client->>Server: tools/call (ржжрзАрж░рзНржШ ржЕржкрж╛рж░рзЗрж╢ржи)
    Server-->>Client: notification: ржЕржЧрзНрж░ржЧрждрж┐ рззрзж%
    Server-->>Client: notification: ржЕржЧрзНрж░ржЧрждрж┐ рзлрзж%
    Server-->>Client: notification: ржЕржЧрзНрж░ржЧрждрж┐ рзпрзж%
    Server->>Client: ржлрж▓рж╛ржлрж▓ (рж╕ржорзНржкрзВрж░рзНржг)
```
### ржкрж╛ржЗржержи ржЗржоржкрзНрж▓рж┐ржорзЗржирзНржЯрзЗрж╢ржи

```python
from mcp.server import Server, NotificationOptions
from mcp.types import ProgressNotification
import asyncio

app = Server("progress-server")

@app.tool()
async def process_large_file(file_path: str, ctx) -> str:
    """Process a large file with progress updates."""
    
    # ржЕржЧрзНрж░ржЧрждрж┐ рж╣рж┐рж╕рж╛ржм ржХрж░рж╛рж░ ржЬржирзНржп ржлрж╛ржЗрж▓рзЗрж░ ржЖржХрж╛рж░ ржирж┐ржи
    file_size = os.path.getsize(file_path)
    processed = 0
    
    with open(file_path, 'rb') as f:
        while chunk := f.read(8192):
            # ржЪрж╛ржЩрзНржХ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ржХрж░ржг ржХрж░рзБржи
            await process_chunk(chunk)
            processed += len(chunk)
            
            # ржЕржЧрзНрж░ржЧрждрж┐рж░ ржмрж┐ржЬрзНржЮржкрзНрждрж┐ ржкрж╛ржарж╛ржи
            progress = (processed / file_size) * 100
            await ctx.send_notification(
                ProgressNotification(
                    progressToken=ctx.request_id,
                    progress=progress,
                    total=100,
                    message=f"Processing: {progress:.1f}%"
                )
            )
    
    return f"Processed {file_size} bytes"

@app.tool()
async def batch_operation(items: list[str], ctx) -> str:
    """Process multiple items with progress."""
    
    results = []
    total = len(items)
    
    for i, item in enumerate(items):
        result = await process_item(item)
        results.append(result)
        
        # ржкрзНрж░рждрж┐ ржЖржЗржЯрзЗржорзЗрж░ ржкрж░рзЗ ржЕржЧрзНрж░ржЧрждрж┐ рж░рж┐ржкрзЛрж░рзНржЯ ржХрж░рзБржи
        await ctx.send_notification(
            ProgressNotification(
                progressToken=ctx.request_id,
                progress=i + 1,
                total=total,
                message=f"Processed {i + 1}/{total}: {item}"
            )
        )
    
    return f"Completed {total} items"
```

### ржЯрж╛ржЗржкрж╕рзНржХрзНрж░рж┐ржкрзНржЯ ржЗржоржкрзНрж▓рж┐ржорзЗржирзНржЯрзЗрж╢ржи

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";

server.setRequestHandler(CallToolSchema, async (request, extra) => {
  const { name, arguments: args } = request.params;
  
  if (name === "process_data") {
    const items = args.items as string[];
    const results = [];
    
    for (let i = 0; i < items.length; i++) {
      const result = await processItem(items[i]);
      results.push(result);
      
      // ржЕржЧрзНрж░ржЧрждрж┐ ржирзЛржЯрж┐ржлрж┐ржХрзЗрж╢ржи ржкрж╛ржарж╛ржи
      await extra.sendNotification({
        method: "notifications/progress",
        params: {
          progressToken: request.id,
          progress: i + 1,
          total: items.length,
          message: `Processing item ${i + 1}/${items.length}`
        }
      });
    }
    
    return { content: [{ type: "text", text: JSON.stringify(results) }] };
  }
});
```

### ржХрзНрж▓рж╛ржпрж╝рзЗржирзНржЯ рж╣рзНржпрж╛ржирзНржбрж▓рж┐ржВ (ржкрж╛ржЗржержи)

```python
async def handle_progress(notification):
    """Handle progress notifications from server."""
    params = notification.params
    print(f"Progress: {params.progress}/{params.total} - {params.message}")

# рж░рзЗржЬрж┐рж╕рзНржЯрж╛рж░ рж╣рзНржпрж╛ржирзНржбрж▓рж╛рж░
session.on_notification("notifications/progress", handle_progress)

# ржЯрзБрж▓ ржХрж▓ ржХрж░рзБржи (ржЕржЧрзНрж░ржЧрждрж┐ ржЖржкржбрзЗржЯржЧрзБрж▓рж┐ рж╣рзНржпрж╛ржирзНржбрж▓рж╛рж░рзЗрж░ ржорж╛ржзрзНржпржорзЗ ржЖрж╕ржмрзЗ)
result = await session.call_tool("process_large_file", {"file_path": "/data/large.csv"})
```

---

## рзи. ржЕржирзБрж░рзЛржз ржмрж╛рждрж┐рж▓ржХрж░ржг

ржХрзНрж▓рж╛ржпрж╝рзЗржирзНржЯржжрзЗрж░ ржПржоржи ржЕржирзБрж░рзЛржз ржмрж╛рждрж┐рж▓ ржХрж░рж╛рж░ ржЕржирзБржорждрж┐ ржжрж┐ржи ржпрж╛ ржЖрж░ ржжрж░ржХрж╛рж░ ржирзЗржЗ ржмрж╛ ржЕржирзЗржХ ржжрзЗрж░рж┐ ржХрж░ржЫрзЗред

### ржкрж╛ржЗржержи ржЗржоржкрзНрж▓рж┐ржорзЗржирзНржЯрзЗрж╢ржи

```python
from mcp.server import Server
from mcp.types import CancelledError
import asyncio

app = Server("cancellable-server")

@app.tool()
async def long_running_search(query: str, ctx) -> str:
    """Search that can be cancelled."""
    
    results = []
    
    try:
        for page in range(100):  # ржЕржирзЗржХ ржкрзГрж╖рзНржарж╛ржпрж╝ ржЕржирзБрж╕ржирзНржзрж╛ржи ржХрж░рзБржи
            # ржпрж╛ржЪрж╛ржЗ ржХрж░рзБржи ржпрзЗ ржмрж╛рждрж┐рж▓рзЗрж░ ржЕржирзБрж░рзЛржз ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрж┐рж▓ ржХрж┐ржирж╛
            if ctx.is_cancelled:
                raise CancelledError("Search cancelled by user")
            
            # ржкрзГрж╖рзНржарж╛ ржЕржирзБрж╕ржирзНржзрж╛ржирзЗрж░ ржЕржирзБржХрж░ржг ржХрж░рзБржи
            page_results = await search_page(query, page)
            results.extend(page_results)
            
            # ржЫрзЛржЯ ржмрж┐рж▓ржорзНржм ржмрж╛рждрж┐рж▓ ржкрж░рзАржХрзНрж╖рж╛ ржХрж░рж╛рж░ рж╕рзБржпрзЛржЧ ржжрзЗржпрж╝
            await asyncio.sleep(0.1)
            
    except CancelledError:
        # ржЖржВрж╢рж┐ржХ ржлрж▓рж╛ржлрж▓ ржлрзЗрж░ржд ржжрж┐ржи
        return f"Cancelled. Found {len(results)} results before cancellation."
    
    return f"Found {len(results)} total results"

@app.tool()
async def download_file(url: str, ctx) -> str:
    """Download with cancellation support."""
    
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            total_size = int(response.headers.get('content-length', 0))
            downloaded = 0
            chunks = []
            
            async for chunk in response.content.iter_chunked(8192):
                if ctx.is_cancelled:
                    return f"Download cancelled at {downloaded}/{total_size} bytes"
                
                chunks.append(chunk)
                downloaded += len(chunk)
            
            return f"Downloaded {downloaded} bytes"
```

### ржмрж╛рждрж┐рж▓ржХрж░ржг ржкрзНрж░рж╕ржЩрзНржЧ ржмрж╛рж╕рзНрждржмрж╛ржпрж╝ржи

```python
class CancellableContext:
    """Context object that tracks cancellation state."""
    
    def __init__(self, request_id: str):
        self.request_id = request_id
        self._cancelled = asyncio.Event()
        self._cancel_reason = None
    
    @property
    def is_cancelled(self) -> bool:
        return self._cancelled.is_set()
    
    def cancel(self, reason: str = "Cancelled"):
        self._cancel_reason = reason
        self._cancelled.set()
    
    async def check_cancelled(self):
        """Raise if cancelled, otherwise continue."""
        if self.is_cancelled:
            raise CancelledError(self._cancel_reason)
    
    async def sleep_or_cancel(self, seconds: float):
        """Sleep that can be interrupted by cancellation."""
        try:
            await asyncio.wait_for(
                self._cancelled.wait(),
                timeout=seconds
            )
            raise CancelledError(self._cancel_reason)
        except asyncio.TimeoutError:
            pass  # рж╕рзНржмрж╛ржнрж╛ржмрж┐ржХ рж╕ржоржпрж╝рж╕рзАржорж╛, ржЪрж╛рж▓рж┐ржпрж╝рзЗ ржпрж╛ржи
```

### ржХрзНрж▓рж╛ржпрж╝рзЗржирзНржЯ-рж╕рж╛ржЗржб ржмрж╛рждрж┐рж▓ржХрж░ржг

```python
import asyncio

async def search_with_timeout(session, query, timeout=30):
    """Search with automatic cancellation on timeout."""
    
    task = asyncio.create_task(
        session.call_tool("long_running_search", {"query": query})
    )
    
    try:
        result = await asyncio.wait_for(task, timeout=timeout)
        return result
    except asyncio.TimeoutError:
        # ржЕржирзБрж░рзЛржз ржмрж╛рждрж┐рж▓ ржХрж░рж╛
        await session.send_notification({
            "method": "notifications/cancelled",
            "params": {"requestId": task.request_id, "reason": "Timeout"}
        })
        return "Search timed out"
```

---

## рзй. рж░рж┐рж╕рзЛрж░рзНрж╕ ржЯрзЗржоржкрзНрж▓рзЗржЯ

рж░рж┐рж╕рзЛрж░рзНрж╕ ржЯрзЗржоржкрзНрж▓рзЗржЯ ржкрзНржпрж╛рж░рж╛ржорж┐ржЯрж╛рж░рж╕рж╣ ржЧрждрж┐рж╢рзАрж▓ URI рждрзИрж░рж┐ ржХрж░рждрзЗ ржжрзЗржпрж╝, ржпрж╛ API ржПржмржВ ржбрж╛ржЯрж╛ржмрзЗрж╕рзЗрж░ ржЬржирзНржп ржЙржкржпрзЛржЧрзАред

### ржЯрзЗржоржкрзНрж▓рзЗржЯ ржирж┐рж░рзНржзрж╛рж░ржг

```python
from mcp.server import Server
from mcp.types import ResourceTemplate

app = Server("template-server")

@app.list_resource_templates()
async def list_templates() -> list[ResourceTemplate]:
    """Return available resource templates."""
    return [
        ResourceTemplate(
            uriTemplate="db://users/{user_id}",
            name="User Profile",
            description="Fetch user profile by ID",
            mimeType="application/json"
        ),
        ResourceTemplate(
            uriTemplate="api://weather/{city}/{date}",
            name="Weather Data",
            description="Historical weather for city and date",
            mimeType="application/json"
        ),
        ResourceTemplate(
            uriTemplate="file://{path}",
            name="File Content",
            description="Read file at given path",
            mimeType="text/plain"
        )
    ]

@app.read_resource()
async def read_resource(uri: str) -> str:
    """Read resource, expanding template parameters."""
    
    # ржкрзНржпрж╛рж░рж╛ржорж┐ржЯрж╛рж░ржЧрзБрж▓рж┐ ржмрзЗрж░ ржХрж░рж╛рж░ ржЬржирзНржп ржЗржЙржЖрж░ржЖржЗ ржкрж╛рж░рзНрж╕ ржХрж░рзБржи
    if uri.startswith("db://users/"):
        user_id = uri.split("/")[-1]
        return await fetch_user(user_id)
    
    elif uri.startswith("api://weather/"):
        parts = uri.replace("api://weather/", "").split("/")
        city, date = parts[0], parts[1]
        return await fetch_weather(city, date)
    
    elif uri.startswith("file://"):
        path = uri.replace("file://", "")
        return await read_file(path)
    
    raise ValueError(f"Unknown resource URI: {uri}")
```

### ржЯрж╛ржЗржкрж╕рзНржХрзНрж░рж┐ржкрзНржЯ ржЗржоржкрзНрж▓рж┐ржорзЗржирзНржЯрзЗрж╢ржи

```typescript
server.setRequestHandler(ListResourceTemplatesSchema, async () => {
  return {
    resourceTemplates: [
      {
        uriTemplate: "github://repos/{owner}/{repo}/issues/{issue_number}",
        name: "GitHub Issue",
        description: "Fetch a specific GitHub issue",
        mimeType: "application/json"
      },
      {
        uriTemplate: "db://tables/{table}/rows/{id}",
        name: "Database Row",
        description: "Fetch a row from a database table",
        mimeType: "application/json"
      }
    ]
  };
});

server.setRequestHandler(ReadResourceSchema, async (request) => {
  const uri = request.params.uri;
  
  // ржЧрж┐ржЯрж╣рж╛ржм ржЗрж╕рзНржпрзБ URI ржкрж╛рж░рзНрж╕ ржХрж░рзБржи
  const githubMatch = uri.match(/^github:\/\/repos\/([^/]+)\/([^/]+)\/issues\/(\d+)$/);
  if (githubMatch) {
    const [_, owner, repo, issueNumber] = githubMatch;
    const issue = await fetchGitHubIssue(owner, repo, parseInt(issueNumber));
    return {
      contents: [{
        uri,
        mimeType: "application/json",
        text: JSON.stringify(issue, null, 2)
      }]
    };
  }
  
  throw new Error(`Unknown resource URI: ${uri}`);
});
```

---

## рзк. рж╕рж╛рж░рзНржнрж╛рж░ рж▓рж╛ржЗржлрж╕рж╛ржЗржХрзЗрж▓ ржЗржнрзЗржирзНржЯрж╕

рж╕ржарж┐ржХ ржЗржирж┐рж╢рж┐ржпрж╝рж╛рж▓рж╛ржЗржЬрзЗрж╢ржи ржПржмржВ рж╢рж╛ржЯржбрж╛ржЙржи рж╣рзНржпрж╛ржирзНржбрж▓рж┐ржВ ржкрж░рж┐рж╖рзНржХрж╛рж░ рж░рж┐рж╕рзЛрж░рзНрж╕ ржмрзНржпржмрж╕рзНржерж╛ржкржирж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рзЗред

### ржкрж╛ржЗржержи рж▓рж╛ржЗржлрж╕рж╛ржЗржХрзЗрж▓ ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ

```python
from mcp.server import Server
from contextlib import asynccontextmanager

app = Server("lifecycle-server")

# рж╢рзЗржпрж╝рж╛рж░рзНржб рж╕рзНржЯрзЗржЯ
db_connection = None
cache = None

@asynccontextmanager
async def lifespan(server: Server):
    """Manage server lifecycle."""
    global db_connection, cache
    
    # рж╕рзНржЯрж╛рж░рзНржЯржЖржк
    print("ЁЯЪА Server starting...")
    db_connection = await create_database_connection()
    cache = await create_cache_client()
    print("тЬЕ Resources initialized")
    
    yield  # рж╕рж╛рж░рзНржнрж╛рж░ ржПржЦрж╛ржирзЗ рж░рж╛ржи ржХрж░рзЗ
    
    # рж╢рж╛ржЯржбрж╛ржЙржи
    print("ЁЯЫС Server shutting down...")
    await db_connection.close()
    await cache.close()
    print("тЬЕ Resources cleaned up")

app = Server("lifecycle-server", lifespan=lifespan)

@app.tool()
async def query_database(sql: str) -> str:
    """Use the shared database connection."""
    result = await db_connection.execute(sql)
    return str(result)
```

### ржЯрж╛ржЗржкрж╕рзНржХрзНрж░рж┐ржкрзНржЯ рж▓рж╛ржЗржлрж╕рж╛ржЗржХрзЗрж▓

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";

class ManagedServer {
  private server: Server;
  private dbConnection: DatabaseConnection | null = null;
  
  constructor() {
    this.server = new Server({
      name: "lifecycle-server",
      version: "1.0.0"
    });
    
    this.setupHandlers();
  }
  
  async start() {
    // рж╕ржорзНржкржж ь┤Иъ╕░ ржХрж░рзБржи
    console.log("ЁЯЪА Server starting...");
    this.dbConnection = await createDatabaseConnection();
    console.log("тЬЕ Database connected");
    
    // рж╕рж╛рж░рзНржнрж╛рж░ рж╢рзБрж░рзБ ржХрж░рзБржи
    await this.server.connect(transport);
  }
  
  async stop() {
    // рж╕ржорзНржкржж ржкрж░рж┐рж╕рзНржХрж╛рж░ ржХрж░рзБржи
    console.log("ЁЯЫС Server shutting down...");
    if (this.dbConnection) {
      await this.dbConnection.close();
    }
    await this.server.close();
    console.log("тЬЕ Cleanup complete");
  }
  
  private setupHandlers() {
    this.server.setRequestHandler(CallToolSchema, async (request) => {
      // ржирж┐рж░рж╛ржкржжрзЗ ржПржЗ.dbConnection ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи
      // ...
    });
  }
}

// рж╕рзБржирзНржжрж░ рж╢рж╛ржЯржбрж╛ржЙржи рж╕рж╣ ржмрзНржпржмрж╣рж╛рж░
const server = new ManagedServer();

process.on('SIGINT', async () => {
  await server.stop();
  process.exit(0);
});

await server.start();
```

---

## рзл. рж▓ржЧрж┐ржВ ржирж┐ржпрж╝ржирзНрждрзНрж░ржг

MCP рж╕рж╛рж░рзНржнрж╛рж░-рж╕рж╛ржЗржб рж▓ржЧрж┐ржВ рж╕рзНрждрж░ рж╕ржорж░рзНржержи ржХрж░рзЗ ржпрж╛ ржХрзНрж▓рж╛ржпрж╝рзЗржирзНржЯ ржирж┐ржпрж╝ржирзНрждрзНрж░ржг ржХрж░рждрзЗ ржкрж╛рж░рзЗред

### рж▓ржЧрж┐ржВ рж╕рзНрждрж░ ржмрж╛рж╕рзНрждржмрж╛ржпрж╝ржи

```python
from mcp.server import Server
from mcp.types import LoggingLevel
import logging

app = Server("logging-server")

# MCP рж╕рзНрждрж░ржЧрзБрж▓рж┐ Python рж▓ржЧрж┐ржВ рж╕рзНрждрж░рзЗрж░ рж╕рж╛ржерзЗ ржорзНржпрж╛ржк ржХрж░рзБржи
LEVEL_MAP = {
    LoggingLevel.DEBUG: logging.DEBUG,
    LoggingLevel.INFO: logging.INFO,
    LoggingLevel.WARNING: logging.WARNING,
    LoggingLevel.ERROR: logging.ERROR,
}

logger = logging.getLogger("mcp-server")

@app.set_logging_level()
async def set_logging_level(level: LoggingLevel) -> None:
    """Handle client request to change logging level."""
    python_level = LEVEL_MAP.get(level, logging.INFO)
    logger.setLevel(python_level)
    logger.info(f"Logging level set to {level}")

@app.tool()
async def debug_operation(data: str) -> str:
    """Tool with various logging levels."""
    logger.debug(f"Processing data: {data}")
    
    try:
        result = process(data)
        logger.info(f"Successfully processed: {result}")
        return result
    except Exception as e:
        logger.error(f"Processing failed: {e}")
        raise
```

### ржХрзНрж▓рж╛ржпрж╝рзЗржирзНржЯржХрзЗ рж▓ржЧ ржмрж╛рж░рзНрждрж╛ ржкрж╛ржарж╛ржирзЛ

```python
@app.tool()
async def complex_operation(input: str, ctx) -> str:
    """Operation that logs to client."""
    
    # ржХрзНрж▓рж╛ржпрж╝рзЗржирзНржЯржХрзЗ рж▓ржЧ ржмрж┐ржЬрзНржЮржкрзНрждрж┐ ржкрж╛ржарж╛ржи
    await ctx.send_log(
        level="info",
        message=f"Starting complex operation with input: {input}"
    )
    
    # ржХрж╛ржЬ ржХрж░рзБржи...
    result = await do_work(input)
    
    await ctx.send_log(
        level="debug",
        message=f"Operation complete, result size: {len(result)}"
    )
    
    return result
```

---

## рзм. рждрзНрж░рзБржЯрж┐ ржкрж░рж┐ржЪрж╛рж▓ржирж╛рж░ ржкрзНржпрж╛ржЯрж╛рж░рзНржи

рж╕ржЩрзНржЧрждрж┐ржкрзВрж░рзНржг рждрзНрж░рзБржЯрж┐ ржмрзНржпржмрж╕рзНржерж╛ржкржирж╛ ржбрж┐ржмрж╛ржЧрж┐ржВ ржПржмржВ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржЕржнрж┐ржЬрзНржЮрждрж╛ ржЙржирзНржиржд ржХрж░рзЗред

### MCP рждрзНрж░рзБржЯрж┐ ржХрзЛржбрж╕ржорзВрж╣

```python
from mcp.types import McpError, ErrorCode

class ToolError(McpError):
    """Base class for tool errors."""
    pass

class ValidationError(ToolError):
    """Invalid input parameters."""
    def __init__(self, message: str):
        super().__init__(ErrorCode.INVALID_PARAMS, message)

class NotFoundError(ToolError):
    """Requested resource not found."""
    def __init__(self, resource: str):
        super().__init__(ErrorCode.INVALID_REQUEST, f"Not found: {resource}")

class PermissionError(ToolError):
    """Access denied."""
    def __init__(self, action: str):
        super().__init__(ErrorCode.INVALID_REQUEST, f"Permission denied: {action}")

class InternalError(ToolError):
    """Internal server error."""
    def __init__(self, message: str):
        super().__init__(ErrorCode.INTERNAL_ERROR, message)
```

### ржЧржаржиржорзВрж▓ржХ рждрзНрж░рзБржЯрж┐ ржкрзНрж░рждрж┐ржХрзНрж░рж┐ржпрж╝рж╛

```python
@app.tool()
async def safe_operation(input: str) -> str:
    """Tool with comprehensive error handling."""
    
    # ржЗржиржкрзБржЯ ржпрж╛ржЪрж╛ржЗ ржХрж░рзБржи
    if not input:
        raise ValidationError("Input cannot be empty")
    
    if len(input) > 10000:
        raise ValidationError(f"Input too large: {len(input)} chars (max 10000)")
    
    try:
        # ржЕржирзБржорждрж┐ ржкрж░рзАржХрзНрж╖рж╛ ржХрж░рзБржи
        if not await check_permission(input):
            raise PermissionError(f"read {input}")
        
        # ржЕржкрж╛рж░рзЗрж╢ржи рж╕ржорзНржкрж╛ржжржи ржХрж░рзБржи
        result = await perform_operation(input)
        
        if result is None:
            raise NotFoundError(input)
        
        return result
        
    except ConnectionError as e:
        raise InternalError(f"Database connection failed: {e}")
    except TimeoutError as e:
        raise InternalError(f"Operation timed out: {e}")
    except Exception as e:
        # ржЕржкрзНрж░рждрзНржпрж╛рж╢рж┐ржд рждрзНрж░рзБржЯрж┐ржЧрзБрж▓рж┐ рж▓ржЧ ржХрж░рзБржи
        logger.exception(f"Unexpected error in safe_operation")
        raise InternalError(f"Unexpected error: {type(e).__name__}")
```

### ржЯрж╛ржЗржкрж╕рзНржХрзНрж░рж┐ржкрзНржЯрзЗ рждрзНрж░рзБржЯрж┐ ржкрж░рж┐ржЪрж╛рж▓ржирж╛

```typescript
import { McpError, ErrorCode } from "@modelcontextprotocol/sdk/types.js";

function validateInput(data: unknown): asserts data is ValidInput {
  if (typeof data !== "object" || data === null) {
    throw new McpError(
      ErrorCode.InvalidParams,
      "Input must be an object"
    );
  }
  // ржЖрж░ржУ ржпрж╛ржЪрж╛ржЗ...
}

server.setRequestHandler(CallToolSchema, async (request) => {
  try {
    validateInput(request.params.arguments);
    
    const result = await performOperation(request.params.arguments);
    
    return {
      content: [{ type: "text", text: JSON.stringify(result) }]
    };
    
  } catch (error) {
    if (error instanceof McpError) {
      throw error;  // ржЗрждрж┐ржоржзрзНржпрзЗ ржПржХржЯрж┐ MCP рждрзНрж░рзБржЯрж┐
    }
    
    // ржЕржирзНржпрж╛ржирзНржп рждрзНрж░рзБржЯрж┐ рж░рзВржкрж╛ржирзНрждрж░ ржХрж░рзБржи
    if (error instanceof NotFoundError) {
      throw new McpError(ErrorCode.InvalidRequest, error.message);
    }
    
    // ржЕржЬрж╛ржирж╛ рждрзНрж░рзБржЯрж┐
    console.error("Unexpected error:", error);
    throw new McpError(
      ErrorCode.InternalError,
      "An unexpected error occurred"
    );
  }
});
```

---

## ржкрж░рзАржХрзНрж╖рж╛ржорзВрж▓ржХ ржмрзИрж╢рж┐рж╖рзНржЯрзНржпрж╕ржорзВрж╣ (MCP 2025-11-25)

ржирж┐рж░рзНржжрж┐рж╖рзНржЯржХрж░ржгрзЗ ржПржЗ ржмрзИрж╢рж┐рж╖рзНржЯрзНржпржЧрзБрж▓рзЛ ржкрж░рзАржХрзНрж╖рж╛ржорзВрж▓ржХ рж╣рж┐рж╕рзЗржмрзЗ ржЪрж┐рж╣рзНржирж┐ржд:

### ржЯрж╛рж╕рзНржХрж╕ржорзВрж╣ (ржжрзАрж░рзНржШржХрж╛рж▓ ржЪрж▓рж╛ ржЕржкрж╛рж░рзЗрж╢ржи)

```python
# ржХрж╛ржЬржЧрзБрж▓рж┐ рж░рж╛ржЬрзНржпрзЗрж░ рж╕рж╛ржерзЗ ржжрзАрж░рзНржШржорзЗржпрж╝рж╛ржжрзА ржЕржкрж╛рж░рзЗрж╢ржиржЧрзБрж▓рж┐ ржЯрзНрж░рзНржпрж╛ржХ ржХрж░рждрзЗ ржжрзЗржпрж╝
@app.task()
async def training_task(model_id: str, data_path: str, ctx) -> str:
    """Long-running ML training task."""
    
    # ржХрж╛ржЬ рж╢рзБрж░рзБ рж╣ржпрж╝рзЗржЫрзЗ рж░рж┐ржкрзЛрж░рзНржЯ ржХрж░рзБржи
    await ctx.report_status("running", "Initializing training...")
    
    # ржкрзНрж░рж╢рж┐ржХрзНрж╖ржгрзЗрж░ рж▓рзБржк
    for epoch in range(100):
        await train_epoch(model_id, data_path, epoch)
        await ctx.report_status(
            "running",
            f"Training epoch {epoch + 1}/100",
            progress=epoch + 1,
            total=100
        )
    
    await ctx.report_status("completed", "Training finished")
    return f"Model {model_id} trained successfully"
```

### ржЯрзБрж▓ ржПржирзЛржЯрзЗрж╢ржи

```python
# ржЯрзБрж▓рзЗрж░ ржЖржЪрж░ржг рж╕ржорзНржкрж░рзНржХрзЗ ржорзЗржЯрж╛ржбрж╛ржЯрж╛ ржкрзНрж░ржжрж╛ржи ржХрж░рзЗ
@app.tool(
    annotations={
        "destructive": False,      # ржбрзЗржЯрж╛ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рзЗ ржирж╛
        "idempotent": True,        # ржкрзБржирж░рж╛ржпрж╝ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рж╛ ржирж┐рж░рж╛ржкржж
        "timeout_seconds": 30,     # ржкрзНрж░рждрзНржпрж╛рж╢рж┐ржд рж╕рж░рзНржмрзЛржЪрзНржЪ рж╕ржоржпрж╝ржХрж╛рж▓
        "requires_approval": False # ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржЕржирзБржорзЛржжржи ржкрзНрж░ржпрж╝рзЛржЬржи ржирзЗржЗ
    }
)
async def safe_query(query: str) -> str:
    """A read-only database query tool."""
    return await execute_read_query(query)
```

---

## ржкрж░ржмрж░рзНрждрзА ржХрзА

- [ржоржбрж┐ржЙрж▓ рзо - рж╕рзЗрж░рж╛ ржЕржирзБрж╢рзАрж▓ржирж╕ржорзВрж╣](../../08-BestPractices/README.md)
- [5.14 - ржкрзНрж░рж╕ржЩрзНржЧ ржкрзНрж░ржХрзМрж╢рж▓](../mcp-contextengineering/README.md)
- [MCP рж╕рзНржкрзЗрж╕рж┐ржлрж┐ржХрзЗрж╢ржи ржЪрзЗржЮрзНржЬрж▓ржЧ](https://spec.modelcontextprotocol.io/)

---

## ржЕрждрж┐рж░рж┐ржХрзНржд рж╕ржорзНржкржж

- [MCP рж╕рзНржкрзЗрж╕рж┐ржлрж┐ржХрзЗрж╢ржи 2025-11-25](https://spec.modelcontextprotocol.io/specification/2025-11-25/)
- [JSON-RPC 2.0 рждрзНрж░рзБржЯрж┐ ржХрзЛржбрж╕ржорзВрж╣](https://www.jsonrpc.org/specification#error_object)
- [ржкрж╛ржЗржержи SDK ржЙржжрж╛рж╣рж░ржгрж╕ржорзВрж╣](https://github.com/modelcontextprotocol/python-sdk/tree/main/examples)
- [ржЯрж╛ржЗржкрж╕рзНржХрзНрж░рж┐ржкрзНржЯ SDK ржЙржжрж╛рж╣рж░ржгрж╕ржорзВрж╣](https://github.com/modelcontextprotocol/typescript-sdk/tree/main/examples)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**ржЕрж╕рзНржмрзАржХрж╛рж░рзЛржХрзНрждрж┐**:  
ржПржЗ ржиржерж┐ржЯрж┐ AI ржЕржирзБржмрж╛ржж рж╕рзЗржмрж╛ [Co-op Translator](https://github.com/Azure/co-op-translator) ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржЕржирзВржжрж┐ржд рж╣ржпрж╝рзЗржЫрзЗред ржЖржорж░рж╛ ржпржерж╛рж╕ржорзНржнржм рж╕ржарж┐ржХрждрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рж┐, рждржмрзЗ рж╕рзНржмржпрж╝ржВржХрзНрж░рж┐ржпрж╝ ржЕржирзБржмрж╛ржжрзЗ ржнрзБрж▓ ржмрж╛ ржЕрж╕ржЩрзНржЧрждрж┐ ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗред ржорзВрж▓ ржиржерж┐рж░ ржирж┐ржЬржнрж╛рж╖рж╛рж░ рж╕ржВрж╕рзНржХрж░ржгржЗ ржХрж░рзНрждрзГрждрзНржмржкрзВрж░рзНржг ржЙрзОрж╕ рж╣рж┐рж╕рзЗржмрзЗ ржмрж┐ржмрзЗржЪржирж╛ ржХрж░рж╛ ржЙржЪрж┐рждред ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг рждржерзНржпрзЗрж░ ржЬржирзНржп ржкрзЗрж╢рж╛ржжрж╛рж░ ржорж╛ржиржм ржЕржирзБржмрж╛ржж ржЧрзНрж░рж╣ржг ржХрж░рж╛рж░ рж╕рзБржкрж╛рж░рж┐рж╢ ржХрж░рж╛ рж╣ржпрж╝ред ржПржЗ ржЕржирзБржмрж╛ржжрзЗрж░ ржмрзНржпржмрж╣рж╛рж░ ржерзЗржХрзЗ рж╕рзГрж╖рзНржЯ ржпрзЗржХрзЛржирзЛ ржнрзБрж▓ ржмрзЛржЭрж╛ржмрзБржЭрж┐ ржмрж╛ ржнрзБрж▓ ржмрзНржпрж╛ржЦрзНржпрж╛рж░ ржЬржирзНржп ржЖржорж░рж╛ ржжрж╛ржпрж╝рзА ржиржЗред
<!-- CO-OP TRANSLATOR DISCLAIMER END -->