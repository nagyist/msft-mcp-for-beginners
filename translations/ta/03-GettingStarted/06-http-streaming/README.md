# HTTPS Streaming with Model Context Protocol (MCP)

இந்த அத்தியாயம் HTTPS பயன்படுத்தி Model Context Protocol (MCP) மூலம் பாதுகாப்பான, விரிவாக்கக்கூடிய மற்றும் நேரடி ஸ்ட்ரீமிங்கை செயல்படுத்துவதற்கான முழுமையான வழிகாட்டுதலை வழங்குகிறது. இது ஸ்ட்ரீமிங்கிற்கான உந்துதல், கிடைக்கும் போக்குவரத்து முறைகள், MCP-இல் ஸ்ட்ரீமபிள் HTTP-ஐ எப்படி செயல்படுத்துவது, பாதுகாப்பு சிறந்த நடைமுறைகள், SSE-இல் இருந்து இடமாற்றம் மற்றும் MCP ஸ்ட்ரீமிங் பயன்பாடுகளை உருவாக்குவதற்கான நடைமுறை வழிகாட்டுதலை உள்ளடக்கியது.

## MCP-இல் போக்குவரத்து முறைகள் மற்றும் ஸ்ட்ரீமிங்

இந்த பகுதி MCP-இல் கிடைக்கும் பல்வேறு போக்குவரத்து முறைகளை ஆராய்ந்து, வாடிக்கையாளர்கள் மற்றும் சேவையகங்களுக்கு இடையிலான நேரடி தொடர்புக்கு ஸ்ட்ரீமிங் திறன்களை எவ்வாறு இயக்குகிறது என்பதை விளக்குகிறது.

### போக்குவரத்து முறை என்றால் என்ன?

போக்குவரத்து முறை என்பது வாடிக்கையாளர் மற்றும் சேவையகத்திற்கிடையே தரவுகள் எவ்வாறு பரிமாறப்படுகின்றன என்பதை வரையறுக்கிறது. MCP பல்வேறு சூழல்களுக்கும் தேவைகளுக்கும் பொருந்தும் பல போக்குவரத்து வகைகளை ஆதரிக்கிறது:

- **stdio**: உள்ளீடு/வெளியீடு தரநிலைகள், உள்ளூர் மற்றும் CLI அடிப்படையிலான கருவிகளுக்கு ஏற்றது. எளிமையானது ஆனால் வலை அல்லது மேகத்திற்குப் பொருத்தமானது அல்ல.
- **SSE (Server-Sent Events)**: HTTP மூலம் வாடிக்கையாளர்களுக்கு நேரடி புதுப்பிப்புகளை சேவையகங்கள் தள்ளும். வலை UI-களுக்கு நல்லது, ஆனால் விரிவாக்கத்திலும் நெகிழ்வுத்தன்மையிலும் வரையறுக்கப்பட்டுள்ளது.
- **Streamable HTTP**: அறிவிப்புகளை ஆதரிக்கும் மற்றும் சிறந்த விரிவாக்கத்தன்மையைக் கொண்ட நவீன HTTP அடிப்படையிலான ஸ்ட்ரீமிங் போக்குவரத்து. பெரும்பாலான உற்பத்தி மற்றும் மேக சூழல்களுக்கு பரிந்துரைக்கப்படுகிறது.

### ஒப்பீட்டு அட்டவணை

இந்த போக்குவரத்து முறைகளின் வேறுபாடுகளைப் புரிந்துகொள்ள கீழே உள்ள ஒப்பீட்டு அட்டவணையைப் பாருங்கள்:

| போக்குவரத்து        | நேரடி புதுப்பிப்புகள் | ஸ்ட்ரீமிங் | விரிவாக்கத்தன்மை | பயன்பாட்டு வழக்கு          |
|-------------------|------------------|-----------|-------------|-------------------------|
| stdio             | இல்லை            | இல்லை      | குறைந்தது     | உள்ளூர் CLI கருவிகள்       |
| SSE               | ஆம்              | ஆம்        | நடுத்தர      | வலை, நேரடி புதுப்பிப்புகள்  |
| Streamable HTTP   | ஆம்              | ஆம்        | அதிகம்       | மேகம், பல வாடிக்கையாளர்கள் |

> **சிறந்த ஆலோசனை:** சரியான போக்குவரத்தைத் தேர்ந்தெடுப்பது செயல்திறன், விரிவாக்கத்தன்மை மற்றும் பயனர் அனுபவத்தை பாதிக்கிறது. **Streamable HTTP** நவீன, விரிவாக்கக்கூடிய மற்றும் மேகத்திற்குத் தயாரான பயன்பாடுகளுக்கு பரிந்துரைக்கப்படுகிறது.

முந்தைய அத்தியாயங்களில் நீங்கள் stdio மற்றும் SSE போக்குவரத்துகளைப் பார்த்தீர்கள், இந்த அத்தியாயத்தில் Streamable HTTP போக்குவரத்தைப் பற்றி விவாதிக்கப்படுகிறது.

## ஸ்ட்ரீமிங்: கருத்துக்கள் மற்றும் உந்துதல்

நேரடி தொடர்பு அமைப்புகளை செயல்படுத்துவதற்கான அடிப்படை கருத்துக்கள் மற்றும் உந்துதல்களைப் புரிந்துகொள்வது முக்கியமானது.

**ஸ்ட்ரீமிங்** என்பது நெட்வொர்க் நிரலாக்கத்தில் ஒரு தொழில்நுட்பமாகும், இது முழு பதில் தயாராக இருக்கும் வரை காத்திருக்காமல், தரவுகளை சிறிய, மேலாண்மை செய்யக்கூடிய துண்டுகளாக அல்லது நிகழ்வுகளின் வரிசையாக அனுப்பவும் பெறவும் அனுமதிக்கிறது. இது குறிப்பாக பின்வரும் சூழல்களுக்கு பயனுள்ளதாக இருக்கும்:

- பெரிய கோப்புகள் அல்லது தரவுத்தொகுப்புகள்.
- நேரடி புதுப்பிப்புகள் (எ.கா., உரையாடல், முன்னேற்ற பட்டைகள்).
- நீண்ட நேரம் செயல்படும் கணக்கீடுகள், பயனரை தகவலுடன் வைத்திருக்க விரும்பும் போது.

ஸ்ட்ரீமிங் பற்றிய உயர் நிலை தகவல்கள்:

- தரவுகள் முறையே வழங்கப்படுகின்றன, ஒரே நேரத்தில் அனைத்தும் அல்ல.
- வாடிக்கையாளர் தரவுகளை வரும்போது செயல்படுத்த முடியும்.
- உணரப்படும் தாமதத்தை குறைத்து, பயனர் அனுபவத்தை மேம்படுத்துகிறது.

### ஏன் ஸ்ட்ரீமிங் பயன்படுத்த வேண்டும்?

ஸ்ட்ரீமிங் பயன்படுத்துவதற்கான காரணங்கள் பின்வருமாறு:

- பயனர்கள் உடனடியாக கருத்துகளைப் பெறுகிறார்கள், இறுதியில் மட்டுமல்ல.
- நேரடி பயன்பாடுகள் மற்றும் பதிலளிக்கக்கூடிய UI-களை இயக்குகிறது.
- நெட்வொர்க் மற்றும் கணினி வளங்களைச் சிறப்பாக பயன்படுத்துகிறது.

### எளிய உதாரணம்: HTTP ஸ்ட்ரீமிங் சேவையகமும் வாடிக்கையாளரும்

ஸ்ட்ரீமிங் எவ்வாறு செயல்படுத்தப்படலாம் என்பதை விளக்கும் ஒரு எளிய உதாரணம் இதோ:

#### Python

**சேவையகம் (Python, FastAPI மற்றும் StreamingResponse பயன்படுத்தி):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**வாடிக்கையாளர் (Python, requests பயன்படுத்தி):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

இந்த உதாரணம், அனைத்து செய்திகளும் தயாராக இருக்கும் வரை காத்திருக்காமல், சேவையகம் வாடிக்கையாளருக்கு கிடைக்கும் செய்திகளை வரிசையாக அனுப்புவதைக் காட்டுகிறது.

**இது எப்படி வேலை செய்கிறது:**

- சேவையகம் ஒவ்வொரு செய்தியையும் தயாராக இருக்கும் போது வழங்குகிறது.
- வாடிக்கையாளர் ஒவ்வொரு துண்டையும் வரும்போது பெறுகிறது மற்றும் அச்சிடுகிறது.

**தேவைகள்:**

- சேவையகம் ஸ்ட்ரீமிங் பதிலை (எ.கா., FastAPI-இல் `StreamingResponse`) பயன்படுத்த வேண்டும்.
- வாடிக்கையாளர் பதிலை ஸ்ட்ரீமாக செயல்படுத்த வேண்டும் (`stream=True` requests-இல்).
- Content-Type பொதுவாக `text/event-stream` அல்லது `application/octet-stream` ஆக இருக்கும்.

#### Java

**சேவையகம் (Java, Spring Boot மற்றும் Server-Sent Events பயன்படுத்தி):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**வாடிக்கையாளர் (Java, Spring WebFlux WebClient பயன்படுத்தி):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Java செயல்படுத்தல் குறிப்புகள்:**

- `Flux` மூலம் Spring Boot-இன் எதிர்வினை குவியலைப் பயன்படுத்துகிறது.
- `ServerSentEvent` நிகழ்வு வகைகளுடன் அமைக்கப்பட்ட நிகழ்வு ஸ்ட்ரீமிங்கை வழங்குகிறது.
- `bodyToFlux()` உடன் `WebClient` எதிர்வினை ஸ்ட்ரீமிங் நுகர்வை இயக்குகிறது.
- `delayElements()` நிகழ்வுகளுக்கு இடையிலான செயலாக்க நேரத்தை ஒத்திகை செய்கிறது.
- நிகழ்வுகள் வாடிக்கையாளர் கையாளுதலுக்கான சிறந்த வகைகளைக் கொண்டிருக்கலாம் (`info`, `result`).

### ஒப்பீடு: பாரம்பரிய ஸ்ட்ரீமிங் vs MCP ஸ்ட்ரீமிங்

"பாரம்பரிய" முறையில் ஸ்ட்ரீமிங் எவ்வாறு செயல்படுகிறது மற்றும் MCP-இல் ஸ்ட்ரீமிங் எவ்வாறு செயல்படுகிறது என்பதற்கான வேறுபாடுகளை கீழே காட்டலாம்:

| அம்சம்                | பாரம்பரிய HTTP ஸ்ட்ரீமிங்         | MCP ஸ்ட்ரீமிங் (அறிவிப்புகள்)      |
|------------------------|-------------------------------|-------------------------------------|
| முக்கிய பதில்          | துண்டுகளாக                   | இறுதியில் ஒரே பதில்                 |
| முன்னேற்ற புதுப்பிப்புகள் | தரவுத் துண்டுகளாக அனுப்பப்படும் | அறிவிப்புகளாக அனுப்பப்படும்         |
| வாடிக்கையாளர் தேவைகள்  | ஸ்ட்ரீமைப் செயல்படுத்த வேண்டும் | செய்தி கையாளுநரை செயல்படுத்த வேண்டும் |
| பயன்பாட்டு வழக்கு       | பெரிய கோப்புகள், AI டோக்கன் ஸ்ட்ரீம்கள் | முன்னேற்றம், பதிவுகள், நேரடி கருத்து |

### முக்கிய வேறுபாடுகள்

மேலும், சில முக்கிய வேறுபாடுகள்:

- **தொடர்பு முறை:**
  - பாரம்பரிய HTTP ஸ்ட்ரீமிங்: தரவுகளை துண்டுகளாக அனுப்ப எளிய துண்டு பரிமாற்ற குறியாக்கத்தைப் பயன்படுத்துகிறது.
  - MCP ஸ்ட்ரீமிங்: JSON-RPC நெறிமுறையுடன் அமைக்கப்பட்ட அறிவிப்பு அமைப்பை பயன்படுத்துகிறது.

- **செய்தி வடிவம்:**
  - பாரம்பரிய HTTP: புதிய வரிகளுடன் சாதாரண உரை துண்டுகள்.
  - MCP: மெட்டாடேட்டாவுடன் அமைக்கப்பட்ட LoggingMessageNotification பொருட்கள்.

- **வாடிக்கையாளர் செயல்படுத்தல்:**
  - பாரம்பரிய HTTP: ஸ்ட்ரீமிங் பதில்களை செயல்படுத்தும் எளிய வாடிக்கையாளர்.
  - MCP: பல்வேறு வகையான செய்திகளை செயல்படுத்த ஒரு செய்தி கையாளுநரை கொண்ட மேம்பட்ட வாடிக்கையாளர்.

- **முன்னேற்ற புதுப்பிப்புகள்:**
  - பாரம்பரிய HTTP: முன்னேற்றம் முக்கிய பதில் ஸ்ட்ரீமின் ஒரு பகுதியாக உள்ளது.
  - MCP: முன்னேற்றம் தனித்த அறிவிப்பு செய்திகளாக அனுப்பப்படுகிறது, முக்கிய பதில் இறுதியில் வருகிறது.

### பரிந்துரைகள்

பாரம்பரிய ஸ்ட்ரீமிங் (மேலே காட்டிய `/stream` எனும் எண்ட்பாயிண்ட்) மற்றும் MCP மூலம் ஸ்ட்ரீமிங் ஆகியவற்றை செயல்படுத்துவதற்கான தேர்வுகளில் சில பரிந்துரைகள் உள்ளன:

- **எளிய ஸ்ட்ரீமிங் தேவைகளுக்கு:** பாரம்பரிய HTTP ஸ்ட்ரீமிங் எளிதாக செயல்படுத்தப்படுகிறது மற்றும் அடிப்படை ஸ்ட்ரீமிங் தேவைகளுக்கு போதுமானது.

- **சிக்கலான, இடையூறு செயல்பாடுகளுக்கு:** MCP ஸ்ட்ரீமிங் அறிவிப்புகள் மற்றும் இறுதி முடிவுகளுக்கு இடையிலான பிரிவுடன் அமைக்கப்பட்ட அணுகுமுறையை வழங்குகிறது.

- **AI பயன்பாடுகளுக்கு:** MCP-இன் அறிவிப்பு அமைப்பு நீண்ட நேரம் செயல்படும் AI பணிகளுக்கு பயனுள்ளதாக உள்ளது, பயனர்களுக்கு முன்னேற்றத்தைத் தெரிவிக்க விரும்பும் போது.

## MCP-இல் ஸ்ட்ரீமிங்

சரி, பாரம்பரிய ஸ்ட்ரீமிங் மற்றும் MCP-இல் ஸ்ட்ரீமிங் பற்றிய ஒப்பீடுகள் மற்றும் பரிந்துரைகளை நீங்கள் பார்த்தீர்கள். MCP-இல் ஸ்ட்ரீமிங்கை எவ்வாறு பயன்படுத்தலாம் என்பதை விரிவாகப் பார்ப்போம்.

MCP கட்டமைப்பில் ஸ்ட்ரீமிங் எவ்வாறு செயல்படுகிறது என்பதைப் புரிந்துகொள்வது, நீண்ட நேரம் செயல்படும் செயல்பாடுகளின் போது பயனர்களுக்கு நேரடி கருத்துகளை வழங்கும் பதிலளிக்கக்கூடிய பயன்பாடுகளை உருவாக்குவதற்கு முக்கியமானது.

MCP-இல், ஸ்ட்ரீமிங் என்பது முக்கிய பதிலை துண்டுகளாக அனுப்புவது பற்றி அல்ல, ஆனால் **அறிவிப்புகளை** வாடிக்கையாளருக்கு அனுப்புவது பற்றி, ஒரு கருவி கோரிக்கையை செயல்படுத்தும் போது. இந்த அறிவிப்புகள் முன்னேற்ற புதுப்பிப்புகள், பதிவுகள் அல்லது பிற நிகழ்வுகளை உள்ளடக்கலாம்.

### இது எப்படி வேலை செய்கிறது

முக்கிய முடிவு இன்னும் ஒரே பதிலாக அனுப்பப்படுகிறது. இருப்பினும், செயலாக்கத்தின் போது அறிவிப்புகள் தனித்த செய்திகளாக அனுப்பப்படலாம், இதனால் வாடிக்கையாளர் நேரடியாக புதுப்பிக்கப்படுகிறது. வாடிக்கையாளர் இந்த அறிவிப்புகளை கையாளவும் காட்சிப்படுத்தவும் முடியும்.

## அறிவிப்பு என்றால் என்ன?

"அறிவிப்பு" என்றால் MCP-இல் என்ன பொருள்?

அறிவிப்பு என்பது நீண்ட நேரம் செயல்படும் செயல்பாட்டின் போது முன்னேற்றம், நிலை அல்லது பிற நிகழ்வுகளைப் பற்றிய தகவல்களை வாடிக்கையாளருக்கு தெரிவிக்க சேவையகத்தால் அனுப்பப்படும் ஒரு செய்தியாகும். அறிவிப்புகள் வெளிப்படைத்தன்மையையும் பயனர் அனுபவத்தையும் மேம்படுத்துகின்றன.

எடுத்துக்காட்டாக, சேவையகத்துடன் ஆரம்ப ஹேண்ட்ஷேக் செய்யப்பட்ட பிறகு வாடிக்கையாளர் அறிவிப்பை அனுப்ப வேண்டும்.

அறிவிப்பு JSON செய்தியாக இவ்வாறு இருக்கும்:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

அறிவிப்புகள் MCP-இல் ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging) எனப்படும் ஒரு தலைப்பிற்கு சொந்தமானவை.

Logging செயல்பட, சேவையகம் அதை ஒரு அம்சமாக/திறனாக இவ்வாறு இயக்க வேண்டும்:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> பயன்படுத்தப்படும் SDK-ஐப் பொறுத்து, Logging இயல்பாக இயக்கப்பட்டிருக்கலாம் அல்லது சேவையக கட்டமைப்பில் அதை வெளிப்படையாக இயக்க வேண்டும்.

அறிவிப்புகளின் பல்வேறு வகைகள் உள்ளன:

| நிலை     | விளக்கம்                    | உதாரண பயன்பாட்டு வழக்கு         |
|-----------|-------------------------------|---------------------------------|
| debug     | விரிவான பிழைத்திருத்த தகவல்கள் | செயல்பாடு நுழைவு/வெளியேற்ற புள்ளிகள் |
| info      | பொதுவான தகவல் செய்திகள்       | செயல்பாட்டு முன்னேற்ற புதுப்பிப்புகள் |
| notice    | சாதாரண ஆனால் முக்கிய நிகழ்வுகள் | கட்டமைப்பு மாற்றங்கள்           |
| warning   | எச்சரிக்கை நிலைகள்           | பழைய அம்ச பயன்பாடு             |
| error     | பிழை நிலைகள்                 | செயல்பாட்டு தோல்விகள்            |
| critical  | முக்கிய நிலைகள்              | அமைப்பு கூறு தோல்விகள்          |
| alert     | உடனடியாக நடவடிக்கை எடுக்க வேண்டும் | தரவுத் துருப்பிடிப்பு கண்டறியப்பட்டது |
| emergency | அமைப்பு பயன்படுத்த முடியாது    | முழுமையான அமைப்பு தோல்வி       |

## MCP-இல் அறிவிப்புகளை செயல்படுத்துதல்

MCP-இல் அறிவிப்புகளை செயல்படுத்த, நீண்ட நேரம் செயல்படும் செயல்பாடுகளின் போது நேரடி புதுப்பிப்புகளை கையாள வாடிக்கையாளர் மற்றும் சேவையகத்தை அமைக்க வேண்டும். இது உங்கள் பயன்பாட்டை பயனர்களுக்கு உடனடி கருத்துகளை வழங்க அனுமதிக்கிறது.

### சேவையக பக்கம்: அறிவிப்புகளை அனுப்புதல்

சேவையக பக்கம் தொடங்குவோம். MCP-இல், கோரிக்கைகளை செயல்படுத்தும் போது அறிவிப்புகளை அனுப்பும் கருவிகளை நீங்கள் வரையறுக்கிறீர்கள். சேவையகம் வாடிக்கையாளருக்கு செய்திகளை அனுப்ப `ctx` எனப்படும் சூழல் பொருளைப் பயன்படுத்துகிறது.

#### Python

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

மேலே உள்ள உதாரணத்தில், `process_files` கருவி ஒவ்வொரு கோப்பையும் செயல்படுத்தும் போது வாடிக்கையாளருக்கு மூன்று அறிவிப்புகளை அனுப்புகிறது. `ctx.info()` முறை தகவல் செய்திகளை அனுப்ப பயன்படுத்தப்படுகிறது.

மேலும், அறிவிப்புகளை இயக்க, உங்கள் சேவையகம் ஸ்ட்ரீமிங் போக்குவரத்தை (எ.கா., `streamable-http`) பயன்படுத்த வேண்டும், மேலும் உங்கள் வாடிக்கையாளர் அறிவிப்புகளை செயல்படுத்த ஒரு செய்தி கையாளுநரை செயல்படுத்த வேண்டும். `streamable-http` போக்குவரத்தை பயன்படுத்த சேவையகத்தை அமைப்பது இவ்வாறு:

```python
mcp.run(transport="streamable-http")
```

#### .NET

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

இந்த .NET உதாரணத்தில், `ProcessFiles` கருவி `Tool` அடையாளத்துடன் அலங்கரிக்கப்பட்டுள்ளது மற்றும் ஒவ்வொரு கோப்பையும் செயல்படுத்தும் போது வாடிக்கையாளருக்கு மூன்று அறிவிப்புகளை அனுப்புகிறது. `ctx.Info()` முறை தகவல் செய்திகளை அனுப்ப பயன்படுத்தப்படுகிறது.

உங்கள் .NET MCP சேவையகத்தில் அறிவிப்புகளை இயக்க, நீங்கள் ஸ்ட்ரீமிங் போக்குவரத்தைப் பயன்படுத்துகிறீர்கள் என்பதை உறுதிப்படுத்துங்கள்:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

### வாடிக்கையாளர் பக்கம்: அறிவிப்புகளை பெறுதல்

வாடிக்கையாளர் வரும்போது அறிவிப்புகளை செயல்படுத்தவும் காட்சிப்படுத்தவும் ஒரு செய்தி கையாளுநரை செயல்படுத்த வேண்டும்.

#### Python

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

மேலே உள்ள குறியீட்டில், `message_handler` செயல்பாடு வரும் செய்தி அறிவிப்பா என்பதைச் சரிபார்க்கிறது. அது அறிவிப்பாக இருந்தால், அதை அச்சிடுகிறது; இல்லையெனில், அதை சாதாரண சேவையக செய்தியாக செயல்படுத்துகிறது. மேலும், `ClientSession` அறிவிப்புகளை கையாள `message_handler` உடன் ஆரம்பிக்கப்படுகிறது.

#### .NET

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

இந்த .NET உதாரணத்தில், `MessageHandler` செயல்பாடு வரும் செய்தி அறிவிப்பா என்பதைச் சரிபார்க்கிறது. அது அறிவிப்பாக இருந்தால், அதை அச்சிடுகிறது; இல்லையெனில், அதை சாதாரண சேவையக செய்தியாக செயல்படுத்துகிறது. `ClientSession` `ClientSessionOptions` மூலம் செய்தி கையாளுநருடன் ஆரம்பிக்கப்படுகிறது.

அறிவிப்புகளை இயக்க, உங்கள் சேவையகம் ஸ்ட்ரீமிங் போக்குவரத்தை (எ.கா., `streamable-http`) பயன்படுத்த வேண்டும், மேலும் உங்கள் வாடிக்கையாளர் அறிவிப்புகளை செயல்படுத்த ஒரு செய்தி கையாளுநரை செயல்படுத்த வேண்டும்.

## முன்னேற்ற அறிவிப்புகள் மற்றும் சூழல்கள்

இந்த பகுதி MCP-இல் முன்னேற்ற அறிவிப்புகளின் கருத்தை, அவற்றின் முக்கியத்துவத்தை மற்றும் Streamable HTTP-ஐப் பயன்படுத்தி அவற்றை எவ்வாறு செயல்படுத்துவது என்பதை விளக்குகிறது. உங்கள் புரிதலை வலுப்படுத்த ஒரு நடைமுறை பணியும் இதில் உள்ளது.

முன்னேற்ற அறிவிப்புகள் என்பது நீண்ட நேரம் செயல்படும் செயல்பாடுகளின் போது சேவையகத்தால் வாடிக்கையாளருக்கு அனுப்பப்படும் நேரடி செய்திகளாகும். முழு செயல்முறை முடிவடையும் வரை காத்திருக்காமல், சேவையகம் தற்போதைய நிலையை வாடிக்கையாளருக்கு புதுப்பிக்கிறது. இது வெளிப்படைத்தன்மையை மேம்படுத்துகிறது, பயனர் அனுபவத்தை மேம்படுத்துகிறது மற்றும் பிழைத்திருத்தத்தை எளிதாக்குகிறது.

**உதாரண
## SSE-இல் இருந்து Streamable HTTP-க்கு மேம்படுத்தல்

Server-Sent Events (SSE) பயன்படுத்தும் பயன்பாடுகளுக்கு, Streamable HTTP-க்கு மாறுதல் MCP செயல்பாடுகளுக்கான மேம்பட்ட திறன்களை மற்றும் நீண்டகால நிலைத்தன்மையை வழங்குகிறது.

### ஏன் மேம்படுத்த வேண்டும்?

SSE-இல் இருந்து Streamable HTTP-க்கு மேம்படுத்துவதற்கான இரண்டு முக்கிய காரணங்கள் உள்ளன:

- Streamable HTTP, SSE-க்கு மாறாக சிறந்த அளவீடு, இணக்கத்தன்மை மற்றும் வளமான அறிவிப்பு ஆதரவை வழங்குகிறது.
- புதிய MCP பயன்பாடுகளுக்கு பரிந்துரைக்கப்படும் போக்குவரத்து இது.

### மாற்று நடவடிக்கைகள்

SSE-இல் இருந்து Streamable HTTP-க்கு உங்கள் MCP பயன்பாடுகளில் எப்படி மாறுவது என்பதை இங்கே காணலாம்:

- **சர்வர் குறியீட்டை புதுப்பிக்கவும்** `mcp.run()`-இல் `transport="streamable-http"` பயன்படுத்தவும்.
- **கிளையன்ட் குறியீட்டை புதுப்பிக்கவும்** SSE கிளையன்ட் பதிலாக `streamablehttp_client` பயன்படுத்தவும்.
- **ஒரு செய்தி கையாளுநரை செயல்படுத்தவும்** அறிவிப்புகளை செயல்படுத்த கிளையன்டில்.
- **இணக்கத்தன்மைக்கான சோதனை** உள்ளடக்கிய கருவிகள் மற்றும் வேலைப்பாடுகளுடன் செய்யவும்.

### இணக்கத்தன்மையை பராமரித்தல்

மாற்று செயல்முறையின் போது SSE கிளையன்ட்களுடன் இணக்கத்தன்மையை பராமரிக்க பரிந்துரைக்கப்படுகிறது. சில உத்திகள் இங்கே:

- SSE மற்றும் Streamable HTTP இரண்டையும் வெவ்வேறு முடிவுகளில் இயக்குவதன் மூலம் ஆதரிக்கலாம்.
- புதிய போக்குவரத்திற்கு கிளையன்ட்களை تدريجமாக மாற்றவும்.

### சவால்கள்

மாற்று செயல்முறையின் போது பின்வரும் சவால்களை தீர்க்க உறுதிப்படுத்தவும்:

- அனைத்து கிளையன்ட்களும் புதுப்பிக்கப்படுவதை உறுதிப்படுத்துதல்
- அறிவிப்பு வழங்கலில் உள்ள வேறுபாடுகளை கையாளுதல்

## பாதுகாப்பு கருத்துக்கள்

HTTP அடிப்படையிலான போக்குவரத்துகளைப் பயன்படுத்தும் போது, குறிப்பாக MCP செயல்பாடுகளில், பாதுகாப்பு மிக முக்கியமாக இருக்க வேண்டும்.

HTTP அடிப்படையிலான போக்குவரத்துகளுடன் MCP சர்வர்களை செயல்படுத்தும்போது, பல தாக்க திசைகள் மற்றும் பாதுகாப்பு முறைகளை கவனமாக பராமரிக்க வேண்டும்.

### கண்ணோட்டம்

HTTP மூலம் MCP சர்வர்களை வெளிப்படுத்தும்போது பாதுகாப்பு முக்கியமானது. Streamable HTTP புதிய தாக்க மேற்பரப்புகளை அறிமுகப்படுத்துகிறது மற்றும் கவனமாக உள்ளமைவை தேவைப்படுகிறது.

முக்கிய பாதுகாப்பு கருத்துக்கள் இங்கே:

- **Origin Header Validation**: DNS rebinding தாக்குதல்களைத் தடுக்க `Origin` தலைப்பை எப்போதும் சரிபார்க்கவும்.
- **Localhost Binding**: உள்ளூர் மேம்பாட்டிற்காக, சர்வர்களை `localhost`-க்கு பிணைக்கவும், அவற்றை பொது இணையத்திற்கு வெளிப்படுத்தாமல் இருக்க.
- **Authentication**: API கீக்கள், OAuth போன்ற அங்கீகாரத்தை உற்பத்தி பயன்பாடுகளுக்கு செயல்படுத்தவும்.
- **CORS**: Cross-Origin Resource Sharing (CORS) கொள்கைகளை அமைத்து அணுகலை கட்டுப்படுத்தவும்.
- **HTTPS**: உற்பத்தியில் HTTPS பயன்படுத்தி போக்குவரத்தை குறியாக்கவும்.

### சிறந்த நடைமுறைகள்

MCP ஸ்ட்ரீமிங் சர்வரில் பாதுகாப்பை செயல்படுத்தும்போது பின்வரும் சிறந்த நடைமுறைகளை பின்பற்றவும்:

- சரிபார்ப்பின்றி வரும் கோரிக்கைகளை நம்ப வேண்டாம்.
- அனைத்து அணுகல்களையும் மற்றும் பிழைகளை பதிவு செய்து கண்காணிக்கவும்.
- பாதுகாப்பு குறைபாடுகளை சரிசெய்ய תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக תלாக

---

**அறிவிப்பு**:  
இந்த ஆவணம் [Co-op Translator](https://github.com/Azure/co-op-translator) என்ற AI மொழிபெயர்ப்பு சேவையை பயன்படுத்தி மொழிபெயர்க்கப்பட்டுள்ளது. நாங்கள் துல்லியத்திற்காக முயற்சித்தாலும், தானியங்கி மொழிபெயர்ப்புகளில் பிழைகள் அல்லது துல்லியக்குறைபாடுகள் இருக்கக்கூடும் என்பதை கவனத்தில் கொள்ளவும். அதன் சொந்த மொழியில் உள்ள மூல ஆவணம் அதிகாரப்பூர்வ ஆதாரமாக கருதப்பட வேண்டும். முக்கியமான தகவல்களுக்கு, தொழில்முறை மனித மொழிபெயர்ப்பு பரிந்துரைக்கப்படுகிறது. இந்த மொழிபெயர்ப்பின் பயன்பாட்டால் ஏற்படும் எந்த தவறான புரிதல்களுக்கும் அல்லது தவறான விளக்கங்களுக்கும் நாங்கள் பொறுப்பல்ல.